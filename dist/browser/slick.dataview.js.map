{
  "version": 3,
  "sources": ["../../src/slick.dataview.ts"],
  "sourcesContent": ["import type {\n  Aggregator,\n  CssStyleHash,\n  CustomDataView,\n  DataViewHints,\n  Grouping,\n  GroupingFormatterItem,\n  ItemMetadata,\n  OnGroupCollapsedEventArgs,\n  OnGroupExpandedEventArgs,\n  OnRowCountChangedEventArgs,\n  OnRowsChangedEventArgs,\n  OnRowsOrCountChangedEventArgs,\n  OnSelectedRowIdsChangedEventArgs,\n  OnSetItemsCalledEventArgs,\n  PagingInfo,\n  SlickGridModel,\n} from './models/index';\nimport {\n  type BasePubSub,\n  SlickEvent as SlickEvent_,\n  SlickEventData as SlickEventData_,\n  SlickGroup as SlickGroup_,\n  SlickGroupTotals as SlickGroupTotals_,\n  Utils as Utils_,\n  SlickNonDataItem,\n} from './slick.core';\nimport { SlickGroupItemMetadataProvider as SlickGroupItemMetadataProvider_ } from './slick.groupitemmetadataprovider';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst SlickEventData = IIFE_ONLY ? Slick.EventData : SlickEventData_;\nconst SlickGroup = IIFE_ONLY ? Slick.Group : SlickGroup_;\nconst SlickGroupTotals = IIFE_ONLY ? Slick.GroupTotals : SlickGroupTotals_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\nconst SlickGroupItemMetadataProvider = IIFE_ONLY ? Slick.Data?.GroupItemMetadataProvider ?? {} : SlickGroupItemMetadataProvider_;\n\nexport interface DataViewOption {\n  groupItemMetadataProvider: SlickGroupItemMetadataProvider_ | null;\n  inlineFilters: boolean;\n  useCSPSafeFilter: boolean;\n}\nexport type FilterFn<T> = (item: T, args: any) => boolean;\nexport type FilterCspFn<T> = (item: T[], args: any) => T[];\nexport type FilterWithCspCachingFn<T> = (item: T[], args: any, filterCache: any[]) => T[];\nexport type DataIdType = number | string;\nexport type SlickDataItem = SlickNonDataItem | SlickGroup_ | SlickGroupTotals_ | any;\nexport type GroupGetterFn = (val: any) => string | number;\nexport type AnyFunction = (...args: any[]) => any;\n\n/**\n   * A sample Model implementation.\n   * Provides a filtered view of the underlying data.\n   *\n   * Relies on the data item having an \"id\" property uniquely identifying it.\n   */\nexport class SlickDataView<TData extends SlickDataItem = any> implements CustomDataView {\n  protected defaults: DataViewOption = {\n    groupItemMetadataProvider: null,\n    inlineFilters: false,\n    useCSPSafeFilter: false,\n  };\n\n  // private\n  protected idProperty = 'id';          // property holding a unique row id\n  protected items: TData[] = [];            // data by index\n  protected rows: TData[] = [];             // data by row\n  protected idxById = new Map<DataIdType, number>();   // indexes by id\n  protected rowsById: { [id: DataIdType]: number } | undefined = undefined;       // rows by id; lazy-calculated\n  protected filter: FilterFn<TData> | null = null;         // filter function\n  protected filterCSPSafe: FilterFn<TData> | null = null;         // filter function\n  protected updated: ({ [id: DataIdType]: boolean }) | null = null;        // updated item ids\n  protected suspend = false;            // suspends the recalculation\n  protected isBulkSuspend = false;      // delays protectedious operations like the\n  // index update and delete to efficient\n  // versions at endUpdate\n  protected bulkDeleteIds = new Map<DataIdType, boolean>();\n  protected sortAsc: boolean | undefined = true;\n  protected fastSortField?: string | null | (() => string);\n  protected sortComparer!: ((a: TData, b: TData) => number);\n  protected refreshHints: DataViewHints = {};\n  protected prevRefreshHints: DataViewHints = {};\n  protected filterArgs: any;\n  protected filteredItems: TData[] = [];\n  protected compiledFilter?: FilterFn<TData> | null;\n  protected compiledFilterCSPSafe?: FilterCspFn<TData> | null;\n  protected compiledFilterWithCaching?: FilterFn<TData> | null;\n  protected compiledFilterWithCachingCSPSafe?: FilterWithCspCachingFn<TData> | null;\n  protected filterCache: any[] = [];\n  protected _grid?: SlickGridModel; // grid object will be defined only after using \"syncGridSelection()\" method\"\n\n  // grouping\n  protected groupingInfoDefaults: Grouping = {\n    getter: undefined,\n    formatter: undefined,\n    comparer: (a: { value: any; }, b: { value: any; }) => (a.value === b.value ? 0 : (a.value > b.value ? 1 : -1)),\n    predefinedValues: [],\n    aggregators: [],\n    aggregateEmpty: false,\n    aggregateCollapsed: false,\n    aggregateChildGroups: false,\n    collapsed: false,\n    displayTotalsRow: true,\n    lazyTotalsCalculation: false\n  };\n  protected groupingInfos: Array<Grouping & { aggregators: Aggregator[]; getterIsAFn?: boolean; compiledAccumulators: any[]; getter: GroupGetterFn | string }> = [];\n  protected groups: SlickGroup_[] = [];\n  protected toggledGroupsByLevel: any[] = [];\n  protected groupingDelimiter = ':|:';\n  protected selectedRowIds: DataIdType[] = [];\n  protected preSelectedRowIdsChangeFn?: (args?: any) => void;\n\n  protected pagesize = 0;\n  protected pagenum = 0;\n  protected totalRows = 0;\n  protected _options: DataViewOption;\n  protected _container?: HTMLElement;\n\n  // public events\n  onBeforePagingInfoChanged: SlickEvent_<PagingInfo>;\n  onGroupExpanded: SlickEvent_<OnGroupExpandedEventArgs>;\n  onGroupCollapsed: SlickEvent_<OnGroupCollapsedEventArgs>;\n  onPagingInfoChanged: SlickEvent_<PagingInfo>;\n  onRowCountChanged: SlickEvent_<OnRowCountChangedEventArgs>;\n  onRowsChanged: SlickEvent_<OnRowsChangedEventArgs>;\n  onRowsOrCountChanged: SlickEvent_<OnRowsOrCountChangedEventArgs>;\n  onSelectedRowIdsChanged: SlickEvent_<OnSelectedRowIdsChangedEventArgs>;\n  onSetItemsCalled: SlickEvent_<OnSetItemsCalledEventArgs>;\n\n  constructor(options: Partial<DataViewOption>, protected externalPubSub?: BasePubSub) {\n    this.onBeforePagingInfoChanged = new SlickEvent<PagingInfo>('onBeforePagingInfoChanged', externalPubSub);\n    this.onGroupExpanded = new SlickEvent<OnGroupExpandedEventArgs>('onGroupExpanded', externalPubSub);\n    this.onGroupCollapsed = new SlickEvent<OnGroupCollapsedEventArgs>('onGroupCollapsed', externalPubSub);\n    this.onPagingInfoChanged = new SlickEvent<PagingInfo>('onPagingInfoChanged', externalPubSub);\n    this.onRowCountChanged = new SlickEvent<OnRowCountChangedEventArgs>('onRowCountChanged', externalPubSub);\n    this.onRowsChanged = new SlickEvent<OnRowsChangedEventArgs>('onRowsChanged', externalPubSub);\n    this.onRowsOrCountChanged = new SlickEvent<OnRowsOrCountChangedEventArgs>('onRowsOrCountChanged', externalPubSub);\n    this.onSelectedRowIdsChanged = new SlickEvent<OnSelectedRowIdsChangedEventArgs>('onSelectedRowIdsChanged', externalPubSub);\n    this.onSetItemsCalled = new SlickEvent<OnSetItemsCalledEventArgs>('onSetItemsCalled', externalPubSub);\n\n    this._options = Utils.extend(true, {}, this.defaults, options);\n  }\n\n  /**\n   * Begins a bached update of the items in the data view.\n   * including deletes and the related events are postponed to the endUpdate call.\n   * As certain operations are postponed during this update, some methods might not\n   * deliver fully consistent information.\n   * @param {Boolean} [bulkUpdate] - if set to true, most data view modifications\n   */\n  beginUpdate(bulkUpdate?: boolean) {\n    this.suspend = true;\n    this.isBulkSuspend = bulkUpdate === true;\n  }\n\n  endUpdate() {\n    const wasBulkSuspend = this.isBulkSuspend;\n    this.isBulkSuspend = false;\n    this.suspend = false;\n    if (wasBulkSuspend) {\n      this.processBulkDelete();\n      this.ensureIdUniqueness();\n    }\n    this.refresh();\n  }\n\n  destroy() {\n    this.items = [];\n    this.idxById = null as any;\n    this.rowsById = null as any;\n    this.filter = null as any;\n    this.filterCSPSafe = null as any;\n    this.updated = null as any;\n    this.sortComparer = null as any;\n    this.filterCache = [];\n    this.filteredItems = [];\n    this.compiledFilter = null;\n    this.compiledFilterCSPSafe = null;\n    this.compiledFilterWithCaching = null;\n    this.compiledFilterWithCachingCSPSafe = null;\n\n    if (this._grid && this._grid.onSelectedRowsChanged && this._grid.onCellCssStylesChanged) {\n      this._grid.onSelectedRowsChanged.unsubscribe();\n      this._grid.onCellCssStylesChanged.unsubscribe();\n    }\n    if (this.onRowsOrCountChanged) {\n      this.onRowsOrCountChanged.unsubscribe();\n    }\n  }\n\n  /** provide some refresh hints as to what to rows needs refresh */\n  setRefreshHints(hints: DataViewHints) {\n    this.refreshHints = hints;\n  }\n\n  /** add extra filter arguments to the filter method */\n  setFilterArgs(args: any) {\n    this.filterArgs = args;\n  }\n\n  /**\n   * Processes all delete requests placed during bulk update\n   * by recomputing the items and idxById members.\n   */\n  protected processBulkDelete() {\n    if (!this.idxById) { return; }\n\n    // the bulk update is processed by\n    // recomputing the whole items array and the index lookup in one go.\n    // this is done by placing the not-deleted items\n    // from left to right into the array and shrink the array the the new\n    // size afterwards.\n    // see https://github.com/6pac/SlickGrid/issues/571 for further details.\n\n    let id: DataIdType, item, newIdx = 0;\n    for (let i = 0, l = this.items.length; i < l; i++) {\n      item = this.items[i];\n      id = item[this.idProperty as keyof TData] as DataIdType;\n      if (id === undefined) {\n        throw new Error(\"[SlickGrid DataView] Each data element must implement a unique 'id' property\");\n      }\n\n      // if items have been marked as deleted we skip them for the new final items array\n      // and we remove them from the lookup table.\n      if (this.bulkDeleteIds.has(id)) {\n        this.idxById.delete(id);\n      } else {\n        // for items which are not deleted, we add them to the\n        // next free position in the array and register the index in the lookup.\n        this.items[newIdx] = item;\n        this.idxById.set(id, newIdx);\n        ++newIdx;\n      }\n    }\n\n    // here we shrink down the full item array to the ones actually\n    // inserted in the cleanup loop above.\n    this.items.length = newIdx;\n    // and finally cleanup the deleted ids to start cleanly on the next update.\n    this.bulkDeleteIds = new Map();\n  }\n\n  protected updateIdxById(startingIndex?: number) {\n    if (this.isBulkSuspend || !this.idxById) { // during bulk update we do not reorganize\n      return;\n    }\n    startingIndex = startingIndex || 0;\n    let id: DataIdType;\n    for (let i = startingIndex, l = this.items.length; i < l; i++) {\n      id = this.items[i][this.idProperty as keyof TData] as DataIdType;\n      if (id === undefined) {\n        throw new Error(\"[SlickGrid DataView] Each data element must implement a unique 'id' property\");\n      }\n      this.idxById.set(id, i);\n    }\n  }\n\n  protected ensureIdUniqueness() {\n    if (this.isBulkSuspend || !this.idxById) { // during bulk update we do not reorganize\n      return;\n    }\n    let id: DataIdType;\n    for (let i = 0, l = this.items.length; i < l; i++) {\n      id = this.items[i][this.idProperty as keyof TData] as DataIdType;\n      if (id === undefined || this.idxById.get(id) !== i) {\n        throw new Error(\"[SlickGrid DataView] Each data element must implement a unique 'id' property\");\n      }\n    }\n  }\n\n  /** Get all DataView Items */\n  getItems() {\n    return this.items;\n  }\n\n  /** Get the DataView Id property name to use (defaults to \"Id\" but could be customized to something else when instantiating the DataView) */\n  getIdPropertyName() {\n    return this.idProperty;\n  }\n\n  /**\n   * Set the Items with a new Dataset and optionally pass a different Id property name\n   * @param {Array<*>} data - array of data\n   * @param {String} [objectIdProperty] - optional id property to use as primary id\n   */\n  setItems(data: TData[], objectIdProperty?: string) {\n    if (objectIdProperty !== undefined) {\n      this.idProperty = objectIdProperty;\n    }\n    this.items = this.filteredItems = data;\n    this.onSetItemsCalled.notify({ idProperty: this.idProperty, itemCount: this.items.length }, null, this);\n    this.idxById = new Map();\n    this.updateIdxById();\n    this.ensureIdUniqueness();\n    this.refresh();\n  }\n\n  /** Set Paging Options */\n  setPagingOptions(args: Partial<PagingInfo>) {\n    if (this.onBeforePagingInfoChanged.notify(this.getPagingInfo(), null, this).getReturnValue() !== false) {\n      if (Utils.isDefined(args.pageSize)) {\n        this.pagesize = args.pageSize;\n        this.pagenum = this.pagesize ? Math.min(this.pagenum, Math.max(0, Math.ceil(this.totalRows / this.pagesize) - 1)) : 0;\n      }\n\n      if (Utils.isDefined(args.pageNum)) {\n        this.pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(this.totalRows / this.pagesize) - 1));\n      }\n\n      this.onPagingInfoChanged.notify(this.getPagingInfo(), null, this);\n\n      this.refresh();\n    }\n  }\n\n  /** Get Paging Options */\n  getPagingInfo(): PagingInfo {\n    const totalPages = this.pagesize ? Math.max(1, Math.ceil(this.totalRows / this.pagesize)) : 1;\n    return { pageSize: this.pagesize, pageNum: this.pagenum, totalRows: this.totalRows, totalPages, dataView: this as SlickDataView };\n  }\n\n  /** Sort Method to use by the DataView */\n  sort(comparer: (a: TData, b: TData) => number, ascending?: boolean) {\n    this.sortAsc = ascending;\n    this.sortComparer = comparer;\n    this.fastSortField = null;\n    if (ascending === false) {\n      this.items.reverse();\n    }\n    this.items.sort(comparer);\n    if (ascending === false) {\n      this.items.reverse();\n    }\n    this.idxById = new Map();\n    this.updateIdxById();\n    this.refresh();\n  }\n\n  /**\n   * Provides a workaround for the extremely slow sorting in IE.\n   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n   * to return the value of that field and then doing a native Array.sort().\n   */\n  fastSort(field: string | (() => string), ascending?: boolean) {\n    this.sortAsc = ascending;\n    this.fastSortField = field;\n    this.sortComparer = null as any;\n    const oldToString = Object.prototype.toString;\n    Object.prototype.toString = (typeof field === 'function') ? field : function () {\n      // @ts-ignore\n      return this[field];\n    };\n    // an extra reversal for descending sort keeps the sort stable\n    // (assuming a stable native sort implementation, which isn't true in some cases)\n    if (ascending === false) {\n      this.items.reverse();\n    }\n    this.items.sort();\n    Object.prototype.toString = oldToString;\n    if (ascending === false) {\n      this.items.reverse();\n    }\n    this.idxById = new Map();\n    this.updateIdxById();\n    this.refresh();\n  }\n\n  /** Re-Sort the dataset */\n  reSort() {\n    if (this.sortComparer) {\n      this.sort(this.sortComparer, this.sortAsc);\n    } else if (this.fastSortField) {\n      this.fastSort(this.fastSortField, this.sortAsc);\n    }\n  }\n\n  /** Get only the DataView filtered items */\n  getFilteredItems<T extends TData>() {\n    return this.filteredItems as T[];\n  }\n\n  /** Get the array length (count) of only the DataView filtered items */\n  getFilteredItemCount() {\n    return this.filteredItems.length;\n  }\n\n  /** Get current Filter used by the DataView */\n  getFilter() {\n    return this._options.useCSPSafeFilter ? this.filterCSPSafe : this.filter;\n  }\n\n  /**\n   * Set a Filter that will be used by the DataView\n   * @param {Function} fn - filter callback function\n   */\n  setFilter(filterFn: FilterFn<TData>) {\n    this.filterCSPSafe = filterFn;\n    this.filter = filterFn;\n    if (this._options.inlineFilters) {\n      this.compiledFilterCSPSafe = this.compileFilterCSPSafe;\n      this.compiledFilterWithCachingCSPSafe = this.compileFilterWithCachingCSPSafe;\n      this.compiledFilter = this.compileFilter(this._options.useCSPSafeFilter);\n      this.compiledFilterWithCaching = this.compileFilterWithCaching(this._options.useCSPSafeFilter);\n    }\n    this.refresh();\n  }\n\n  /** Get current Grouping info */\n  getGrouping(): Grouping[] {\n    return this.groupingInfos;\n  }\n\n  /** Set some Grouping */\n  setGrouping(groupingInfo: Grouping | Grouping[]) {\n    if (!this._options.groupItemMetadataProvider) {\n      this._options.groupItemMetadataProvider = new SlickGroupItemMetadataProvider();\n    }\n\n    this.groups = [];\n    this.toggledGroupsByLevel = [];\n    groupingInfo = groupingInfo || [];\n    this.groupingInfos = ((groupingInfo instanceof Array) ? groupingInfo : [groupingInfo]) as any;\n\n    for (let i = 0; i < this.groupingInfos.length; i++) {\n      const gi = this.groupingInfos[i] = Utils.extend(true, {}, this.groupingInfoDefaults, this.groupingInfos[i]);\n      gi.getterIsAFn = typeof gi.getter === 'function';\n\n      // pre-compile accumulator loops\n      gi.compiledAccumulators = [];\n      let idx = gi.aggregators.length;\n      while (idx--) {\n        gi.compiledAccumulators[idx] = this.compileAccumulatorLoop(gi.aggregators[idx]);\n      }\n\n      this.toggledGroupsByLevel[i] = {};\n    }\n\n    this.refresh();\n  }\n\n  /** Get an item in the DataView by its row index */\n  getItemByIdx<T extends TData>(i: number) {\n    return this.items[i] as T;\n  }\n\n  /** Get row index in the DataView by its Id */\n  getIdxById(id: DataIdType) {\n    return this.idxById?.get(id);\n  }\n\n  protected ensureRowsByIdCache() {\n    if (!this.rowsById) {\n      this.rowsById = {};\n      for (let i = 0, l = this.rows.length; i < l; i++) {\n        this.rowsById[this.rows[i][this.idProperty as keyof TData] as DataIdType] = i;\n      }\n    }\n  }\n\n  /** Get row number in the grid by its item object */\n  getRowByItem(item: TData) {\n    this.ensureRowsByIdCache();\n    return this.rowsById?.[item[this.idProperty as keyof TData] as DataIdType];\n  }\n\n  /** Get row number in the grid by its Id */\n  getRowById(id: DataIdType) {\n    this.ensureRowsByIdCache();\n    return this.rowsById?.[id];\n  }\n\n  /** Get an item in the DataView by its Id */\n  getItemById<T extends TData>(id: DataIdType) {\n    return this.items[(this.idxById.get(id) as number)] as T;\n  }\n\n  /** From the items array provided, return the mapped rows */\n  mapItemsToRows(itemArray: TData[]) {\n    const rows: number[] = [];\n    this.ensureRowsByIdCache();\n    for (let i = 0, l = itemArray.length; i < l; i++) {\n      const row = this.rowsById?.[itemArray[i][this.idProperty as keyof TData] as DataIdType];\n      if (Utils.isDefined(row)) {\n        rows[rows.length] = row as number;\n      }\n    }\n    return rows;\n  }\n\n  /** From the Ids array provided, return the mapped rows */\n  mapIdsToRows(idArray: DataIdType[]) {\n    const rows: number[] = [];\n    this.ensureRowsByIdCache();\n    for (let i = 0, l = idArray.length; i < l; i++) {\n      const row = this.rowsById?.[idArray[i]];\n      if (Utils.isDefined(row)) {\n        rows[rows.length] = row as number;\n      }\n    }\n    return rows;\n  }\n\n  /** From the rows array provided, return the mapped Ids */\n  mapRowsToIds(rowArray: number[]) {\n    const ids: DataIdType[] = [];\n    for (let i = 0, l = rowArray.length; i < l; i++) {\n      if (rowArray[i] < this.rows.length) {\n        const rowItem = this.rows[rowArray[i]];\n        ids[ids.length] = rowItem![this.idProperty as keyof TData] as DataIdType;\n      }\n    }\n    return ids;\n  }\n\n  /**\n   * Performs the update operations of a single item by id without\n   * triggering any events or refresh operations.\n   * @param id The new id of the item.\n   * @param item The item which should be the new value for the given id.\n   */\n  updateSingleItem(id: DataIdType, item: TData) {\n    if (!this.idxById) { return; }\n\n    // see also https://github.com/mleibman/SlickGrid/issues/1082\n    if (!this.idxById.has(id)) {\n      throw new Error('[SlickGrid DataView] Invalid id');\n    }\n\n    // What if the specified item also has an updated idProperty?\n    // Then we'll have to update the index as well, and possibly the `updated` cache too.\n    if (id !== item[this.idProperty as keyof TData]) {\n      // make sure the new id is unique:\n      const newId = item[this.idProperty as keyof TData] as DataIdType;\n      if (!Utils.isDefined(newId)) {\n        throw new Error('[SlickGrid DataView] Cannot update item to associate with a null id');\n      }\n      if (this.idxById.has(newId)) {\n        throw new Error('[SlickGrid DataView] Cannot update item to associate with a non-unique id');\n      }\n      this.idxById.set(newId, this.idxById.get(id) as number);\n      this.idxById.delete(id);\n\n      // Also update the `updated` hashtable/markercache? Yes, `recalc()` inside `refresh()` needs that one!\n      if (this.updated?.[id]) {\n        delete this.updated[id];\n      }\n\n      // Also update the row indexes? no need since the `refresh()`, further down, blows away the `rowsById[]` cache!\n\n      id = newId;\n    }\n    this.items[this.idxById.get(id) as number] = item;\n\n    // Also update the rows? no need since the `refresh()`, further down, blows away the `rows[]` cache and recalculates it via `recalc()`!\n\n    if (!this.updated) {\n      this.updated = {};\n    }\n    this.updated[id] = true;\n  }\n\n  /**\n   * Updates a single item in the data view given the id and new value.\n   * @param id The new id of the item.\n   * @param item The item which should be the new value for the given id.\n   */\n  updateItem<T extends TData>(id: DataIdType, item: T) {\n    this.updateSingleItem(id, item);\n    this.refresh();\n  }\n\n  /**\n   * Updates multiple items in the data view given the new ids and new values.\n   * @param id {Array} The array of new ids which is in the same order as the items.\n   * @param newItems {Array} The new items that should be set in the data view for the given ids.\n   */\n  updateItems<T extends TData>(ids: DataIdType[], newItems: T[]) {\n    if (ids.length !== newItems.length) {\n      throw new Error(\"[SlickGrid DataView] Mismatch on the length of ids and items provided to update\");\n    }\n    for (let i = 0, l = newItems.length; i < l; i++) {\n      this.updateSingleItem(ids[i], newItems[i]);\n    }\n    this.refresh();\n  }\n\n  /**\n   * Inserts a single item into the data view at the given position.\n   * @param insertBefore {Number} The 0-based index before which the item should be inserted.\n   * @param item The item to insert.\n   */\n  insertItem(insertBefore: number, item: TData) {\n    this.items.splice(insertBefore, 0, item);\n    this.updateIdxById(insertBefore);\n    this.refresh();\n  }\n\n  /**\n   * Inserts multiple items into the data view at the given position.\n   * @param insertBefore {Number} The 0-based index before which the items should be inserted.\n   * @param newItems {Array}  The items to insert.\n   */\n  insertItems(insertBefore: number, newItems: TData[]) {\n    // @ts-ignore\n    Array.prototype.splice.apply(this.items, [insertBefore, 0].concat(newItems));\n    this.updateIdxById(insertBefore);\n    this.refresh();\n  }\n\n  /**\n   * Adds a single item at the end of the data view.\n   * @param item The item to add at the end.\n   */\n  addItem(item: TData) {\n    this.items.push(item);\n    this.updateIdxById(this.items.length - 1);\n    this.refresh();\n  }\n\n  /**\n   * Adds multiple items at the end of the data view.\n   * @param {Array} newItems The items to add at the end.\n   */\n  addItems(newItems: TData[]) {\n    this.items = this.items.concat(newItems);\n    this.updateIdxById(this.items.length - newItems.length);\n    this.refresh();\n  }\n\n  /**\n   * Deletes a single item identified by the given id from the data view.\n   * @param {String|Number} id The id identifying the object to delete.\n   */\n  deleteItem(id: DataIdType) {\n    if (!this.idxById) { return; }\n    if (this.isBulkSuspend) {\n      this.bulkDeleteIds.set(id, true);\n    } else {\n      const idx = this.idxById.get(id);\n      if (idx === undefined) {\n        throw new Error('[SlickGrid DataView] Invalid id');\n      }\n      this.idxById.delete(id);\n      this.items.splice(idx, 1);\n      this.updateIdxById(idx);\n      this.refresh();\n    }\n  }\n\n  /**\n   * Deletes multiple item identified by the given ids from the data view.\n   * @param {Array} ids The ids of the items to delete.\n   */\n  deleteItems(ids: DataIdType[]) {\n    if (ids.length === 0 || !this.idxById) {\n      return;\n    }\n\n    if (this.isBulkSuspend) {\n      for (let i = 0, l = ids.length; i < l; i++) {\n        const id = ids[i];\n        const idx = this.idxById.get(id);\n        if (idx === undefined) {\n          throw new Error('[SlickGrid DataView] Invalid id');\n        }\n        this.bulkDeleteIds.set(id, true);\n      }\n    } else {\n      // collect all indexes\n      const indexesToDelete: number[] = [];\n      for (let i = 0, l = ids.length; i < l; i++) {\n        const id = ids[i];\n        const idx = this.idxById.get(id);\n        if (idx === undefined) {\n          throw new Error('[SlickGrid DataView] Invalid id');\n        }\n        this.idxById.delete(id);\n        indexesToDelete.push(idx);\n      }\n\n      // Remove from back to front\n      indexesToDelete.sort();\n      for (let i = indexesToDelete.length - 1; i >= 0; --i) {\n        this.items.splice(indexesToDelete[i], 1);\n      }\n\n      // update lookup from front to back\n      this.updateIdxById(indexesToDelete[0]);\n      this.refresh();\n    }\n  }\n\n  /** Add an item in a sorted dataset (a Sort function must be defined) */\n  sortedAddItem(item: TData) {\n    if (!this.sortComparer) {\n      throw new Error('[SlickGrid DataView] sortedAddItem() requires a sort comparer, use sort()');\n    }\n    this.insertItem(this.sortedIndex(item), item);\n  }\n\n  /** Update an item in a sorted dataset (a Sort function must be defined) */\n  sortedUpdateItem(id: string | number, item: TData) {\n    if (!this.idxById) { return; }\n    if (!this.idxById.has(id) || id !== item[this.idProperty as keyof TData]) {\n      throw new Error('[SlickGrid DataView] Invalid or non-matching id ' + this.idxById.get(id));\n    }\n    if (!this.sortComparer) {\n      throw new Error(\"[SlickGrid DataView] sortedUpdateItem() requires a sort comparer, use sort()\");\n    }\n    const oldItem = this.getItemById(id);\n    if (this.sortComparer(oldItem, item) !== 0) {\n      // item affects sorting -> must use sorted add\n      this.deleteItem(id);\n      this.sortedAddItem(item);\n    } else { // update does not affect sorting -> regular update works fine\n      this.updateItem(id, item);\n    }\n  }\n\n  protected sortedIndex(searchItem: TData) {\n    let low = 0;\n    let high = this.items.length;\n\n    while (low < high) {\n      const mid = low + high >>> 1;\n      if (this.sortComparer(this.items[mid], searchItem) === -1) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return low;\n  }\n\n  /** Get item count, that is the full dataset lenght of the DataView */\n  getItemCount() {\n    return this.items.length;\n  }\n\n  /** Get row count (rows displayed in current page) */\n  getLength() {\n    return this.rows.length;\n  }\n\n  /** Retrieve an item from the DataView at specific index */\n  getItem<T extends TData>(i: number) {\n    const item = this.rows[i] as T;\n\n    // if this is a group row, make sure totals are calculated and update the title\n    if ((item as SlickGroup_)?.__group && (item as SlickGroup_).totals && !(item as SlickGroup_).totals?.initialized) {\n      const gi = this.groupingInfos[(item as SlickGroup_).level];\n      if (!gi.displayTotalsRow) {\n        this.calculateTotals((item as SlickGroup_).totals);\n        (item as SlickGroup_).title = gi.formatter ? gi.formatter((item as SlickGroup_)) : (item as SlickGroup_).value;\n      }\n    }\n    // if this is a totals row, make sure it's calculated\n    else if ((item as SlickGroupTotals_)?.__groupTotals && !(item as SlickGroupTotals_).initialized) {\n      this.calculateTotals(item as SlickGroupTotals_);\n    }\n\n    return item;\n  }\n\n  getItemMetadata(i: number): ItemMetadata | null {\n    const item = this.rows[i];\n    if (item === undefined) {\n      return null;\n    }\n\n    // overrides for grouping rows\n    if ((item as SlickGroup_).__group) {\n      return this._options.groupItemMetadataProvider!.getGroupRowMetadata(item as GroupingFormatterItem);\n    }\n\n    // overrides for totals rows\n    if ((item as SlickGroupTotals_).__groupTotals) {\n      return this._options.groupItemMetadataProvider!.getTotalsRowMetadata(item as { group: GroupingFormatterItem });\n    }\n\n    return null;\n  }\n\n  protected expandCollapseAllGroups(level?: number, collapse?: boolean) {\n    if (!Utils.isDefined(level)) {\n      for (let i = 0; i < this.groupingInfos.length; i++) {\n        this.toggledGroupsByLevel[i] = {};\n        this.groupingInfos[i].collapsed = collapse;\n\n        if (collapse === true) {\n          this.onGroupCollapsed.notify({ level: i, groupingKey: null });\n        } else {\n          this.onGroupExpanded.notify({ level: i, groupingKey: null });\n        }\n      }\n    } else {\n      this.toggledGroupsByLevel[level] = {};\n      this.groupingInfos[level].collapsed = collapse;\n\n      if (collapse === true) {\n        this.onGroupCollapsed.notify({ level, groupingKey: null });\n      } else {\n        this.onGroupExpanded.notify({ level, groupingKey: null });\n      }\n    }\n    this.refresh();\n  }\n\n  /**\n   * @param {Number} [level] Optional level to collapse.  If not specified, applies to all levels.\n   */\n  collapseAllGroups(level?: number) {\n    this.expandCollapseAllGroups(level, true);\n  }\n\n  /**\n   * @param {Number} [level] Optional level to expand.  If not specified, applies to all levels.\n   */\n  expandAllGroups(level?: number) {\n    this.expandCollapseAllGroups(level, false);\n  }\n\n  expandCollapseGroup(level: number, groupingKey: string, collapse?: boolean) {\n    // @ts-ignore\n    this.toggledGroupsByLevel[level][groupingKey] = this.groupingInfos[level].collapsed ^ collapse;\n    this.refresh();\n  }\n\n  /**\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     variable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n   *     the 'high' group.\n   */\n  collapseGroup(...args: any) {\n    const calledArgs = Array.prototype.slice.call(args);\n    const arg0 = calledArgs[0];\n    let groupingKey: string;\n    let level: number;\n\n    if (args.length === 1 && arg0.indexOf(this.groupingDelimiter) !== -1) {\n      groupingKey = arg0;\n      level = arg0.split(this.groupingDelimiter).length - 1;\n    } else {\n      groupingKey = args.join(this.groupingDelimiter);\n      level = args.length - 1;\n    }\n\n    this.expandCollapseGroup(level, groupingKey, true);\n    this.onGroupCollapsed.notify({ level, groupingKey });\n  }\n\n  /**\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     variable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n   *     the 'high' group.\n   */\n  expandGroup(...args: any) {\n    const calledArgs = Array.prototype.slice.call(args);\n    const arg0 = calledArgs[0];\n    let groupingKey: string;\n    let level: number;\n\n    if (args.length === 1 && arg0.indexOf(this.groupingDelimiter) !== -1) {\n      level = arg0.split(this.groupingDelimiter).length - 1;\n      groupingKey = arg0;\n    } else {\n      level = args.length - 1;\n      groupingKey = args.join(this.groupingDelimiter);\n    }\n\n    this.expandCollapseGroup(level, groupingKey, false);\n    this.onGroupExpanded.notify({ level, groupingKey });\n  }\n\n  getGroups() {\n    return this.groups;\n  }\n\n  protected extractGroups(rows: any[], parentGroup?: SlickGroup_) {\n    let group: SlickGroup_;\n    let val: any;\n    const groups: SlickGroup_[] = [];\n    const groupsByVal: any = {};\n    let r;\n    const level = parentGroup ? parentGroup.level + 1 : 0;\n    const gi = this.groupingInfos[level];\n\n    for (let i = 0, l = gi.predefinedValues?.length ?? 0; i < l; i++) {\n      val = gi.predefinedValues?.[i];\n      group = groupsByVal[val];\n      if (!group) {\n        group = new SlickGroup();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + this.groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n    }\n\n    for (let i = 0, l = rows.length; i < l; i++) {\n      r = rows[i];\n      val = gi.getterIsAFn ? (gi.getter as GroupGetterFn)(r) : r[gi.getter as keyof TData];\n      group = groupsByVal[val];\n      if (!group) {\n        group = new SlickGroup();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + this.groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n\n      group.rows[group.count++] = r;\n    }\n\n    if (level < this.groupingInfos.length - 1) {\n      for (let i = 0; i < groups.length; i++) {\n        group = groups[i];\n        group.groups = this.extractGroups(group.rows, group);\n      }\n    }\n\n    if (groups.length) {\n      this.addTotals(groups, level);\n    }\n\n    groups.sort(this.groupingInfos[level].comparer);\n\n    return groups;\n  }\n\n  /** claculate Group Totals */\n  protected calculateTotals(totals: SlickGroupTotals_) {\n    const group = totals.group;\n    const gi = this.groupingInfos[group.level ?? 0];\n    const isLeafLevel = (group.level === this.groupingInfos.length);\n    let agg: Aggregator;\n    let idx = gi.aggregators.length;\n\n    if (!isLeafLevel && gi.aggregateChildGroups) {\n      // make sure all the subgroups are calculated\n      let i = group.groups?.length ?? 0;\n      while (i--) {\n        if (!group.groups[i].totals.initialized) {\n          this.calculateTotals(group.groups[i].totals);\n        }\n      }\n    }\n\n    while (idx--) {\n      agg = gi.aggregators[idx];\n      agg.init();\n      if (!isLeafLevel && gi.aggregateChildGroups) {\n        gi.compiledAccumulators[idx].call(agg, group.groups);\n      } else {\n        gi.compiledAccumulators[idx].call(agg, group.rows);\n      }\n      agg.storeResult(totals);\n    }\n    totals.initialized = true;\n  }\n\n  protected addGroupTotals(group: SlickGroup_) {\n    const gi = this.groupingInfos[group.level];\n    const totals = new SlickGroupTotals();\n    totals.group = group;\n    group.totals = totals;\n    if (!gi.lazyTotalsCalculation) {\n      this.calculateTotals(totals);\n    }\n  }\n\n  protected addTotals(groups: SlickGroup_[], level?: number) {\n    level = level || 0;\n    const gi = this.groupingInfos[level];\n    const groupCollapsed = gi.collapsed;\n    const toggledGroups = this.toggledGroupsByLevel[level];\n    let idx = groups.length, g;\n    while (idx--) {\n      g = groups[idx];\n\n      if (g.collapsed && !gi.aggregateCollapsed) {\n        continue;\n      }\n\n      // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n      if (g.groups) {\n        this.addTotals(g.groups, level + 1);\n      }\n\n      if (gi.aggregators?.length && (\n        gi.aggregateEmpty || g.rows.length || g.groups?.length)) {\n        this.addGroupTotals(g);\n      }\n\n      g.collapsed = (groupCollapsed as any) ^ toggledGroups[g.groupingKey];\n      g.title = gi.formatter ? gi.formatter(g) : g.value;\n    }\n  }\n\n  protected flattenGroupedRows(groups: SlickGroup_[], level?: number) {\n    level = level || 0;\n    const gi = this.groupingInfos[level];\n    const groupedRows: any[] = [];\n    let rows: any[];\n    let gl = 0;\n    let g;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      g = groups[i];\n      groupedRows[gl++] = g;\n\n      if (!g.collapsed) {\n        rows = g.groups ? this.flattenGroupedRows(g.groups, level + 1) : g.rows;\n        for (let j = 0, jj = rows.length; j < jj; j++) {\n          groupedRows[gl++] = rows[j];\n        }\n      }\n\n      if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\n        groupedRows[gl++] = g.totals;\n      }\n    }\n    return groupedRows;\n  }\n\n  protected getFunctionInfo(fn: AnyFunction) {\n    const fnStr = fn.toString();\n    const usingEs5 = fnStr.indexOf('function') >= 0; // with ES6, the word function is not present\n    const fnRegex = usingEs5 ? /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/ : /^[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n    const matches = fn.toString().match(fnRegex) || [];\n    return {\n      params: matches[1].split(','),\n      body: matches[2]\n    };\n  }\n\n  protected compileAccumulatorLoop(aggregator: Aggregator) {\n    if (aggregator.accumulate) {\n      const accumulatorInfo = this.getFunctionInfo(aggregator.accumulate);\n      const fn: any = new Function(\n        '_items',\n        'for (var ' + accumulatorInfo.params[0] + ', _i=0, _il=_items.length; _i<_il; _i++) {' +\n        accumulatorInfo.params[0] + ' = _items[_i]; ' +\n        accumulatorInfo.body +\n        '}'\n      );\n      const fnName = 'compiledAccumulatorLoop';\n      fn.displayName = fnName;\n      fn.name = this.setFunctionName(fn, fnName);\n      return fn;\n    } else {\n      return function noAccumulator() { };\n    }\n  }\n\n  protected compileFilterCSPSafe(items: TData[], args: any): TData[] {\n    if (typeof this.filterCSPSafe !== 'function') {\n      return [];\n    }\n    const _retval: TData[] = [];\n    const _il = items.length;\n\n    for (let _i = 0; _i < _il; _i++) {\n      if (this.filterCSPSafe(items[_i], args)) {\n        _retval.push(items[_i]);\n      }\n    }\n\n    return _retval;\n  }\n\n  protected compileFilter(stopRunningIfCSPSafeIsActive: boolean = false): FilterFn<TData> {\n    if(stopRunningIfCSPSafeIsActive) {\n      return null as any;\n    }\n    const filterInfo = this.getFunctionInfo(this.filter as FilterFn<TData>);\n\n    const filterPath1 = '{ continue _coreloop; }$1';\n    const filterPath2 = '{ _retval[_idx++] = $item$; continue _coreloop; }$1';\n    // make some allowances for minification - there's only so far we can go with RegEx\n    const filterBody = filterInfo.body\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n        '{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    let tpl = [\n      // 'function(_items, _args) { ',\n      'var _retval = [], _idx = 0; ',\n      'var $item$, $args$ = _args; ',\n      '_coreloop: ',\n      'for (var _i = 0, _il = _items.length; _i < _il; _i++) { ',\n      '$item$ = _items[_i]; ',\n      '$filter$; ',\n      '} ',\n      'return _retval; '\n      // '}'\n    ].join('');\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n    const fn: any = new Function('_items,_args', tpl);\n    const fnName = 'compiledFilter';\n    fn.displayName = fnName;\n    fn.name = this.setFunctionName(fn, fnName);\n    return fn;\n  }\n\n  protected compileFilterWithCaching(stopRunningIfCSPSafeIsActive: boolean = false) {\n    if(stopRunningIfCSPSafeIsActive) {\n      return null as any;\n    }\n\n    const filterInfo = this.getFunctionInfo(this.filter as FilterFn<TData>);\n\n    const filterPath1 = '{ continue _coreloop; }$1';\n    const filterPath2 = '{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1';\n    // make some allowances for minification - there's only so far we can go with RegEx\n    const filterBody = filterInfo.body\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n        '{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    let tpl = [\n      // 'function(_items, _args, _cache) { ',\n      'var _retval = [], _idx = 0; ',\n      'var $item$, $args$ = _args; ',\n      '_coreloop: ',\n      'for (var _i = 0, _il = _items.length; _i < _il; _i++) { ',\n      '$item$ = _items[_i]; ',\n      'if (_cache[_i]) { ',\n      '_retval[_idx++] = $item$; ',\n      'continue _coreloop; ',\n      '} ',\n      '$filter$; ',\n      '} ',\n      'return _retval; '\n      // '}'\n    ].join('');\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n    const fn: any = new Function('_items,_args,_cache', tpl);\n    const fnName = 'compiledFilterWithCaching';\n    fn.displayName = fnName;\n    fn.name = this.setFunctionName(fn, fnName);\n    return fn;\n  }\n\n  protected compileFilterWithCachingCSPSafe(items: TData[], args: any, filterCache: any[]): TData[] {\n    if (typeof this.filterCSPSafe !== 'function') {\n      return [];\n    }\n\n    const retval: TData[] = [];\n    const il = items.length;\n\n    for (let _i = 0; _i < il; _i++) {\n      if (filterCache[_i] || this.filterCSPSafe(items[_i], args)) {\n        retval.push(items[_i]);\n      }\n    }\n\n    return retval;\n  }\n\n  /**\n   * In ES5 we could set the function name on the fly but in ES6 this is forbidden and we need to set it through differently\n   * We can use Object.defineProperty and set it the property to writable, see MDN for reference\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n   * @param {*} fn\n   * @param {string} fnName\n   */\n  protected setFunctionName(fn: any, fnName: string) {\n    try {\n      Object.defineProperty(fn, 'name', { writable: true, value: fnName });\n    } catch (err) {\n      fn.name = fnName;\n    }\n  }\n\n  protected uncompiledFilter(items: TData[], args: any) {\n    const retval: any[] = [];\n    let idx = 0;\n\n    for (let i = 0, ii = items.length; i < ii; i++) {\n      if (this.filter?.(items[i], args)) {\n        retval[idx++] = items[i];\n      }\n    }\n\n    return retval;\n  }\n\n  protected uncompiledFilterWithCaching(items: TData[], args: any, cache: any) {\n    const retval: any[] = [];\n    let idx = 0,\n      item: TData;\n\n    for (let i = 0, ii = items.length; i < ii; i++) {\n      item = items[i];\n      if (cache[i]) {\n        retval[idx++] = item;\n      } else if (this.filter?.(item, args)) {\n        retval[idx++] = item;\n        cache[i] = true;\n      }\n    }\n\n    return retval;\n  }\n\n  protected getFilteredAndPagedItems(items: TData[]) {\n    if (this._options.useCSPSafeFilter ? this.filterCSPSafe : this.filter) {\n      let batchFilter: AnyFunction;\n      let batchFilterWithCaching: AnyFunction;\n      if (this._options.useCSPSafeFilter) {\n        batchFilter = (this._options.inlineFilters ? this.compiledFilterCSPSafe : this.uncompiledFilter) as AnyFunction;\n        batchFilterWithCaching = (this._options.inlineFilters ? this.compiledFilterWithCachingCSPSafe : this.uncompiledFilterWithCaching) as AnyFunction;\n      } else {\n        batchFilter = (this._options.inlineFilters ? this.compiledFilter : this.uncompiledFilter) as AnyFunction;\n        batchFilterWithCaching = (this._options.inlineFilters ? this.compiledFilterWithCaching : this.uncompiledFilterWithCaching) as AnyFunction;\n      }\n      if (this.refreshHints.isFilterNarrowing) {\n        this.filteredItems = batchFilter.call(this, this.filteredItems, this.filterArgs);\n      } else if (this.refreshHints.isFilterExpanding) {\n        this.filteredItems = batchFilterWithCaching.call(this, items, this.filterArgs, this.filterCache);\n      } else if (!this.refreshHints.isFilterUnchanged) {\n        this.filteredItems = batchFilter.call(this, items, this.filterArgs);\n      }\n    } else {\n      // special case:  if not filtering and not paging, the resulting\n      // rows collection needs to be a copy so that changes due to sort\n      // can be caught\n      this.filteredItems = this.pagesize ? items : items.concat();\n    }\n\n    // get the current page\n    let paged: TData[];\n    if (this.pagesize) {\n      if (this.filteredItems.length <= this.pagenum * this.pagesize) {\n        if (this.filteredItems.length === 0) {\n          this.pagenum = 0;\n        } else {\n          this.pagenum = Math.floor((this.filteredItems.length - 1) / this.pagesize);\n        }\n      }\n      paged = this.filteredItems.slice(this.pagesize * this.pagenum, this.pagesize * this.pagenum + this.pagesize);\n    } else {\n      paged = this.filteredItems;\n    }\n    return { totalRows: this.filteredItems.length, rows: paged };\n  }\n\n  protected getRowDiffs(rows: TData[], newRows: TData[]) {\n    let item: TData | SlickNonDataItem | SlickDataItem | SlickGroup_;\n    let r;\n    let eitherIsNonData;\n    const diff: number[] = [];\n    let from = 0;\n    let to = Math.max(newRows.length, rows.length);\n\n    if (this.refreshHints?.ignoreDiffsBefore) {\n      from = Math.max(0,\n        Math.min(newRows.length, this.refreshHints.ignoreDiffsBefore));\n    }\n\n    if (this.refreshHints?.ignoreDiffsAfter) {\n      to = Math.min(newRows.length,\n        Math.max(0, this.refreshHints.ignoreDiffsAfter));\n    }\n\n    for (let i = from, rl = rows.length; i < to; i++) {\n      if (i >= rl) {\n        diff[diff.length] = i;\n      } else {\n        item = newRows[i];\n        r = rows[i];\n\n        if (!item || (this.groupingInfos.length && (eitherIsNonData = ((item as SlickNonDataItem).__nonDataRow) || ((r as SlickNonDataItem).__nonDataRow)) &&\n          (item as SlickGroup_).__group !== (r as SlickGroup_).__group ||\n          (item as SlickGroup_).__group && !(item as SlickGroup_).equals(r as SlickGroup_))\n          || (eitherIsNonData &&\n            // no good way to compare totals since they are arbitrary DTOs\n            // deep object comparison is pretty expensive\n            // always considering them 'dirty' seems easier for the time being\n            ((item as SlickGroupTotals_).__groupTotals || (r as SlickGroupTotals_).__groupTotals))\n          || item[this.idProperty as keyof TData] !== r[this.idProperty as keyof TData]\n          || (this.updated?.[item[this.idProperty as keyof TData]])\n        ) {\n          diff[diff.length] = i;\n        }\n      }\n    }\n    return diff;\n  }\n\n  protected recalc(_items: TData[]) {\n    this.rowsById = undefined;\n\n    if (this.refreshHints.isFilterNarrowing !== this.prevRefreshHints.isFilterNarrowing ||\n      this.refreshHints.isFilterExpanding !== this.prevRefreshHints.isFilterExpanding) {\n      this.filterCache = [];\n    }\n\n    const filteredItems = this.getFilteredAndPagedItems(_items);\n    this.totalRows = filteredItems.totalRows;\n    let newRows: TData[] = filteredItems.rows;\n\n    this.groups = [];\n    if (this.groupingInfos.length) {\n      this.groups = this.extractGroups(newRows);\n      if (this.groups.length) {\n        newRows = this.flattenGroupedRows(this.groups);\n      }\n    }\n\n    const diff = this.getRowDiffs(this.rows, newRows as TData[]);\n\n    this.rows = newRows as TData[];\n\n    return diff;\n  }\n\n  refresh() {\n    if (this.suspend) {\n      return;\n    }\n\n    const previousPagingInfo = Utils.extend(true, {}, this.getPagingInfo());\n\n    const countBefore = this.rows.length;\n    const totalRowsBefore = this.totalRows;\n\n    let diff = this.recalc(this.items); // pass as direct refs to avoid closure perf hit\n\n    // if the current page is no longer valid, go to last page and recalc\n    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n    if (this.pagesize && this.totalRows < this.pagenum * this.pagesize) {\n      this.pagenum = Math.max(0, Math.ceil(this.totalRows / this.pagesize) - 1);\n      diff = this.recalc(this.items);\n    }\n\n    this.updated = null;\n    this.prevRefreshHints = this.refreshHints;\n    this.refreshHints = {};\n\n    if (totalRowsBefore !== this.totalRows) {\n      // use the previously saved paging info\n      if (this.onBeforePagingInfoChanged.notify(previousPagingInfo, null, this).getReturnValue() !== false) {\n        this.onPagingInfoChanged.notify(this.getPagingInfo(), null, this);\n      }\n    }\n    if (countBefore !== this.rows.length) {\n      this.onRowCountChanged.notify({ previous: countBefore, current: this.rows.length, itemCount: this.items.length, dataView: this, callingOnRowsChanged: (diff.length > 0) }, null, this);\n    }\n    if (diff.length > 0) {\n      this.onRowsChanged.notify({ rows: diff, itemCount: this.items.length, dataView: this, calledOnRowCountChanged: (countBefore !== this.rows.length) }, null, this);\n    }\n    if (countBefore !== this.rows.length || diff.length > 0) {\n      this.onRowsOrCountChanged.notify({\n        rowsDiff: diff, previousRowCount: countBefore, currentRowCount: this.rows.length, itemCount: this.items.length,\n        rowCountChanged: countBefore !== this.rows.length, rowsChanged: diff.length > 0, dataView: this\n      }, null, this);\n    }\n  }\n\n  /**\n   * Wires the grid and the DataView together to keep row selection tied to item ids.\n   * This is useful since, without it, the grid only knows about rows, so if the items\n   * move around, the same rows stay selected instead of the selection moving along\n   * with the items.\n   *\n   * NOTE:  This doesn't work with cell selection model.\n   *\n   * @param {SlickGrid} grid - The grid to sync selection with.\n   * @param {Boolean} preserveHidden - Whether to keep selected items that go out of the\n   *     view due to them getting filtered out.\n   * @param {Boolean} [preserveHiddenOnSelectionChange] - Whether to keep selected items\n   *     that are currently out of the view (see preserveHidden) as selected when selection\n   *     changes.\n   * @return {Event} An event that notifies when an internal list of selected row ids\n   *     changes.  This is useful since, in combination with the above two options, it allows\n   *     access to the full list selected row ids, and not just the ones visible to the grid.\n   * @method syncGridSelection\n   */\n  syncGridSelection(grid: SlickGridModel, preserveHidden: boolean, preserveHiddenOnSelectionChange?: boolean) {\n    this._grid = grid;\n    let inHandler: boolean;\n    this.selectedRowIds = this.mapRowsToIds(grid.getSelectedRows());\n\n    /** @param {Array} rowIds */\n    const setSelectedRowIds = (rowIds: DataIdType[] | false) => {\n      if (rowIds === false) {\n        this.selectedRowIds = [];\n      } else {\n        if (this.selectedRowIds!.sort().join(',') !== rowIds.sort().join(',')) {\n          this.selectedRowIds = rowIds;\n        }\n      }\n    };\n\n    const update = () => {\n      if ((this.selectedRowIds || []).length > 0 && !inHandler) {\n        inHandler = true;\n        const selectedRows = this.mapIdsToRows(this.selectedRowIds || []);\n        if (!preserveHidden) {\n          const selectedRowsChangedArgs = {\n            grid: this._grid,\n            ids: this.mapRowsToIds(selectedRows),\n            rows: selectedRows,\n            dataView: this\n          };\n          this.preSelectedRowIdsChangeFn!(selectedRowsChangedArgs);\n          this.onSelectedRowIdsChanged.notify(Object.assign(selectedRowsChangedArgs, {\n            selectedRowIds: this.selectedRowIds,\n            filteredIds: this.getAllSelectedFilteredIds() as DataIdType[],\n          }), new SlickEventData(), this);\n        }\n        grid.setSelectedRows(selectedRows);\n        inHandler = false;\n      }\n    };\n\n    grid.onSelectedRowsChanged.subscribe((_e: Event, args: { rows: number[]; }) => {\n      if (!inHandler) {\n        const newSelectedRowIds = this.mapRowsToIds(args.rows);\n        const selectedRowsChangedArgs = {\n          grid: this._grid,\n          ids: newSelectedRowIds,\n          rows: args.rows,\n          added: true,\n          dataView: this\n        };\n        this.preSelectedRowIdsChangeFn!(selectedRowsChangedArgs);\n        this.onSelectedRowIdsChanged.notify(Object.assign(selectedRowsChangedArgs, {\n          selectedRowIds: this.selectedRowIds,\n          filteredIds: this.getAllSelectedFilteredIds() as DataIdType[],\n        }), new SlickEventData(), this);\n      }\n    });\n\n    this.preSelectedRowIdsChangeFn = (args: { ids: DataIdType[]; added?: boolean; }) => {\n      if (!inHandler) {\n        inHandler = true;\n        const overwrite = (typeof args.added === typeof undefined);\n\n        if (overwrite) {\n          setSelectedRowIds(args.ids);\n        } else {\n          let rowIds: DataIdType[];\n          if (args.added) {\n            if (preserveHiddenOnSelectionChange && grid.getOptions().multiSelect) {\n              // find the ones that are hidden\n              const hiddenSelectedRowIds = this.selectedRowIds?.filter((id) => this.getRowById(id) === undefined);\n              // add the newly selected ones\n              rowIds = hiddenSelectedRowIds!.concat(args.ids);\n            } else {\n              rowIds = args.ids;\n            }\n          } else {\n            if (preserveHiddenOnSelectionChange && grid.getOptions().multiSelect) {\n              // remove rows whose id is on the list\n              rowIds = this.selectedRowIds!.filter((id) => args.ids.indexOf(id) === -1);\n            } else {\n              rowIds = [];\n            }\n          }\n          setSelectedRowIds(rowIds);\n        }\n        inHandler = false;\n      }\n    };\n\n    this.onRowsOrCountChanged.subscribe(update.bind(this));\n\n    return this.onSelectedRowIdsChanged;\n  }\n\n  /**\n   * Get all selected IDs\n   * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\n   */\n  getAllSelectedIds() {\n    return this.selectedRowIds;\n  }\n\n  /**\n   * Get all selected filtered IDs (similar to \"getAllSelectedIds\" but only return filtered data)\n   * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\n   */\n  getAllSelectedFilteredIds() {\n    return this.getAllSelectedFilteredItems().map((item) => item[this.idProperty as keyof TData]);\n  }\n\n  /**\n   * Set current row selected IDs array (regardless of Pagination)\n   * NOTE: This will NOT change the selection in the grid, if you need to do that then you still need to call\n   * \"grid.setSelectedRows(rows)\"\n   * @param {Array} selectedIds - list of IDs which have been selected for this action\n   * @param {Object} options\n   *  - `isRowBeingAdded`: defaults to true, are the new selected IDs being added (or removed) as new row selections\n   *  - `shouldTriggerEvent`: defaults to true, should we trigger `onSelectedRowIdsChanged` event\n   *  - `applyRowSelectionToGrid`: defaults to true, should we apply the row selections to the grid in the UI\n   */\n  setSelectedIds(selectedIds: Array<number | string>, options?: Partial<{ isRowBeingAdded: boolean; shouldTriggerEvent: boolean; applyRowSelectionToGrid: boolean; }>) {\n    let isRowBeingAdded = options?.isRowBeingAdded;\n    const shouldTriggerEvent = options?.shouldTriggerEvent;\n    const applyRowSelectionToGrid = options?.applyRowSelectionToGrid;\n\n    if (isRowBeingAdded !== false) {\n      isRowBeingAdded = true;\n    }\n    const selectedRows = this.mapIdsToRows(selectedIds);\n    const selectedRowsChangedArgs = {\n      grid: this._grid,\n      ids: selectedIds,\n      rows: selectedRows,\n      added: isRowBeingAdded,\n      dataView: this\n    };\n    this.preSelectedRowIdsChangeFn?.(selectedRowsChangedArgs);\n\n    if (shouldTriggerEvent !== false) {\n      this.onSelectedRowIdsChanged.notify(Object.assign(selectedRowsChangedArgs, {\n        selectedRowIds: this.selectedRowIds,\n        filteredIds: this.getAllSelectedFilteredIds() as DataIdType[],\n      }), new SlickEventData(), this);\n    }\n\n    // should we also apply the row selection in to the grid (UI) as well?\n    if (applyRowSelectionToGrid !== false && this._grid) {\n      this._grid.setSelectedRows(selectedRows);\n    }\n  }\n\n  /**\n   * Get all selected dataContext items\n   * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\n   */\n  getAllSelectedItems<T extends TData>() {\n    const selectedData: TData[] = [];\n    const selectedIds = this.getAllSelectedIds();\n    selectedIds!.forEach((id) => {\n      selectedData.push(this.getItemById(id));\n    });\n    return selectedData as T[];\n  }\n\n  /**\n  * Get all selected filtered dataContext items (similar to \"getAllSelectedItems\" but only return filtered data)\n  * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\n  */\n  getAllSelectedFilteredItems<T extends TData>() {\n    if (!Array.isArray(this.selectedRowIds)) {\n      return [];\n    }\n\n    const intersection = this.filteredItems.filter((a) => this.selectedRowIds!.some((b) => a[this.idProperty as keyof TData] === b));\n    return (intersection || []) as T[];\n  }\n\n  syncGridCellCssStyles(grid: SlickGridModel, key: string) {\n    let hashById: any;\n    let inHandler: boolean;\n\n    const storeCellCssStyles = (hash: CssStyleHash) => {\n      hashById = {};\n      for (const row in hash) {\n        if (hash) {\n          const id = this.rows[row as any][this.idProperty as keyof TData];\n          hashById[id] = hash[row];\n        }\n      }\n    };\n\n    // since this method can be called after the cell styles have been set,\n    // get the existing ones right away\n    storeCellCssStyles(grid.getCellCssStyles(key));\n\n    const update = () => {\n      if (hashById) {\n        inHandler = true;\n        this.ensureRowsByIdCache();\n        const newHash: CssStyleHash = {};\n        for (const id in hashById) {\n          if (hashById) {\n            const row = this.rowsById?.[id];\n            if (Utils.isDefined(row)) {\n              newHash[row] = hashById[id];\n            }\n          }\n        }\n        grid.setCellCssStyles(key, newHash);\n        inHandler = false;\n      }\n    };\n\n    grid.onCellCssStylesChanged.subscribe((_e: Event, args: any) => {\n      if (inHandler) { return; }\n      if (key !== args.key) { return; }\n      if (args.hash) {\n        storeCellCssStyles(args.hash);\n      } else {\n        grid.onCellCssStylesChanged.unsubscribe();\n        this.onRowsOrCountChanged.unsubscribe(update);\n      }\n    });\n\n    this.onRowsOrCountChanged.subscribe(update.bind(this));\n  }\n}\n\nexport class AvgAggregator<T = any> implements Aggregator {\n  private _nonNullCount = 0;\n  private _sum = 0;\n  private _field: number | string;\n  private _type = 'avg' as const;\n\n  constructor(field: number | string) {\n    this._field = field;\n  }\n\n  get field(): number | string {\n    return this._field;\n  }\n\n  get type(): string {\n    return this._type;\n  }\n\n  init(): void {\n    this._nonNullCount = 0;\n    this._sum = 0;\n  }\n\n  accumulate(item: T) {\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\n    if (val !== null && val !== '' && !isNaN(val)) {\n      this._nonNullCount++;\n      this._sum += parseFloat(val);\n    }\n  }\n\n  storeResult(groupTotals: SlickGroupTotals_ & { avg: Record<number | string, number>; }) {\n    if (!groupTotals || groupTotals[this._type] === undefined) {\n      (groupTotals as any)[this._type] = {};\n    }\n    if (this._nonNullCount !== 0) {\n      groupTotals[this._type][this._field] = this._sum / this._nonNullCount;\n    }\n  }\n}\n\nexport class MinAggregator<T = any> implements Aggregator {\n  private _min: number | null = null;\n  private _field: number | string;\n  private _type = 'min' as const;\n\n  constructor(field: number | string) {\n    this._field = field;\n  }\n\n  get field(): number | string {\n    return this._field;\n  }\n\n  get type(): string {\n    return this._type;\n  }\n\n  init() {\n    this._min = null;\n  }\n\n  accumulate(item: T) {\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\n    if (val !== null && val !== '' && !isNaN(val)) {\n      if (this._min === null || val < this._min) {\n        this._min = parseFloat(val);\n      }\n    }\n  }\n\n  storeResult(groupTotals: SlickGroupTotals_ & { min: Record<number | string, number | null>; }) {\n    if (!groupTotals || groupTotals[this._type] === undefined) {\n      groupTotals[this._type] = {};\n    }\n    groupTotals[this._type][this._field] = this._min;\n  }\n}\n\nexport class MaxAggregator<T = any> implements Aggregator {\n  private _max: number | null = null;\n  private _field: number | string;\n  private _type = 'max' as const;\n\n  constructor(field: number | string) {\n    this._field = field;\n  }\n\n  get field(): number | string {\n    return this._field;\n  }\n\n  get type(): string {\n    return this._type;\n  }\n\n  init(): void {\n    this._max = null;\n  }\n\n  accumulate(item: T) {\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\n    if (val !== null && val !== '' && !isNaN(val)) {\n      if (this._max === null || val > this._max) {\n        this._max = parseFloat(val);\n      }\n    }\n  }\n\n  storeResult(groupTotals: SlickGroupTotals_ & { max: Record<number | string, number | null>; }) {\n    if (!groupTotals || groupTotals[this._type] === undefined) {\n      groupTotals[this._type] = {};\n    }\n    groupTotals[this._type][this._field] = this._max;\n  }\n}\n\nexport class SumAggregator<T = any> implements Aggregator {\n  private _sum = 0;\n  private _field: number | string;\n  private _type = 'sum' as const;\n\n  constructor(field: number | string) {\n    this._field = field;\n  }\n\n  get field(): number | string {\n    return this._field;\n  }\n\n  get type(): string {\n    return this._type;\n  }\n\n  init() {\n    this._sum = 0;\n  }\n\n  accumulate(item: T) {\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\n    if (val !== null && val !== '' && !isNaN(val)) {\n      this._sum += parseFloat(val);\n    }\n  }\n\n  storeResult(groupTotals: SlickGroupTotals_ & { sum: Record<number | string, number>; }) {\n    if (!groupTotals || groupTotals[this._type] === undefined) {\n      groupTotals[this._type] = {};\n    }\n    groupTotals[this._type][this._field] = this._sum;\n  }\n}\n\nexport class CountAggregator implements Aggregator {\n  private _field: number | string;\n  private _type = 'count' as const;\n\n  constructor(field: number | string) {\n    this._field = field;\n  }\n\n  get field(): number | string {\n    return this._field;\n  }\n\n  get type(): string {\n    return this._type;\n  }\n\n  init(): void {\n  }\n\n  storeResult(groupTotals: SlickGroupTotals_ & { count: Record<number | string, number>; }) {\n    if (!groupTotals || groupTotals[this._type] === undefined) {\n      groupTotals[this._type] = {};\n    }\n    groupTotals[this._type][this._field] = groupTotals.group.rows.length;\n  }\n}\n\n// TODO:  add more built-in aggregators\n// TODO:  merge common aggregators in one to prevent needless iterating\n\nexport const Aggregators = {\n  Avg: AvgAggregator,\n  Min: MinAggregator,\n  Max: MaxAggregator,\n  Sum: SumAggregator,\n  Count: CountAggregator\n};\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  window.Slick.Data = window.Slick.Data || {};\n  window.Slick.Data.DataView = SlickDataView;\n  window.Slick.Data.Aggregators = Aggregators;\n}"],
  "mappings": "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",
  "names": ["_a", "_b"]
}
