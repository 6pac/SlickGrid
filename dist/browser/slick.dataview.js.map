{
  "version": 3,
  "sources": ["../../src/slick.dataview.ts"],
  "sourcesContent": ["import type {\r\n  Aggregator,\r\n  AnyFunction,\r\n  CssStyleHash,\r\n  CustomDataView,\r\n  DataViewHints,\r\n  Grouping,\r\n  GroupingFormatterItem,\r\n  ItemMetadata,\r\n  ItemMetadataProvider,\r\n  OnGroupCollapsedEventArgs,\r\n  OnGroupExpandedEventArgs,\r\n  OnRowCountChangedEventArgs,\r\n  OnRowsChangedEventArgs,\r\n  OnRowsOrCountChangedEventArgs,\r\n  OnSelectedRowIdsChangedEventArgs,\r\n  OnSetItemsCalledEventArgs,\r\n  PagingInfo,\r\n  SlickGridModel,\r\n} from './models/index.js';\r\nimport {\r\n  type BasePubSub,\r\n  SlickEvent as SlickEvent_,\r\n  SlickEventData as SlickEventData_,\r\n  SlickGroup as SlickGroup_,\r\n  SlickGroupTotals as SlickGroupTotals_,\r\n  Utils as Utils_,\r\n  type SlickNonDataItem,\r\n} from './slick.core.js';\r\nimport { SlickGroupItemMetadataProvider as SlickGroupItemMetadataProvider_ } from './slick.groupitemmetadataprovider.js';\r\n\r\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\r\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\r\nconst SlickEventData = IIFE_ONLY ? Slick.EventData : SlickEventData_;\r\nconst SlickGroup = IIFE_ONLY ? Slick.Group : SlickGroup_;\r\nconst SlickGroupTotals = IIFE_ONLY ? Slick.GroupTotals : SlickGroupTotals_;\r\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\r\nconst SlickGroupItemMetadataProvider = IIFE_ONLY ? Slick.Data?.GroupItemMetadataProvider ?? {} : SlickGroupItemMetadataProvider_;\r\n\r\nexport interface DataViewOption {\r\n  /** global override for all rows */\r\n  globalItemMetadataProvider: ItemMetadataProvider | null;\r\n\r\n  /** Optionally provide a GroupItemMetadataProvider in order to use Grouping/DraggableGrouping features */\r\n  groupItemMetadataProvider: SlickGroupItemMetadataProvider_ | null;\r\n\r\n  /** defaults to false, are we using inline filters? */\r\n  inlineFilters: boolean;\r\n\r\n  /**\r\n   * defaults to false, option to use CSP Safe approach,\r\n   * Note: it is an opt-in option because it is slightly slower (perf impact) when compared to the non-CSP safe approach.\r\n   */\r\n  useCSPSafeFilter: boolean;\r\n}\r\nexport type FilterFn<T> = (item: T, args: any) => boolean;\r\nexport type FilterCspFn<T> = (item: T[], args: any) => T[];\r\nexport type FilterWithCspCachingFn<T> = (item: T[], args: any, filterCache: any[]) => T[];\r\nexport type DataIdType = number | string;\r\nexport type SlickDataItem = SlickNonDataItem | SlickGroup_ | SlickGroupTotals_ | any;\r\nexport type GroupGetterFn = (val: any) => string | number;\r\n\r\n/**\r\n  * A simple Model implementation.\r\n  * Provides a filtered view of the underlying data.\r\n  * Relies on the data item having an \"id\" property uniquely identifying it.\r\n  */\r\nexport class SlickDataView<TData extends SlickDataItem = any> implements CustomDataView {\r\n  protected defaults: DataViewOption = {\r\n    globalItemMetadataProvider: null,\r\n    groupItemMetadataProvider: null,\r\n    inlineFilters: false,\r\n    useCSPSafeFilter: false,\r\n  };\r\n\r\n  // private\r\n  protected idProperty = 'id';          // property holding a unique row id\r\n  protected items: TData[] = [];            // data by index\r\n  protected rows: TData[] = [];             // data by row\r\n  protected idxById = new Map<DataIdType, number>();   // indexes by id\r\n  protected rowsById: { [id: DataIdType]: number } | undefined = undefined;       // rows by id; lazy-calculated\r\n  protected filter: FilterFn<TData> | null = null;         // filter function\r\n  protected filterCSPSafe: FilterFn<TData> | null = null;         // filter function\r\n  protected updated: ({ [id: DataIdType]: boolean }) | null = null;        // updated item ids\r\n  protected suspend = false;            // suspends the recalculation\r\n  protected isBulkSuspend = false;      // delays protectedious operations like the\r\n  // index update and delete to efficient\r\n  // versions at endUpdate\r\n  protected bulkDeleteIds = new Map<DataIdType, boolean>();\r\n  protected sortAsc: boolean | undefined = true;\r\n  protected fastSortField?: string | null | (() => string);\r\n  protected sortComparer!: ((a: TData, b: TData) => number);\r\n  protected refreshHints: DataViewHints = {};\r\n  protected prevRefreshHints: DataViewHints = {};\r\n  protected filterArgs: any;\r\n  protected filteredItems: TData[] = [];\r\n  protected compiledFilter?: FilterFn<TData> | null;\r\n  protected compiledFilterCSPSafe?: FilterCspFn<TData> | null;\r\n  protected compiledFilterWithCaching?: FilterFn<TData> | null;\r\n  protected compiledFilterWithCachingCSPSafe?: FilterWithCspCachingFn<TData> | null;\r\n  protected filterCache: any[] = [];\r\n  protected _grid?: SlickGridModel; // grid object will be defined only after using \"syncGridSelection()\" method\"\r\n\r\n  // grouping\r\n  protected groupingInfoDefaults: Grouping = {\r\n    getter: undefined,\r\n    formatter: undefined,\r\n    comparer: (a: { value: any; }, b: { value: any; }) => (a.value === b.value ? 0 : (a.value > b.value ? 1 : -1)),\r\n    predefinedValues: [],\r\n    aggregators: [],\r\n    aggregateEmpty: false,\r\n    aggregateCollapsed: false,\r\n    aggregateChildGroups: false,\r\n    collapsed: false,\r\n    displayTotalsRow: true,\r\n    lazyTotalsCalculation: false\r\n  };\r\n  protected groupingInfos: Array<Grouping & { aggregators: Aggregator[]; getterIsAFn?: boolean; compiledAccumulators: any[]; getter: GroupGetterFn | string }> = [];\r\n  protected groups: SlickGroup_[] = [];\r\n  protected toggledGroupsByLevel: any[] = [];\r\n  protected groupingDelimiter = ':|:';\r\n  protected selectedRowIds: DataIdType[] = [];\r\n  protected preSelectedRowIdsChangeFn?: (args?: any) => void;\r\n\r\n  protected pagesize = 0;\r\n  protected pagenum = 0;\r\n  protected totalRows = 0;\r\n  protected _options: DataViewOption;\r\n  protected _container?: HTMLElement;\r\n\r\n  // public events\r\n  onBeforePagingInfoChanged: SlickEvent_<PagingInfo>;\r\n  onGroupExpanded: SlickEvent_<OnGroupExpandedEventArgs>;\r\n  onGroupCollapsed: SlickEvent_<OnGroupCollapsedEventArgs>;\r\n  onPagingInfoChanged: SlickEvent_<PagingInfo>;\r\n  onRowCountChanged: SlickEvent_<OnRowCountChangedEventArgs>;\r\n  onRowsChanged: SlickEvent_<OnRowsChangedEventArgs>;\r\n  onRowsOrCountChanged: SlickEvent_<OnRowsOrCountChangedEventArgs>;\r\n  onSelectedRowIdsChanged: SlickEvent_<OnSelectedRowIdsChangedEventArgs>;\r\n  onSetItemsCalled: SlickEvent_<OnSetItemsCalledEventArgs>;\r\n\r\n  constructor(options?: Partial<DataViewOption>, protected externalPubSub?: BasePubSub) {\r\n    this.onBeforePagingInfoChanged = new SlickEvent<PagingInfo>('onBeforePagingInfoChanged', externalPubSub);\r\n    this.onGroupExpanded = new SlickEvent<OnGroupExpandedEventArgs>('onGroupExpanded', externalPubSub);\r\n    this.onGroupCollapsed = new SlickEvent<OnGroupCollapsedEventArgs>('onGroupCollapsed', externalPubSub);\r\n    this.onPagingInfoChanged = new SlickEvent<PagingInfo>('onPagingInfoChanged', externalPubSub);\r\n    this.onRowCountChanged = new SlickEvent<OnRowCountChangedEventArgs>('onRowCountChanged', externalPubSub);\r\n    this.onRowsChanged = new SlickEvent<OnRowsChangedEventArgs>('onRowsChanged', externalPubSub);\r\n    this.onRowsOrCountChanged = new SlickEvent<OnRowsOrCountChangedEventArgs>('onRowsOrCountChanged', externalPubSub);\r\n    this.onSelectedRowIdsChanged = new SlickEvent<OnSelectedRowIdsChangedEventArgs>('onSelectedRowIdsChanged', externalPubSub);\r\n    this.onSetItemsCalled = new SlickEvent<OnSetItemsCalledEventArgs>('onSetItemsCalled', externalPubSub);\r\n\r\n    this._options = Utils.extend(true, {}, this.defaults, options);\r\n  }\r\n\r\n  /**\r\n   * Begins a bached update of the items in the data view.\r\n   * including deletes and the related events are postponed to the endUpdate call.\r\n   * As certain operations are postponed during this update, some methods might not\r\n   * deliver fully consistent information.\r\n   * @param {Boolean} [bulkUpdate] - if set to true, most data view modifications\r\n   */\r\n  beginUpdate(bulkUpdate?: boolean) {\r\n    this.suspend = true;\r\n    this.isBulkSuspend = bulkUpdate === true;\r\n  }\r\n\r\n  endUpdate() {\r\n    const wasBulkSuspend = this.isBulkSuspend;\r\n    this.isBulkSuspend = false;\r\n    this.suspend = false;\r\n    if (wasBulkSuspend) {\r\n      this.processBulkDelete();\r\n      this.ensureIdUniqueness();\r\n    }\r\n    this.refresh();\r\n  }\r\n\r\n  destroy() {\r\n    this.items = [];\r\n    this.idxById = null as any;\r\n    this.rowsById = null as any;\r\n    this.filter = null as any;\r\n    this.filterCSPSafe = null as any;\r\n    this.updated = null as any;\r\n    this.sortComparer = null as any;\r\n    this.filterCache = [];\r\n    this.filteredItems = [];\r\n    this.compiledFilter = null;\r\n    this.compiledFilterCSPSafe = null;\r\n    this.compiledFilterWithCaching = null;\r\n    this.compiledFilterWithCachingCSPSafe = null;\r\n\r\n    if (this._grid && this._grid.onSelectedRowsChanged && this._grid.onCellCssStylesChanged) {\r\n      this._grid.onSelectedRowsChanged.unsubscribe();\r\n      this._grid.onCellCssStylesChanged.unsubscribe();\r\n    }\r\n    if (this.onRowsOrCountChanged) {\r\n      this.onRowsOrCountChanged.unsubscribe();\r\n    }\r\n  }\r\n\r\n  /** provide some refresh hints as to what to rows needs refresh */\r\n  setRefreshHints(hints: DataViewHints) {\r\n    this.refreshHints = hints;\r\n  }\r\n\r\n  /** get extra filter arguments of the filter method */\r\n  getFilterArgs() {\r\n    return this.filterArgs;\r\n  }\r\n\r\n  /** add extra filter arguments to the filter method */\r\n  setFilterArgs(args: any) {\r\n    this.filterArgs = args;\r\n  }\r\n\r\n  /**\r\n   * Processes all delete requests placed during bulk update\r\n   * by recomputing the items and idxById members.\r\n   */\r\n  protected processBulkDelete() {\r\n    if (!this.idxById) { return; }\r\n\r\n    // the bulk update is processed by\r\n    // recomputing the whole items array and the index lookup in one go.\r\n    // this is done by placing the not-deleted items\r\n    // from left to right into the array and shrink the array the the new\r\n    // size afterwards.\r\n    // see https://github.com/6pac/SlickGrid/issues/571 for further details.\r\n\r\n    let id: DataIdType, item, newIdx = 0;\r\n    for (let i = 0, l = this.items.length; i < l; i++) {\r\n      item = this.items[i];\r\n      id = item[this.idProperty as keyof TData] as DataIdType;\r\n      if (id === undefined) {\r\n        throw new Error(`[SlickGrid DataView] Each data element must implement a unique 'id' property`);\r\n      }\r\n\r\n      // if items have been marked as deleted we skip them for the new final items array\r\n      // and we remove them from the lookup table.\r\n      if (this.bulkDeleteIds.has(id)) {\r\n        this.idxById.delete(id);\r\n      } else {\r\n        // for items which are not deleted, we add them to the\r\n        // next free position in the array and register the index in the lookup.\r\n        this.items[newIdx] = item;\r\n        this.idxById.set(id, newIdx);\r\n        ++newIdx;\r\n      }\r\n    }\r\n\r\n    // here we shrink down the full item array to the ones actually\r\n    // inserted in the cleanup loop above.\r\n    this.items.length = newIdx;\r\n    // and finally cleanup the deleted ids to start cleanly on the next update.\r\n    this.bulkDeleteIds = new Map();\r\n  }\r\n\r\n  protected updateIdxById(startingIndex?: number) {\r\n    if (this.isBulkSuspend || !this.idxById) { // during bulk update we do not reorganize\r\n      return;\r\n    }\r\n    startingIndex = startingIndex || 0;\r\n    let id: DataIdType;\r\n    for (let i = startingIndex, l = this.items.length; i < l; i++) {\r\n      id = this.items[i][this.idProperty as keyof TData] as DataIdType;\r\n      if (id === undefined) {\r\n        throw new Error(`[SlickGrid DataView] Each data element must implement a unique 'id' property`);\r\n      }\r\n      this.idxById.set(id, i);\r\n    }\r\n  }\r\n\r\n  protected ensureIdUniqueness() {\r\n    if (this.isBulkSuspend || !this.idxById) { // during bulk update we do not reorganize\r\n      return;\r\n    }\r\n    let id: DataIdType;\r\n    for (let i = 0, l = this.items.length; i < l; i++) {\r\n      id = this.items[i][this.idProperty as keyof TData] as DataIdType;\r\n      if (id === undefined || this.idxById.get(id) !== i) {\r\n        throw new Error(`[SlickGrid DataView] Each data element must implement a unique 'id' property`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Get all DataView Items */\r\n  getItems() {\r\n    return this.items;\r\n  }\r\n\r\n  /** Get the DataView Id property name to use (defaults to \"Id\" but could be customized to something else when instantiating the DataView) */\r\n  getIdPropertyName() {\r\n    return this.idProperty;\r\n  }\r\n\r\n  /**\r\n   * Set the Items with a new Dataset and optionally pass a different Id property name\r\n   * @param {Array<*>} data - array of data\r\n   * @param {String} [objectIdProperty] - optional id property to use as primary id\r\n   */\r\n  setItems(data: TData[], objectIdProperty?: string) {\r\n    if (objectIdProperty !== undefined) {\r\n      this.idProperty = objectIdProperty;\r\n    }\r\n    this.items = this.filteredItems = data;\r\n    this.onSetItemsCalled.notify({ idProperty: this.idProperty, itemCount: this.items.length }, null, this);\r\n    this.idxById = new Map();\r\n    this.updateIdxById();\r\n    this.ensureIdUniqueness();\r\n    this.refresh();\r\n  }\r\n\r\n  /** Set Paging Options */\r\n  setPagingOptions(args: Partial<PagingInfo>) {\r\n    if (this.onBeforePagingInfoChanged.notify(this.getPagingInfo(), null, this).getReturnValue() !== false) {\r\n      if (Utils.isDefined(args.pageSize)) {\r\n        this.pagesize = args.pageSize;\r\n        this.pagenum = this.pagesize ? Math.min(this.pagenum, Math.max(0, Math.ceil(this.totalRows / this.pagesize) - 1)) : 0;\r\n      }\r\n\r\n      if (Utils.isDefined(args.pageNum)) {\r\n        this.pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(this.totalRows / this.pagesize) - 1));\r\n      }\r\n\r\n      this.onPagingInfoChanged.notify(this.getPagingInfo(), null, this);\r\n\r\n      this.refresh();\r\n    }\r\n  }\r\n\r\n  /** Get Paging Options */\r\n  getPagingInfo(): PagingInfo {\r\n    const totalPages = this.pagesize ? Math.max(1, Math.ceil(this.totalRows / this.pagesize)) : 1;\r\n    return { pageSize: this.pagesize, pageNum: this.pagenum, totalRows: this.totalRows, totalPages, dataView: this as SlickDataView };\r\n  }\r\n\r\n  /** Sort Method to use by the DataView */\r\n  sort(comparer: (a: TData, b: TData) => number, ascending?: boolean) {\r\n    this.sortAsc = ascending;\r\n    this.sortComparer = comparer;\r\n    this.fastSortField = null;\r\n    if (ascending === false) {\r\n      this.items.reverse();\r\n    }\r\n    this.items.sort(comparer);\r\n    if (ascending === false) {\r\n      this.items.reverse();\r\n    }\r\n    this.idxById = new Map();\r\n    this.updateIdxById();\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * @deprecated, to be more removed in next major since IE is no longer supported and this is no longer useful.\r\n   * Provides a workaround for the extremely slow sorting in IE.\r\n   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\r\n   * to return the value of that field and then doing a native Array.sort().\r\n   */\r\n  fastSort(field: string | (() => string), ascending?: boolean) {\r\n    this.sortAsc = ascending;\r\n    this.fastSortField = field;\r\n    this.sortComparer = null as any;\r\n    const oldToString = Object.prototype.toString;\r\n    Object.prototype.toString = (typeof field === 'function') ? field : function () {\r\n      // @ts-ignore\r\n      return this[field];\r\n    };\r\n    // an extra reversal for descending sort keeps the sort stable\r\n    // (assuming a stable native sort implementation, which isn't true in some cases)\r\n    if (ascending === false) {\r\n      this.items.reverse();\r\n    }\r\n    this.items.sort();\r\n    Object.prototype.toString = oldToString;\r\n    if (ascending === false) {\r\n      this.items.reverse();\r\n    }\r\n    this.idxById = new Map();\r\n    this.updateIdxById();\r\n    this.refresh();\r\n  }\r\n\r\n  /** Re-Sort the dataset */\r\n  reSort() {\r\n    if (this.sortComparer) {\r\n      this.sort(this.sortComparer, this.sortAsc);\r\n    } else if (this.fastSortField) {\r\n      this.fastSort(this.fastSortField, this.sortAsc);\r\n    }\r\n  }\r\n\r\n  /** Get only the DataView filtered items */\r\n  getFilteredItems<T extends TData>() {\r\n    return this.filteredItems as T[];\r\n  }\r\n\r\n  /** Get the array length (count) of only the DataView filtered items */\r\n  getFilteredItemCount() {\r\n    return this.filteredItems.length;\r\n  }\r\n\r\n  /** Get current Filter used by the DataView */\r\n  getFilter() {\r\n    return this._options.useCSPSafeFilter ? this.filterCSPSafe : this.filter;\r\n  }\r\n\r\n  /**\r\n   * Set a Filter that will be used by the DataView\r\n   * @param {Function} fn - filter callback function\r\n   */\r\n  setFilter(filterFn: FilterFn<TData>) {\r\n    this.filterCSPSafe = filterFn;\r\n    this.filter = filterFn;\r\n    if (this._options.inlineFilters) {\r\n      this.compiledFilterCSPSafe = this.compileFilterCSPSafe;\r\n      this.compiledFilterWithCachingCSPSafe = this.compileFilterWithCachingCSPSafe;\r\n      this.compiledFilter = this.compileFilter(this._options.useCSPSafeFilter);\r\n      this.compiledFilterWithCaching = this.compileFilterWithCaching(this._options.useCSPSafeFilter);\r\n    }\r\n    this.refresh();\r\n  }\r\n\r\n  /** Get current Grouping info */\r\n  getGrouping(): Grouping[] {\r\n    return this.groupingInfos;\r\n  }\r\n\r\n  /** Set some Grouping */\r\n  setGrouping(groupingInfo: Grouping | Grouping[]) {\r\n    if (!this._options.groupItemMetadataProvider) {\r\n      this._options.groupItemMetadataProvider = new SlickGroupItemMetadataProvider();\r\n    }\r\n\r\n    this.groups = [];\r\n    this.toggledGroupsByLevel = [];\r\n    groupingInfo = groupingInfo || [];\r\n    this.groupingInfos = ((groupingInfo instanceof Array) ? groupingInfo : [groupingInfo]) as any;\r\n\r\n    for (let i = 0; i < this.groupingInfos.length; i++) {\r\n      const gi = this.groupingInfos[i] = Utils.extend(true, {}, this.groupingInfoDefaults, this.groupingInfos[i]);\r\n      gi.getterIsAFn = typeof gi.getter === 'function';\r\n\r\n      // pre-compile accumulator loops\r\n      gi.compiledAccumulators = [];\r\n      let idx = gi.aggregators.length;\r\n      while (idx--) {\r\n        gi.compiledAccumulators[idx] = this.compileAccumulatorLoopCSPSafe(gi.aggregators[idx]);\r\n      }\r\n\r\n      this.toggledGroupsByLevel[i] = {};\r\n    }\r\n\r\n    this.refresh();\r\n  }\r\n\r\n  /** Get an item in the DataView by its row index */\r\n  getItemByIdx<T extends TData>(i: number) {\r\n    return this.items[i] as T;\r\n  }\r\n\r\n  /** Get row index in the DataView by its Id */\r\n  getIdxById(id: DataIdType) {\r\n    return this.idxById?.get(id);\r\n  }\r\n\r\n  protected ensureRowsByIdCache() {\r\n    if (!this.rowsById) {\r\n      this.rowsById = {};\r\n      for (let i = 0, l = this.rows.length; i < l; i++) {\r\n        this.rowsById[this.rows[i][this.idProperty as keyof TData] as DataIdType] = i;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Get row number in the grid by its item object */\r\n  getRowByItem(item: TData) {\r\n    this.ensureRowsByIdCache();\r\n    return this.rowsById?.[item[this.idProperty as keyof TData] as DataIdType];\r\n  }\r\n\r\n  /** Get row number in the grid by its Id */\r\n  getRowById(id: DataIdType) {\r\n    this.ensureRowsByIdCache();\r\n    return this.rowsById?.[id];\r\n  }\r\n\r\n  /** Get an item in the DataView by its Id */\r\n  getItemById<T extends TData>(id: DataIdType) {\r\n    return this.items[(this.idxById.get(id) as number)] as T;\r\n  }\r\n\r\n  /** From the items array provided, return the mapped rows */\r\n  mapItemsToRows(itemArray: TData[]) {\r\n    const rows: number[] = [];\r\n    this.ensureRowsByIdCache();\r\n    for (let i = 0, l = itemArray.length; i < l; i++) {\r\n      const row = this.rowsById?.[itemArray[i][this.idProperty as keyof TData] as DataIdType];\r\n      if (Utils.isDefined(row)) {\r\n        rows[rows.length] = row as number;\r\n      }\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  /** From the Ids array provided, return the mapped rows */\r\n  mapIdsToRows(idArray: DataIdType[]) {\r\n    const rows: number[] = [];\r\n    this.ensureRowsByIdCache();\r\n    for (let i = 0, l = idArray.length; i < l; i++) {\r\n      const row = this.rowsById?.[idArray[i]];\r\n      if (Utils.isDefined(row)) {\r\n        rows[rows.length] = row as number;\r\n      }\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  /** From the rows array provided, return the mapped Ids */\r\n  mapRowsToIds(rowArray: number[]) {\r\n    const ids: DataIdType[] = [];\r\n    for (let i = 0, l = rowArray.length; i < l; i++) {\r\n      if (rowArray[i] < this.rows.length) {\r\n        const rowItem = this.rows[rowArray[i]];\r\n        ids[ids.length] = rowItem![this.idProperty as keyof TData] as DataIdType;\r\n      }\r\n    }\r\n    return ids;\r\n  }\r\n\r\n  /**\r\n   * Performs the update operations of a single item by id without\r\n   * triggering any events or refresh operations.\r\n   * @param id The new id of the item.\r\n   * @param item The item which should be the new value for the given id.\r\n   */\r\n  updateSingleItem(id: DataIdType, item: TData) {\r\n    if (!this.idxById) { return; }\r\n\r\n    // see also https://github.com/mleibman/SlickGrid/issues/1082\r\n    if (!this.idxById.has(id)) {\r\n      throw new Error('[SlickGrid DataView] Invalid id');\r\n    }\r\n\r\n    // What if the specified item also has an updated idProperty?\r\n    // Then we'll have to update the index as well, and possibly the `updated` cache too.\r\n    if (id !== item[this.idProperty as keyof TData]) {\r\n      // make sure the new id is unique:\r\n      const newId = item[this.idProperty as keyof TData] as DataIdType;\r\n      if (!Utils.isDefined(newId)) {\r\n        throw new Error('[SlickGrid DataView] Cannot update item to associate with a null id');\r\n      }\r\n      if (this.idxById.has(newId)) {\r\n        throw new Error('[SlickGrid DataView] Cannot update item to associate with a non-unique id');\r\n      }\r\n      this.idxById.set(newId, this.idxById.get(id) as number);\r\n      this.idxById.delete(id);\r\n\r\n      // Also update the `updated` hashtable/markercache? Yes, `recalc()` inside `refresh()` needs that one!\r\n      if (this.updated?.[id]) {\r\n        delete this.updated[id];\r\n      }\r\n\r\n      // Also update the row indexes? no need since the `refresh()`, further down, blows away the `rowsById[]` cache!\r\n\r\n      id = newId;\r\n    }\r\n    this.items[this.idxById.get(id) as number] = item;\r\n\r\n    // Also update the rows? no need since the `refresh()`, further down, blows away the `rows[]` cache and recalculates it via `recalc()`!\r\n\r\n    if (!this.updated) {\r\n      this.updated = {};\r\n    }\r\n    this.updated[id] = true;\r\n  }\r\n\r\n  /**\r\n   * Updates a single item in the data view given the id and new value.\r\n   * @param id The new id of the item.\r\n   * @param item The item which should be the new value for the given id.\r\n   */\r\n  updateItem<T extends TData>(id: DataIdType, item: T) {\r\n    this.updateSingleItem(id, item);\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * Updates multiple items in the data view given the new ids and new values.\r\n   * @param id {Array} The array of new ids which is in the same order as the items.\r\n   * @param newItems {Array} The new items that should be set in the data view for the given ids.\r\n   */\r\n  updateItems<T extends TData>(ids: DataIdType[], newItems: T[]) {\r\n    if (ids.length !== newItems.length) {\r\n      throw new Error('[SlickGrid DataView] Mismatch on the length of ids and items provided to update');\r\n    }\r\n    for (let i = 0, l = newItems.length; i < l; i++) {\r\n      this.updateSingleItem(ids[i], newItems[i]);\r\n    }\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * Inserts a single item into the data view at the given position.\r\n   * @param insertBefore {Number} The 0-based index before which the item should be inserted.\r\n   * @param item The item to insert.\r\n   */\r\n  insertItem(insertBefore: number, item: TData) {\r\n    this.items.splice(insertBefore, 0, item);\r\n    this.updateIdxById(insertBefore);\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * Inserts multiple items into the data view at the given position.\r\n   * @param insertBefore {Number} The 0-based index before which the items should be inserted.\r\n   * @param newItems {Array}  The items to insert.\r\n   */\r\n  insertItems(insertBefore: number, newItems: TData[]) {\r\n    // @ts-ignore\r\n    Array.prototype.splice.apply(this.items, [insertBefore, 0].concat(newItems));\r\n    this.updateIdxById(insertBefore);\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * Adds a single item at the end of the data view.\r\n   * @param item The item to add at the end.\r\n   */\r\n  addItem(item: TData) {\r\n    this.items.push(item);\r\n    this.updateIdxById(this.items.length - 1);\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * Adds multiple items at the end of the data view.\r\n   * @param {Array} newItems The items to add at the end.\r\n   */\r\n  addItems(newItems: TData[]) {\r\n    this.items = this.items.concat(newItems);\r\n    this.updateIdxById(this.items.length - newItems.length);\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * Deletes a single item identified by the given id from the data view.\r\n   * @param {String|Number} id The id identifying the object to delete.\r\n   */\r\n  deleteItem(id: DataIdType) {\r\n    if (!this.idxById) { return; }\r\n    if (this.isBulkSuspend) {\r\n      this.bulkDeleteIds.set(id, true);\r\n    } else {\r\n      const idx = this.idxById.get(id);\r\n      if (idx === undefined) {\r\n        throw new Error('[SlickGrid DataView] Invalid id');\r\n      }\r\n      this.idxById.delete(id);\r\n      this.items.splice(idx, 1);\r\n      this.updateIdxById(idx);\r\n      this.refresh();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes multiple item identified by the given ids from the data view.\r\n   * @param {Array} ids The ids of the items to delete.\r\n   */\r\n  deleteItems(ids: DataIdType[]) {\r\n    if (ids.length === 0 || !this.idxById) {\r\n      return;\r\n    }\r\n\r\n    if (this.isBulkSuspend) {\r\n      for (let i = 0, l = ids.length; i < l; i++) {\r\n        const id = ids[i];\r\n        const idx = this.idxById.get(id);\r\n        if (idx === undefined) {\r\n          throw new Error('[SlickGrid DataView] Invalid id');\r\n        }\r\n        this.bulkDeleteIds.set(id, true);\r\n      }\r\n    } else {\r\n      // collect all indexes\r\n      const indexesToDelete: number[] = [];\r\n      for (let i = 0, l = ids.length; i < l; i++) {\r\n        const id = ids[i];\r\n        const idx = this.idxById.get(id);\r\n        if (idx === undefined) {\r\n          throw new Error('[SlickGrid DataView] Invalid id');\r\n        }\r\n        this.idxById.delete(id);\r\n        indexesToDelete.push(idx);\r\n      }\r\n\r\n      // Remove from back to front\r\n      indexesToDelete.sort();\r\n      for (let i = indexesToDelete.length - 1; i >= 0; --i) {\r\n        this.items.splice(indexesToDelete[i], 1);\r\n      }\r\n\r\n      // update lookup from front to back\r\n      this.updateIdxById(indexesToDelete[0]);\r\n      this.refresh();\r\n    }\r\n  }\r\n\r\n  /** Add an item in a sorted dataset (a Sort function must be defined) */\r\n  sortedAddItem(item: TData) {\r\n    if (!this.sortComparer) {\r\n      throw new Error('[SlickGrid DataView] sortedAddItem() requires a sort comparer, use sort()');\r\n    }\r\n    this.insertItem(this.sortedIndex(item), item);\r\n  }\r\n\r\n  /** Update an item in a sorted dataset (a Sort function must be defined) */\r\n  sortedUpdateItem(id: string | number, item: TData) {\r\n    if (!this.idxById) { return; }\r\n    if (!this.idxById.has(id) || id !== item[this.idProperty as keyof TData]) {\r\n      throw new Error('[SlickGrid DataView] Invalid or non-matching id ' + this.idxById.get(id));\r\n    }\r\n    if (!this.sortComparer) {\r\n      throw new Error('[SlickGrid DataView] sortedUpdateItem() requires a sort comparer, use sort()');\r\n    }\r\n    const oldItem = this.getItemById(id);\r\n    if (this.sortComparer(oldItem, item) !== 0) {\r\n      // item affects sorting -> must use sorted add\r\n      this.deleteItem(id);\r\n      this.sortedAddItem(item);\r\n    } else { // update does not affect sorting -> regular update works fine\r\n      this.updateItem(id, item);\r\n    }\r\n  }\r\n\r\n  protected sortedIndex(searchItem: TData) {\r\n    let low = 0;\r\n    let high = this.items.length;\r\n\r\n    while (low < high) {\r\n      const mid = low + high >>> 1;\r\n      if (this.sortComparer(this.items[mid], searchItem) === -1) {\r\n        low = mid + 1;\r\n      } else {\r\n        high = mid;\r\n      }\r\n    }\r\n    return low;\r\n  }\r\n\r\n  /** Get item count, that is the full dataset lenght of the DataView */\r\n  getItemCount() {\r\n    return this.items.length;\r\n  }\r\n\r\n  /** Get row count (rows displayed in current page) */\r\n  getLength() {\r\n    return this.rows.length;\r\n  }\r\n\r\n  /** Retrieve an item from the DataView at specific index */\r\n  getItem<T extends TData>(i: number) {\r\n    const item = this.rows[i] as T;\r\n\r\n    // if this is a group row, make sure totals are calculated and update the title\r\n    if ((item as SlickGroup_)?.__group && (item as SlickGroup_).totals && !(item as SlickGroup_).totals?.initialized) {\r\n      const gi = this.groupingInfos[(item as SlickGroup_).level];\r\n      if (!gi.displayTotalsRow) {\r\n        this.calculateTotals((item as SlickGroup_).totals);\r\n        (item as SlickGroup_).title = gi.formatter ? gi.formatter((item as SlickGroup_)) : (item as SlickGroup_).value;\r\n      }\r\n    }\r\n    // if this is a totals row, make sure it's calculated\r\n    else if ((item as SlickGroupTotals_)?.__groupTotals && !(item as SlickGroupTotals_).initialized) {\r\n      this.calculateTotals(item as SlickGroupTotals_);\r\n    }\r\n\r\n    return item;\r\n  }\r\n\r\n  getItemMetadata(row: number): ItemMetadata | null {\r\n    const item = this.rows[row];\r\n    if (item === undefined) {\r\n      return null;\r\n    }\r\n\r\n    // global override for all regular rows\r\n    if (this._options.globalItemMetadataProvider?.getRowMetadata) {\r\n      return this._options.globalItemMetadataProvider.getRowMetadata(item, row);\r\n    }\r\n\r\n    // overrides for grouping rows\r\n    if ((item as SlickGroup_).__group && this._options.groupItemMetadataProvider?.getGroupRowMetadata) {\r\n      return this._options.groupItemMetadataProvider.getGroupRowMetadata(item as GroupingFormatterItem, row);\r\n    }\r\n\r\n    // overrides for totals rows\r\n    if ((item as SlickGroupTotals_).__groupTotals && this._options.groupItemMetadataProvider?.getTotalsRowMetadata) {\r\n      return this._options.groupItemMetadataProvider.getTotalsRowMetadata(item as { group: GroupingFormatterItem }, row);\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  protected expandCollapseAllGroups(level?: number, collapse?: boolean) {\r\n    if (!Utils.isDefined(level)) {\r\n      for (let i = 0; i < this.groupingInfos.length; i++) {\r\n        this.toggledGroupsByLevel[i] = {};\r\n        this.groupingInfos[i].collapsed = collapse;\r\n\r\n        if (collapse === true) {\r\n          this.onGroupCollapsed.notify({ level: i, groupingKey: null });\r\n        } else {\r\n          this.onGroupExpanded.notify({ level: i, groupingKey: null });\r\n        }\r\n      }\r\n    } else {\r\n      this.toggledGroupsByLevel[level] = {};\r\n      this.groupingInfos[level].collapsed = collapse;\r\n\r\n      if (collapse === true) {\r\n        this.onGroupCollapsed.notify({ level, groupingKey: null });\r\n      } else {\r\n        this.onGroupExpanded.notify({ level, groupingKey: null });\r\n      }\r\n    }\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * @param {Number} [level] Optional level to collapse.  If not specified, applies to all levels.\r\n   */\r\n  collapseAllGroups(level?: number) {\r\n    this.expandCollapseAllGroups(level, true);\r\n  }\r\n\r\n  /**\r\n   * @param {Number} [level] Optional level to expand.  If not specified, applies to all levels.\r\n   */\r\n  expandAllGroups(level?: number) {\r\n    this.expandCollapseAllGroups(level, false);\r\n  }\r\n\r\n  expandCollapseGroup(level: number, groupingKey: string, collapse?: boolean) {\r\n    // @ts-ignore\r\n    this.toggledGroupsByLevel[level][groupingKey] = this.groupingInfos[level].collapsed ^ collapse;\r\n    this.refresh();\r\n  }\r\n\r\n  /**\r\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\r\n   *     variable argument list of grouping values denoting a unique path to the row.  For\r\n   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\r\n   *     the 'high' group.\r\n   */\r\n  collapseGroup(...args: any) {\r\n    const calledArgs = Array.prototype.slice.call(args);\r\n    const arg0 = calledArgs[0];\r\n    let groupingKey: string;\r\n    let level: number;\r\n\r\n    if (args.length === 1 && arg0.indexOf(this.groupingDelimiter) !== -1) {\r\n      groupingKey = arg0;\r\n      level = arg0.split(this.groupingDelimiter).length - 1;\r\n    } else {\r\n      groupingKey = args.join(this.groupingDelimiter);\r\n      level = args.length - 1;\r\n    }\r\n\r\n    this.expandCollapseGroup(level, groupingKey, true);\r\n    this.onGroupCollapsed.notify({ level, groupingKey });\r\n  }\r\n\r\n  /**\r\n   * @param varArgs Either a Slick.Group's \"groupingKey\" property, or a\r\n   *     variable argument list of grouping values denoting a unique path to the row.  For\r\n   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\r\n   *     the 'high' group.\r\n   */\r\n  expandGroup(...args: any) {\r\n    const calledArgs = Array.prototype.slice.call(args);\r\n    const arg0 = calledArgs[0];\r\n    let groupingKey: string;\r\n    let level: number;\r\n\r\n    if (args.length === 1 && arg0.indexOf(this.groupingDelimiter) !== -1) {\r\n      level = arg0.split(this.groupingDelimiter).length - 1;\r\n      groupingKey = arg0;\r\n    } else {\r\n      level = args.length - 1;\r\n      groupingKey = args.join(this.groupingDelimiter);\r\n    }\r\n\r\n    this.expandCollapseGroup(level, groupingKey, false);\r\n    this.onGroupExpanded.notify({ level, groupingKey });\r\n  }\r\n\r\n  getGroups() {\r\n    return this.groups;\r\n  }\r\n\r\n  protected extractGroups(rows: any[], parentGroup?: SlickGroup_) {\r\n    let group: SlickGroup_;\r\n    let val: any;\r\n    const groups: SlickGroup_[] = [];\r\n    const groupsByVal: any = {};\r\n    let r;\r\n    const level = parentGroup ? parentGroup.level + 1 : 0;\r\n    const gi = this.groupingInfos[level];\r\n\r\n    for (let i = 0, l = gi.predefinedValues?.length ?? 0; i < l; i++) {\r\n      val = gi.predefinedValues?.[i];\r\n      group = groupsByVal[val];\r\n      if (!group) {\r\n        group = new SlickGroup();\r\n        group.value = val;\r\n        group.level = level;\r\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + this.groupingDelimiter : '') + val;\r\n        groups[groups.length] = group;\r\n        groupsByVal[val] = group;\r\n      }\r\n    }\r\n\r\n    for (let i = 0, l = rows.length; i < l; i++) {\r\n      r = rows[i];\r\n      val = gi.getterIsAFn ? (gi.getter as GroupGetterFn)(r) : r[gi.getter as keyof TData];\r\n      group = groupsByVal[val];\r\n      if (!group) {\r\n        group = new SlickGroup();\r\n        group.value = val;\r\n        group.level = level;\r\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + this.groupingDelimiter : '') + val;\r\n        groups[groups.length] = group;\r\n        groupsByVal[val] = group;\r\n      }\r\n\r\n      group.rows[group.count++] = r;\r\n    }\r\n\r\n    if (level < this.groupingInfos.length - 1) {\r\n      for (let i = 0; i < groups.length; i++) {\r\n        group = groups[i];\r\n        group.groups = this.extractGroups(group.rows, group);\r\n      }\r\n    }\r\n\r\n    if (groups.length) {\r\n      this.addTotals(groups, level);\r\n    }\r\n\r\n    groups.sort(this.groupingInfos[level].comparer);\r\n\r\n    return groups;\r\n  }\r\n\r\n  /** claculate Group Totals */\r\n  protected calculateTotals(totals: SlickGroupTotals_) {\r\n    const group = totals.group;\r\n    const gi = this.groupingInfos[group.level ?? 0];\r\n    const isLeafLevel = (group.level === this.groupingInfos.length);\r\n    let agg: Aggregator;\r\n    let idx = gi.aggregators.length;\r\n\r\n    if (!isLeafLevel && gi.aggregateChildGroups) {\r\n      // make sure all the subgroups are calculated\r\n      let i = group.groups?.length ?? 0;\r\n      while (i--) {\r\n        if (!group.groups[i].totals.initialized) {\r\n          this.calculateTotals(group.groups[i].totals);\r\n        }\r\n      }\r\n    }\r\n\r\n    while (idx--) {\r\n      agg = gi.aggregators[idx];\r\n      agg.init();\r\n      if (!isLeafLevel && gi.aggregateChildGroups) {\r\n        gi.compiledAccumulators[idx].call(agg, group.groups);\r\n      } else {\r\n        gi.compiledAccumulators[idx].call(agg, group.rows);\r\n      }\r\n      agg.storeResult(totals);\r\n    }\r\n    totals.initialized = true;\r\n  }\r\n\r\n  protected addGroupTotals(group: SlickGroup_) {\r\n    const gi = this.groupingInfos[group.level];\r\n    const totals = new SlickGroupTotals();\r\n    totals.group = group;\r\n    group.totals = totals;\r\n    if (!gi.lazyTotalsCalculation) {\r\n      this.calculateTotals(totals);\r\n    }\r\n  }\r\n\r\n  protected addTotals(groups: SlickGroup_[], level?: number) {\r\n    level = level || 0;\r\n    const gi = this.groupingInfos[level];\r\n    const groupCollapsed = gi.collapsed;\r\n    const toggledGroups = this.toggledGroupsByLevel[level];\r\n    let idx = groups.length, g;\r\n    while (idx--) {\r\n      g = groups[idx];\r\n\r\n      if (g.collapsed && !gi.aggregateCollapsed) {\r\n        continue;\r\n      }\r\n\r\n      // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\r\n      if (g.groups) {\r\n        this.addTotals(g.groups, level + 1);\r\n      }\r\n\r\n      if (gi.aggregators?.length && (\r\n        gi.aggregateEmpty || g.rows.length || g.groups?.length)) {\r\n        this.addGroupTotals(g);\r\n      }\r\n\r\n      g.collapsed = (groupCollapsed as any) ^ toggledGroups[g.groupingKey];\r\n      g.title = gi.formatter ? gi.formatter(g) : g.value;\r\n    }\r\n  }\r\n\r\n  protected flattenGroupedRows(groups: SlickGroup_[], level?: number) {\r\n    level = level || 0;\r\n    const gi = this.groupingInfos[level];\r\n    const groupedRows: any[] = [];\r\n    let rows: any[];\r\n    let gl = 0;\r\n    let g;\r\n    for (let i = 0, l = groups.length; i < l; i++) {\r\n      g = groups[i];\r\n      groupedRows[gl++] = g;\r\n\r\n      if (!g.collapsed) {\r\n        rows = g.groups ? this.flattenGroupedRows(g.groups, level + 1) : g.rows;\r\n        for (let j = 0, jj = rows.length; j < jj; j++) {\r\n          groupedRows[gl++] = rows[j];\r\n        }\r\n      }\r\n\r\n      if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\r\n        groupedRows[gl++] = g.totals;\r\n      }\r\n    }\r\n    return groupedRows;\r\n  }\r\n\r\n  protected compileAccumulatorLoopCSPSafe(aggregator: Aggregator) {\r\n    if (aggregator.accumulate) {\r\n      return function (items: any[]) {\r\n        let result;\r\n        for (let i = 0; i < items.length; i++) {\r\n          const item = items[i];\r\n          result = aggregator.accumulate!.call(aggregator, item);\r\n        }\r\n        return result;\r\n      };\r\n    } else {\r\n      return function noAccumulator() { };\r\n    }\r\n  }\r\n\r\n  protected compileFilterCSPSafe(items: TData[], args: any): TData[] {\r\n    if (typeof this.filterCSPSafe !== 'function') {\r\n      return [];\r\n    }\r\n    const _retval: TData[] = [];\r\n    const _il = items.length;\r\n\r\n    for (let _i = 0; _i < _il; _i++) {\r\n      if (this.filterCSPSafe(items[_i], args)) {\r\n        _retval.push(items[_i]);\r\n      }\r\n    }\r\n\r\n    return _retval;\r\n  }\r\n\r\n  protected compileFilter(stopRunningIfCSPSafeIsActive = false): FilterFn<TData> | null {\r\n    if (stopRunningIfCSPSafeIsActive) {\r\n      return null as any;\r\n    }\r\n    const filterInfo = Utils.getFunctionDetails(this.filter as FilterFn<TData>);\r\n\r\n    const filterPath1 = '{ continue _coreloop; }$1';\r\n    const filterPath2 = '{ _retval[_idx++] = $item$; continue _coreloop; }$1';\r\n    // make some allowances for minification - there's only so far we can go with RegEx\r\n    const filterBody = filterInfo.body\r\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\r\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\r\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\r\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\r\n      .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\r\n        '{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\r\n\r\n    // This preserves the function template code after JS compression,\r\n    // so that replace() commands still work as expected.\r\n    let tpl = [\r\n      // 'function(_items, _args) { ',\r\n      'var _retval = [], _idx = 0; ',\r\n      'var $item$, $args$ = _args; ',\r\n      '_coreloop: ',\r\n      'for (var _i = 0, _il = _items.length; _i < _il; _i++) { ',\r\n      '$item$ = _items[_i]; ',\r\n      '$filter$; ',\r\n      '} ',\r\n      'return _retval; '\r\n      // '}'\r\n    ].join('');\r\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\r\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\r\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\r\n    const fn: any = new Function('_items,_args', tpl);\r\n    const fnName = 'compiledFilter';\r\n    fn.displayName = fnName;\r\n    fn.name = this.setFunctionName(fn, fnName);\r\n    return fn;\r\n  }\r\n\r\n  protected compileFilterWithCaching(stopRunningIfCSPSafeIsActive = false) {\r\n    if (stopRunningIfCSPSafeIsActive) {\r\n      return null as any;\r\n    }\r\n\r\n    const filterInfo = Utils.getFunctionDetails(this.filter as FilterFn<TData>);\r\n\r\n    const filterPath1 = '{ continue _coreloop; }$1';\r\n    const filterPath2 = '{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1';\r\n    // make some allowances for minification - there's only so far we can go with RegEx\r\n    const filterBody = filterInfo.body\r\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\r\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\r\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\r\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\r\n      .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\r\n        '{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\r\n\r\n    // This preserves the function template code after JS compression,\r\n    // so that replace() commands still work as expected.\r\n    let tpl = [\r\n      // 'function(_items, _args, _cache) { ',\r\n      'var _retval = [], _idx = 0; ',\r\n      'var $item$, $args$ = _args; ',\r\n      '_coreloop: ',\r\n      'for (var _i = 0, _il = _items.length; _i < _il; _i++) { ',\r\n      '$item$ = _items[_i]; ',\r\n      'if (_cache[_i]) { ',\r\n      '_retval[_idx++] = $item$; ',\r\n      'continue _coreloop; ',\r\n      '} ',\r\n      '$filter$; ',\r\n      '} ',\r\n      'return _retval; '\r\n      // '}'\r\n    ].join('');\r\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\r\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\r\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\r\n\r\n    const fn: any = new Function('_items,_args,_cache', tpl);\r\n    const fnName = 'compiledFilterWithCaching';\r\n    fn.displayName = fnName;\r\n    fn.name = this.setFunctionName(fn, fnName);\r\n    return fn;\r\n  }\r\n\r\n  protected compileFilterWithCachingCSPSafe(items: TData[], args: any, filterCache: any[]): TData[] {\r\n    if (typeof this.filterCSPSafe !== 'function') {\r\n      return [];\r\n    }\r\n\r\n    const retval: TData[] = [];\r\n    const il = items.length;\r\n\r\n    for (let _i = 0; _i < il; _i++) {\r\n      if (filterCache[_i] || this.filterCSPSafe(items[_i], args)) {\r\n        retval.push(items[_i]);\r\n      }\r\n    }\r\n\r\n    return retval;\r\n  }\r\n\r\n  /**\r\n   * In ES5 we could set the function name on the fly but in ES6 this is forbidden and we need to set it through differently\r\n   * We can use Object.defineProperty and set it the property to writable, see MDN for reference\r\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\r\n   * @param {*} fn\r\n   * @param {string} fnName\r\n   */\r\n  protected setFunctionName(fn: any, fnName: string) {\r\n    try {\r\n      Object.defineProperty(fn, 'name', { writable: true, value: fnName });\r\n    } catch (err) {\r\n      fn.name = fnName;\r\n    }\r\n  }\r\n\r\n  protected uncompiledFilter(items: TData[], args: any) {\r\n    const retval: any[] = [];\r\n    let idx = 0;\r\n\r\n    for (let i = 0, ii = items.length; i < ii; i++) {\r\n      if (this.filter?.(items[i], args)) {\r\n        retval[idx++] = items[i];\r\n      }\r\n    }\r\n\r\n    return retval;\r\n  }\r\n\r\n  protected uncompiledFilterWithCaching(items: TData[], args: any, cache: any) {\r\n    const retval: any[] = [];\r\n    let idx = 0,\r\n      item: TData;\r\n\r\n    for (let i = 0, ii = items.length; i < ii; i++) {\r\n      item = items[i];\r\n      if (cache[i]) {\r\n        retval[idx++] = item;\r\n      } else if (this.filter?.(item, args)) {\r\n        retval[idx++] = item;\r\n        cache[i] = true;\r\n      }\r\n    }\r\n\r\n    return retval;\r\n  }\r\n\r\n  protected getFilteredAndPagedItems(items: TData[]) {\r\n    if (this._options.useCSPSafeFilter ? this.filterCSPSafe : this.filter) {\r\n      let batchFilter: AnyFunction;\r\n      let batchFilterWithCaching: AnyFunction;\r\n      if (this._options.useCSPSafeFilter) {\r\n        batchFilter = (this._options.inlineFilters ? this.compiledFilterCSPSafe : this.uncompiledFilter) as AnyFunction;\r\n        batchFilterWithCaching = (this._options.inlineFilters ? this.compiledFilterWithCachingCSPSafe : this.uncompiledFilterWithCaching) as AnyFunction;\r\n      } else {\r\n        batchFilter = (this._options.inlineFilters ? this.compiledFilter : this.uncompiledFilter) as AnyFunction;\r\n        batchFilterWithCaching = (this._options.inlineFilters ? this.compiledFilterWithCaching : this.uncompiledFilterWithCaching) as AnyFunction;\r\n      }\r\n      if (this.refreshHints.isFilterNarrowing) {\r\n        this.filteredItems = batchFilter.call(this, this.filteredItems, this.filterArgs);\r\n      } else if (this.refreshHints.isFilterExpanding) {\r\n        this.filteredItems = batchFilterWithCaching.call(this, items, this.filterArgs, this.filterCache);\r\n      } else if (!this.refreshHints.isFilterUnchanged) {\r\n        this.filteredItems = batchFilter.call(this, items, this.filterArgs);\r\n      }\r\n    } else {\r\n      // special case:  if not filtering and not paging, the resulting\r\n      // rows collection needs to be a copy so that changes due to sort\r\n      // can be caught\r\n      this.filteredItems = this.pagesize ? items : items.concat();\r\n    }\r\n\r\n    // get the current page\r\n    let paged: TData[];\r\n    if (this.pagesize) {\r\n      if (this.filteredItems.length <= this.pagenum * this.pagesize) {\r\n        if (this.filteredItems.length === 0) {\r\n          this.pagenum = 0;\r\n        } else {\r\n          this.pagenum = Math.floor((this.filteredItems.length - 1) / this.pagesize);\r\n        }\r\n      }\r\n      paged = this.filteredItems.slice(this.pagesize * this.pagenum, this.pagesize * this.pagenum + this.pagesize);\r\n    } else {\r\n      paged = this.filteredItems;\r\n    }\r\n    return { totalRows: this.filteredItems.length, rows: paged };\r\n  }\r\n\r\n  protected getRowDiffs(rows: TData[], newRows: TData[]) {\r\n    let item: TData | SlickNonDataItem | SlickDataItem | SlickGroup_;\r\n    let r;\r\n    let eitherIsNonData;\r\n    const diff: number[] = [];\r\n    let from = 0;\r\n    let to = Math.max(newRows.length, rows.length);\r\n\r\n    if (this.refreshHints?.ignoreDiffsBefore) {\r\n      from = Math.max(0,\r\n        Math.min(newRows.length, this.refreshHints.ignoreDiffsBefore));\r\n    }\r\n\r\n    if (this.refreshHints?.ignoreDiffsAfter) {\r\n      to = Math.min(newRows.length,\r\n        Math.max(0, this.refreshHints.ignoreDiffsAfter));\r\n    }\r\n\r\n    for (let i = from, rl = rows.length; i < to; i++) {\r\n      if (i >= rl) {\r\n        diff[diff.length] = i;\r\n      } else {\r\n        item = newRows[i];\r\n        r = rows[i];\r\n\r\n        if (!item || (this.groupingInfos.length && (eitherIsNonData = ((item as SlickNonDataItem).__nonDataRow) || ((r as SlickNonDataItem).__nonDataRow)) &&\r\n          (item as SlickGroup_).__group !== (r as SlickGroup_).__group ||\r\n          (item as SlickGroup_).__group && !(item as SlickGroup_).equals(r as SlickGroup_))\r\n          || (eitherIsNonData &&\r\n            // no good way to compare totals since they are arbitrary DTOs\r\n            // deep object comparison is pretty expensive\r\n            // always considering them 'dirty' seems easier for the time being\r\n            ((item as SlickGroupTotals_).__groupTotals || (r as SlickGroupTotals_).__groupTotals))\r\n          || item[this.idProperty as keyof TData] !== r[this.idProperty as keyof TData]\r\n          || (this.updated?.[item[this.idProperty as keyof TData]])\r\n        ) {\r\n          diff[diff.length] = i;\r\n        }\r\n      }\r\n    }\r\n    return diff;\r\n  }\r\n\r\n  protected recalc(_items: TData[]) {\r\n    this.rowsById = undefined;\r\n\r\n    if (this.refreshHints.isFilterNarrowing !== this.prevRefreshHints.isFilterNarrowing ||\r\n      this.refreshHints.isFilterExpanding !== this.prevRefreshHints.isFilterExpanding) {\r\n      this.filterCache = [];\r\n    }\r\n\r\n    const filteredItems = this.getFilteredAndPagedItems(_items);\r\n    this.totalRows = filteredItems.totalRows;\r\n    let newRows: TData[] = filteredItems.rows;\r\n\r\n    this.groups = [];\r\n    if (this.groupingInfos.length) {\r\n      this.groups = this.extractGroups(newRows);\r\n      if (this.groups.length) {\r\n        newRows = this.flattenGroupedRows(this.groups);\r\n      }\r\n    }\r\n\r\n    const diff = this.getRowDiffs(this.rows, newRows as TData[]);\r\n\r\n    this.rows = newRows as TData[];\r\n\r\n    return diff;\r\n  }\r\n\r\n  refresh() {\r\n    if (this.suspend) {\r\n      return;\r\n    }\r\n\r\n    const previousPagingInfo = Utils.extend(true, {}, this.getPagingInfo());\r\n\r\n    const countBefore = this.rows.length;\r\n    const totalRowsBefore = this.totalRows;\r\n\r\n    let diff = this.recalc(this.items); // pass as direct refs to avoid closure perf hit\r\n\r\n    // if the current page is no longer valid, go to last page and recalc\r\n    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\r\n    if (this.pagesize && this.totalRows < this.pagenum * this.pagesize) {\r\n      this.pagenum = Math.max(0, Math.ceil(this.totalRows / this.pagesize) - 1);\r\n      diff = this.recalc(this.items);\r\n    }\r\n\r\n    this.updated = null;\r\n    this.prevRefreshHints = this.refreshHints;\r\n    this.refreshHints = {};\r\n\r\n    if (totalRowsBefore !== this.totalRows) {\r\n      // use the previously saved paging info\r\n      if (this.onBeforePagingInfoChanged.notify(previousPagingInfo, null, this).getReturnValue() !== false) {\r\n        this.onPagingInfoChanged.notify(this.getPagingInfo(), null, this);\r\n      }\r\n    }\r\n    if (countBefore !== this.rows.length) {\r\n      this.onRowCountChanged.notify({ previous: countBefore, current: this.rows.length, itemCount: this.items.length, dataView: this, callingOnRowsChanged: (diff.length > 0) }, null, this);\r\n    }\r\n    if (diff.length > 0) {\r\n      this.onRowsChanged.notify({ rows: diff, itemCount: this.items.length, dataView: this, calledOnRowCountChanged: (countBefore !== this.rows.length) }, null, this);\r\n    }\r\n    if (countBefore !== this.rows.length || diff.length > 0) {\r\n      this.onRowsOrCountChanged.notify({\r\n        rowsDiff: diff, previousRowCount: countBefore, currentRowCount: this.rows.length, itemCount: this.items.length,\r\n        rowCountChanged: countBefore !== this.rows.length, rowsChanged: diff.length > 0, dataView: this\r\n      }, null, this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wires the grid and the DataView together to keep row selection tied to item ids.\r\n   * This is useful since, without it, the grid only knows about rows, so if the items\r\n   * move around, the same rows stay selected instead of the selection moving along\r\n   * with the items.\r\n   *\r\n   * NOTE:  This doesn't work with cell selection model.\r\n   *\r\n   * @param {SlickGrid} grid - The grid to sync selection with.\r\n   * @param {Boolean} preserveHidden - Whether to keep selected items that go out of the\r\n   *     view due to them getting filtered out.\r\n   * @param {Boolean} [preserveHiddenOnSelectionChange] - Whether to keep selected items\r\n   *     that are currently out of the view (see preserveHidden) as selected when selection\r\n   *     changes.\r\n   * @return {Event} An event that notifies when an internal list of selected row ids\r\n   *     changes.  This is useful since, in combination with the above two options, it allows\r\n   *     access to the full list selected row ids, and not just the ones visible to the grid.\r\n   * @method syncGridSelection\r\n   */\r\n  syncGridSelection(grid: SlickGridModel, preserveHidden: boolean, preserveHiddenOnSelectionChange?: boolean) {\r\n    this._grid = grid;\r\n    let inHandler: boolean;\r\n    this.selectedRowIds = this.mapRowsToIds(grid.getSelectedRows());\r\n\r\n    /** @param {Array} rowIds */\r\n    const setSelectedRowIds = (rowIds: DataIdType[] | false) => {\r\n      if (rowIds === false) {\r\n        this.selectedRowIds = [];\r\n      } else {\r\n        if (this.selectedRowIds!.sort().join(',') !== rowIds.sort().join(',')) {\r\n          this.selectedRowIds = rowIds;\r\n        }\r\n      }\r\n    };\r\n\r\n    const update = () => {\r\n      if ((this.selectedRowIds || []).length > 0 && !inHandler) {\r\n        inHandler = true;\r\n        const selectedRows = this.mapIdsToRows(this.selectedRowIds || []);\r\n        if (!preserveHidden) {\r\n          const selectedRowsChangedArgs = {\r\n            grid: this._grid,\r\n            ids: this.mapRowsToIds(selectedRows),\r\n            rows: selectedRows,\r\n            dataView: this\r\n          };\r\n          this.preSelectedRowIdsChangeFn!(selectedRowsChangedArgs);\r\n          this.onSelectedRowIdsChanged.notify(Object.assign(selectedRowsChangedArgs, {\r\n            selectedRowIds: this.selectedRowIds,\r\n            filteredIds: this.getAllSelectedFilteredIds() as DataIdType[],\r\n          }), new SlickEventData(), this);\r\n        }\r\n        grid.setSelectedRows(selectedRows);\r\n        inHandler = false;\r\n      }\r\n    };\r\n\r\n    grid.onSelectedRowsChanged.subscribe((_e: SlickEventData_, args: { rows: number[]; }) => {\r\n      if (!inHandler) {\r\n        const newSelectedRowIds = this.mapRowsToIds(args.rows);\r\n        const selectedRowsChangedArgs = {\r\n          grid: this._grid,\r\n          ids: newSelectedRowIds,\r\n          rows: args.rows,\r\n          added: true,\r\n          dataView: this\r\n        };\r\n        this.preSelectedRowIdsChangeFn!(selectedRowsChangedArgs);\r\n        this.onSelectedRowIdsChanged.notify(Object.assign(selectedRowsChangedArgs, {\r\n          selectedRowIds: this.selectedRowIds,\r\n          filteredIds: this.getAllSelectedFilteredIds() as DataIdType[],\r\n        }), new SlickEventData(), this);\r\n      }\r\n    });\r\n\r\n    this.preSelectedRowIdsChangeFn = (args: { ids: DataIdType[]; added?: boolean; }) => {\r\n      if (!inHandler) {\r\n        inHandler = true;\r\n        const overwrite = (typeof args.added === typeof undefined);\r\n\r\n        if (overwrite) {\r\n          setSelectedRowIds(args.ids);\r\n        } else {\r\n          let rowIds: DataIdType[];\r\n          if (args.added) {\r\n            if (preserveHiddenOnSelectionChange && grid.getOptions().multiSelect) {\r\n              // find the ones that are hidden\r\n              const hiddenSelectedRowIds = this.selectedRowIds?.filter((id) => this.getRowById(id) === undefined);\r\n              // add the newly selected ones\r\n              rowIds = hiddenSelectedRowIds!.concat(args.ids);\r\n            } else {\r\n              rowIds = args.ids;\r\n            }\r\n          } else {\r\n            if (preserveHiddenOnSelectionChange && grid.getOptions().multiSelect) {\r\n              // remove rows whose id is on the list\r\n              const argsIdsSet = new Set(args.ids);\r\n              rowIds = this.selectedRowIds?.filter((id) => !argsIdsSet.has(id));\r\n            } else {\r\n              rowIds = [];\r\n            }\r\n          }\r\n          setSelectedRowIds(rowIds);\r\n        }\r\n        inHandler = false;\r\n      }\r\n    };\r\n\r\n    this.onRowsOrCountChanged.subscribe(update.bind(this));\r\n\r\n    return this.onSelectedRowIdsChanged;\r\n  }\r\n\r\n  /**\r\n   * Get all selected IDs\r\n   * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\r\n   */\r\n  getAllSelectedIds() {\r\n    return this.selectedRowIds;\r\n  }\r\n\r\n  /**\r\n   * Get all selected filtered IDs (similar to \"getAllSelectedIds\" but only return filtered data)\r\n   * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\r\n   */\r\n  getAllSelectedFilteredIds() {\r\n    return this.getAllSelectedFilteredItems().map((item) => item[this.idProperty as keyof TData]);\r\n  }\r\n\r\n  /**\r\n   * Set current row selected IDs array (regardless of Pagination)\r\n   * NOTE: This will NOT change the selection in the grid, if you need to do that then you still need to call\r\n   * \"grid.setSelectedRows(rows)\"\r\n   * @param {Array} selectedIds - list of IDs which have been selected for this action\r\n   * @param {Object} options\r\n   *  - `isRowBeingAdded`: defaults to true, are the new selected IDs being added (or removed) as new row selections\r\n   *  - `shouldTriggerEvent`: defaults to true, should we trigger `onSelectedRowIdsChanged` event\r\n   *  - `applyRowSelectionToGrid`: defaults to true, should we apply the row selections to the grid in the UI\r\n   */\r\n  setSelectedIds(selectedIds: Array<number | string>, options?: Partial<{ isRowBeingAdded: boolean; shouldTriggerEvent: boolean; applyRowSelectionToGrid: boolean; }>) {\r\n    let isRowBeingAdded = options?.isRowBeingAdded;\r\n    const shouldTriggerEvent = options?.shouldTriggerEvent;\r\n    const applyRowSelectionToGrid = options?.applyRowSelectionToGrid;\r\n\r\n    if (isRowBeingAdded !== false) {\r\n      isRowBeingAdded = true;\r\n    }\r\n    const selectedRows = this.mapIdsToRows(selectedIds);\r\n    const selectedRowsChangedArgs = {\r\n      grid: this._grid,\r\n      ids: selectedIds,\r\n      rows: selectedRows,\r\n      added: isRowBeingAdded,\r\n      dataView: this\r\n    };\r\n    this.preSelectedRowIdsChangeFn?.(selectedRowsChangedArgs);\r\n\r\n    if (shouldTriggerEvent !== false) {\r\n      this.onSelectedRowIdsChanged.notify(Object.assign(selectedRowsChangedArgs, {\r\n        selectedRowIds: this.selectedRowIds,\r\n        filteredIds: this.getAllSelectedFilteredIds() as DataIdType[],\r\n      }), new SlickEventData(), this);\r\n    }\r\n\r\n    // should we also apply the row selection in to the grid (UI) as well?\r\n    if (applyRowSelectionToGrid !== false && this._grid) {\r\n      this._grid.setSelectedRows(selectedRows);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all selected dataContext items\r\n   * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\r\n   */\r\n  getAllSelectedItems<T extends TData>() {\r\n    const selectedData: TData[] = [];\r\n    const selectedIds = this.getAllSelectedIds();\r\n    selectedIds!.forEach((id) => {\r\n      selectedData.push(this.getItemById(id));\r\n    });\r\n    return selectedData as T[];\r\n  }\r\n\r\n  /**\r\n  * Get all selected filtered dataContext items (similar to \"getAllSelectedItems\" but only return filtered data)\r\n  * Note: when using Pagination it will also include hidden selections assuming `preserveHiddenOnSelectionChange` is set to true.\r\n  */\r\n  getAllSelectedFilteredItems<T extends TData>() {\r\n    if (!Array.isArray(this.selectedRowIds)) {\r\n      return [];\r\n    }\r\n\r\n    const selectedRowIdSet = new Set<DataIdType>(this.selectedRowIds);\r\n    const intersection = this.filteredItems.filter((a) => selectedRowIdSet.has(a[this.idProperty as keyof TData] as DataIdType));\r\n    return (intersection || []) as T[];\r\n  }\r\n\r\n  syncGridCellCssStyles(grid: SlickGridModel, key: string) {\r\n    let hashById: any;\r\n    let inHandler: boolean;\r\n\r\n    const storeCellCssStyles = (hash: CssStyleHash) => {\r\n      hashById = {};\r\n      if (typeof hash === 'object') {\r\n        Object.keys(hash).forEach(row => {\r\n          if (hash) {\r\n            const id = this.rows[row as any][this.idProperty as keyof TData];\r\n            hashById[id] = hash[row];\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    // since this method can be called after the cell styles have been set,\r\n    // get the existing ones right away\r\n    storeCellCssStyles(grid.getCellCssStyles(key));\r\n\r\n    const update = () => {\r\n      if (typeof hashById === 'object') {\r\n        inHandler = true;\r\n        this.ensureRowsByIdCache();\r\n        const newHash: CssStyleHash = {};\r\n        Object.keys(hashById).forEach(id => {\r\n          const row = this.rowsById?.[id];\r\n          if (Utils.isDefined(row)) {\r\n            newHash[row as number] = hashById[id];\r\n          }\r\n        });\r\n        grid.setCellCssStyles(key, newHash);\r\n        inHandler = false;\r\n      }\r\n    };\r\n\r\n    grid.onCellCssStylesChanged.subscribe((_e: SlickEventData_, args: any) => {\r\n      if (inHandler) { return; }\r\n      if (key !== args.key) { return; }\r\n      if (args.hash) {\r\n        storeCellCssStyles(args.hash);\r\n      } else {\r\n        grid.onCellCssStylesChanged.unsubscribe();\r\n        this.onRowsOrCountChanged.unsubscribe(update);\r\n      }\r\n    });\r\n\r\n    this.onRowsOrCountChanged.subscribe(update.bind(this));\r\n  }\r\n}\r\n\r\nexport class AvgAggregator<T = any> implements Aggregator {\r\n  private _nonNullCount = 0;\r\n  private _sum = 0;\r\n  private _field: number | string;\r\n  private _type = 'avg' as const;\r\n\r\n  constructor(field: number | string) {\r\n    this._field = field;\r\n  }\r\n\r\n  get field(): number | string {\r\n    return this._field;\r\n  }\r\n\r\n  get type(): string {\r\n    return this._type;\r\n  }\r\n\r\n  init(): void {\r\n    this._nonNullCount = 0;\r\n    this._sum = 0;\r\n  }\r\n\r\n  accumulate(item: T) {\r\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\r\n    if (val !== null && val !== '' && !isNaN(val)) {\r\n      this._nonNullCount++;\r\n      this._sum += parseFloat(val);\r\n    }\r\n  }\r\n\r\n  storeResult(groupTotals: SlickGroupTotals_ & { avg: Record<number | string, number>; }) {\r\n    if (!groupTotals || groupTotals[this._type] === undefined) {\r\n      (groupTotals as any)[this._type] = {};\r\n    }\r\n    if (this._nonNullCount !== 0) {\r\n      groupTotals[this._type][this._field] = this._sum / this._nonNullCount;\r\n    }\r\n  }\r\n}\r\n\r\nexport class MinAggregator<T = any> implements Aggregator {\r\n  private _min: number | null = null;\r\n  private _field: number | string;\r\n  private _type = 'min' as const;\r\n\r\n  constructor(field: number | string) {\r\n    this._field = field;\r\n  }\r\n\r\n  get field(): number | string {\r\n    return this._field;\r\n  }\r\n\r\n  get type(): string {\r\n    return this._type;\r\n  }\r\n\r\n  init() {\r\n    this._min = null;\r\n  }\r\n\r\n  accumulate(item: T) {\r\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\r\n    if (val !== null && val !== '' && !isNaN(val)) {\r\n      if (this._min === null || val < this._min) {\r\n        this._min = parseFloat(val);\r\n      }\r\n    }\r\n  }\r\n\r\n  storeResult(groupTotals: SlickGroupTotals_ & { min: Record<number | string, number | null>; }) {\r\n    if (!groupTotals || groupTotals[this._type] === undefined) {\r\n      groupTotals[this._type] = {};\r\n    }\r\n    groupTotals[this._type][this._field] = this._min;\r\n  }\r\n}\r\n\r\nexport class MaxAggregator<T = any> implements Aggregator {\r\n  private _max: number | null = null;\r\n  private _field: number | string;\r\n  private _type = 'max' as const;\r\n\r\n  constructor(field: number | string) {\r\n    this._field = field;\r\n  }\r\n\r\n  get field(): number | string {\r\n    return this._field;\r\n  }\r\n\r\n  get type(): string {\r\n    return this._type;\r\n  }\r\n\r\n  init(): void {\r\n    this._max = null;\r\n  }\r\n\r\n  accumulate(item: T) {\r\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\r\n    if (val !== null && val !== '' && !isNaN(val)) {\r\n      if (this._max === null || val > this._max) {\r\n        this._max = parseFloat(val);\r\n      }\r\n    }\r\n  }\r\n\r\n  storeResult(groupTotals: SlickGroupTotals_ & { max: Record<number | string, number | null>; }) {\r\n    if (!groupTotals || groupTotals[this._type] === undefined) {\r\n      groupTotals[this._type] = {};\r\n    }\r\n    groupTotals[this._type][this._field] = this._max;\r\n  }\r\n}\r\n\r\nexport class SumAggregator<T = any> implements Aggregator {\r\n  private _sum = 0;\r\n  private _field: number | string;\r\n  private _type = 'sum' as const;\r\n\r\n  constructor(field: number | string) {\r\n    this._field = field;\r\n  }\r\n\r\n  get field(): number | string {\r\n    return this._field;\r\n  }\r\n\r\n  get type(): string {\r\n    return this._type;\r\n  }\r\n\r\n  init() {\r\n    this._sum = 0;\r\n  }\r\n\r\n  accumulate(item: T) {\r\n    const val: any = (item?.hasOwnProperty(this._field)) ? item[this._field as keyof T] : null;\r\n    if (val !== null && val !== '' && !isNaN(val)) {\r\n      this._sum += parseFloat(val);\r\n    }\r\n  }\r\n\r\n  storeResult(groupTotals: SlickGroupTotals_ & { sum: Record<number | string, number>; }) {\r\n    if (!groupTotals || groupTotals[this._type] === undefined) {\r\n      groupTotals[this._type] = {};\r\n    }\r\n    groupTotals[this._type][this._field] = this._sum;\r\n  }\r\n}\r\n\r\nexport class CountAggregator implements Aggregator {\r\n  private _field: number | string;\r\n  private _type = 'count' as const;\r\n\r\n  constructor(field: number | string) {\r\n    this._field = field;\r\n  }\r\n\r\n  get field(): number | string {\r\n    return this._field;\r\n  }\r\n\r\n  get type(): string {\r\n    return this._type;\r\n  }\r\n\r\n  init(): void {\r\n  }\r\n\r\n  storeResult(groupTotals: SlickGroupTotals_ & { count: Record<number | string, number>; }) {\r\n    if (!groupTotals || groupTotals[this._type] === undefined) {\r\n      groupTotals[this._type] = {};\r\n    }\r\n    groupTotals[this._type][this._field] = groupTotals.group.rows.length;\r\n  }\r\n}\r\n\r\n// TODO:  add more built-in aggregators\r\n// TODO:  merge common aggregators in one to prevent needless iterating\r\n\r\nexport const Aggregators = {\r\n  Avg: AvgAggregator,\r\n  Min: MinAggregator,\r\n  Max: MaxAggregator,\r\n  Sum: SumAggregator,\r\n  Count: CountAggregator\r\n};\r\n\r\n// extend Slick namespace on window object when building as iife\r\nif (IIFE_ONLY && window.Slick) {\r\n  window.Slick.Data = window.Slick.Data || {};\r\n  window.Slick.Data.DataView = SlickDataView;\r\n  window.Slick.Data.Aggregators = Aggregators;\r\n}\r\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}
