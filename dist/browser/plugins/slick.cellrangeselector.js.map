{
  "version": 3,
  "sources": ["../../../src/plugins/slick.cellrangeselector.js"],
  "sourcesContent": ["import { Event as SlickEvent_, EventHandler as EventHandler_, Range as SlickRange_, Utils as Utils_ } from '../slick.core';\nimport { Draggable as Draggable_ } from '../slick.interactions';\nimport { CellRangeDecorator as CellRangeDecorator_ } from './slick.cellrangedecorator';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (cjs/esm)\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst EventHandler = IIFE_ONLY ? Slick.EventHandler : EventHandler_;\nconst SlickRange = IIFE_ONLY ? Slick.Range : SlickRange_;\nconst Draggable = IIFE_ONLY ? Slick.Draggable : Draggable_;\nconst CellRangeDecorator = IIFE_ONLY ? Slick.CellRangeDecorator : CellRangeDecorator_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\nexport function CellRangeSelector(options) {\n    var _grid;\n    var _currentlySelectedRange;\n    var _canvas;\n    var _gridOptions;\n    var _activeCanvas;\n    var _dragging;\n    var _decorator;\n    var _self = this;\n  var _handler = new EventHandler();\n    var _defaults = {\n      autoScroll: true,\n      minIntervalToShowNextCell: 30,\n      maxIntervalToShowNextCell: 600, // better to a multiple of minIntervalToShowNextCell\n      accelerateInterval: 5,          // increase 5ms when cursor 1px outside the viewport.\n      selectionCss: {\n        \"border\": \"2px dashed blue\"\n      }\n    };\n\n    // Frozen row & column variables\n    var _rowOffset;\n    var _columnOffset;\n    var _isRightCanvas;\n    var _isBottomCanvas;\n\n    // autoScroll related variables\n    var _activeViewport;\n    var _viewportWidth;\n    var _viewportHeight;\n    var _draggingMouseOffset;\n    var _moveDistanceForOneCell;\n    var _autoScrollTimerId;\n    var _xDelayForNextCell;\n    var _yDelayForNextCell;\n    var _isRowMoveRegistered = false;\n\n    // Scrollings\n    var _scrollTop = 0;\n    var _scrollLeft = 0;\n\n    function init(grid) {\n      if (typeof Draggable === \"undefined\") {\n        throw new Error('Slick.Draggable is undefined, make sure to import \"slick.interactions.js\"');\n      }\n\n      options = Utils.extend(true, {}, _defaults, options);\n      _decorator = options.cellDecorator || new CellRangeDecorator(grid, options);\n      _grid = grid;\n      _canvas = _grid.getCanvasNode();\n      _gridOptions = _grid.getOptions();\n      _handler\n        .subscribe(_grid.onScroll, handleScroll)\n        .subscribe(_grid.onDragInit, handleDragInit)\n        .subscribe(_grid.onDragStart, handleDragStart)\n        .subscribe(_grid.onDrag, handleDrag)\n        .subscribe(_grid.onDragEnd, handleDragEnd);\n    }\n\n    function destroy() {\n      _handler.unsubscribeAll();\n      _activeCanvas = null;\n      _activeViewport = null;\n      _canvas = null;\n      if (_decorator && _decorator.destroy) {\n        _decorator.destroy();\n      }\n    }\n\n    function getCellDecorator() {\n      return _decorator;\n    }\n\n    function handleScroll(e, args) {\n      _scrollTop = args.scrollTop;\n      _scrollLeft = args.scrollLeft;\n    }\n\n    function handleDragInit(e) {\n      // Set the active canvas node because the decorator needs to append its\n      // box to the correct canvas\n      _activeCanvas = _grid.getActiveCanvasNode(e);\n      _activeViewport = _grid.getActiveViewportNode(e);\n\n      var scrollbarDimensions = _grid.getDisplayedScrollbarDimensions()\n      _viewportWidth = _activeViewport.offsetWidth - scrollbarDimensions.width;\n      _viewportHeight = _activeViewport.offsetHeight - scrollbarDimensions.height;\n\n      _moveDistanceForOneCell = {\n        x: _grid.getAbsoluteColumnMinWidth() / 2,\n        y: _grid.getOptions().rowHeight / 2\n      }\n      _isRowMoveRegistered = hasRowMoveManager();\n\n      _rowOffset = 0;\n      _columnOffset = 0;\n      _isBottomCanvas = _activeCanvas.classList.contains('grid-canvas-bottom');\n\n      if (_gridOptions.frozenRow > -1 && _isBottomCanvas) {\n        const canvasSelector = `.${_grid.getUID()} .grid-canvas-${_gridOptions.frozenBottom ? 'bottom' : 'top'}`;\n        const canvasElm = document.querySelector(canvasSelector);\n        if (canvasElm) {\n          _rowOffset = canvasElm.clientHeight || 0;\n        }\n      }\n\n      _isRightCanvas = _activeCanvas.classList.contains('grid-canvas-right');\n\n      if (_gridOptions.frozenColumn > -1 && _isRightCanvas) {\n        const canvasLeftElm = document.querySelector(`.${_grid.getUID()} .grid-canvas-left`);\n        if (canvasLeftElm) {\n          _columnOffset = canvasLeftElm.clientWidth || 0;\n        }\n      }\n\n      // prevent the grid from cancelling drag'n'drop by default\n      e.stopImmediatePropagation();\n      e.preventDefault();\n    }\n\n    function handleDragStart(e, dd) {\n      var cell = _grid.getCellFromEvent(e);\n      if (_self.onBeforeCellRangeSelected.notify(cell) !== false) {\n        if (_grid.canCellBeSelected(cell.row, cell.cell)) {\n          _dragging = true;\n          e.stopImmediatePropagation();\n        }\n      }\n      if (!_dragging) {\n        return;\n      }\n\n      _grid.focus();\n\n      let canvasOffset = Utils.offset(_canvas);\n\n      let startX = dd.startX - (canvasOffset.left || 0);\n      if (_gridOptions.frozenColumn >= 0 && _isRightCanvas) {\n        startX += _scrollLeft;\n      }\n\n      let startY = dd.startY - (canvasOffset.top || 0);\n      if (_gridOptions.frozenRow >= 0 && _isBottomCanvas) {\n        startY += _scrollTop;\n      }\n\n      var start = _grid.getCellFromPoint(startX, startY);\n\n      dd.range = { start: start, end: {} };\n      _currentlySelectedRange = dd.range;\n      return _decorator.show(new SlickRange(start.row, start.cell));\n    }\n\n    function handleDrag(evt, dd) {\n      if (!_dragging && !_isRowMoveRegistered) {\n        return;\n      }\n      if (!_isRowMoveRegistered) {\n        evt.stopImmediatePropagation();\n      }\n\n      const e = evt.getNativeEvent();\n      if (options.autoScroll) {\n        _draggingMouseOffset = getMouseOffsetViewport(e, dd);\n        if (_draggingMouseOffset.isOutsideViewport) {\n          return handleDragOutsideViewport();\n        }\n      }\n      stopIntervalTimer();\n      handleDragTo(e, dd);\n    }\n\n    function getMouseOffsetViewport(e, dd) {\n      var targetEvent = e.touches ? e.touches[0] : e;\n      var viewportLeft = _activeViewport.scrollLeft;\n      var viewportTop = _activeViewport.scrollTop;\n      var viewportRight = viewportLeft + _viewportWidth;\n      var viewportBottom = viewportTop + _viewportHeight;\n\n      var viewportOffset = Utils.offset(_activeViewport);\n      var viewportOffsetLeft = viewportOffset.left || 0;\n      var viewportOffsetTop = viewportOffset.top || 0;\n      var viewportOffsetRight = viewportOffsetLeft + _viewportWidth;\n      var viewportOffsetBottom = viewportOffsetTop + _viewportHeight;\n\n      var result = {\n        e: e,\n        dd: dd,\n        viewport: {\n          left: viewportLeft,\n          top: viewportTop,\n          right: viewportRight,\n          bottom: viewportBottom,\n          offset: {\n            left: viewportOffsetLeft,\n            top: viewportOffsetTop,\n            right: viewportOffsetRight,\n            bottom: viewportOffsetBottom\n          }\n        },\n        // Consider the viewport as the origin, the `offset` is based on the coordinate system:\n        // the cursor is on the viewport's left/bottom when it is less than 0, and on the right/top when greater than 0.\n        offset: {\n          x: 0,\n          y: 0\n        },\n        isOutsideViewport: false\n      }\n      // ... horizontal\n      if (targetEvent.pageX < viewportOffsetLeft) {\n        result.offset.x = targetEvent.pageX - viewportOffsetLeft;\n      } else if (targetEvent.pageX > viewportOffsetRight) {\n        result.offset.x = targetEvent.pageX - viewportOffsetRight;\n      }\n      // ... vertical\n      if (targetEvent.pageY < viewportOffsetTop) {\n        result.offset.y = viewportOffsetTop - targetEvent.pageY;\n      } else if (targetEvent.pageY > viewportOffsetBottom) {\n        result.offset.y = viewportOffsetBottom - targetEvent.pageY;\n      }\n      result.isOutsideViewport = !!result.offset.x || !!result.offset.y;\n      return result;\n    }\n\n    function handleDragOutsideViewport() {\n      _xDelayForNextCell = options.maxIntervalToShowNextCell - Math.abs(_draggingMouseOffset.offset.x) * options.accelerateInterval;\n      _yDelayForNextCell = options.maxIntervalToShowNextCell - Math.abs(_draggingMouseOffset.offset.y) * options.accelerateInterval;\n      // only one timer is created to handle the case that cursor outside the viewport\n      if (!_autoScrollTimerId) {\n        var xTotalDelay = 0;\n        var yTotalDelay = 0;\n        _autoScrollTimerId = setInterval(function () {\n          var xNeedUpdate = false;\n          var yNeedUpdate = false;\n          // ... horizontal\n          if (_draggingMouseOffset.offset.x) {\n            xTotalDelay += options.minIntervalToShowNextCell;\n            xNeedUpdate = xTotalDelay >= _xDelayForNextCell;\n          } else {\n            xTotalDelay = 0;\n          }\n          // ... vertical\n          if (_draggingMouseOffset.offset.y) {\n            yTotalDelay += options.minIntervalToShowNextCell;\n            yNeedUpdate = yTotalDelay >= _yDelayForNextCell;\n          } else {\n            yTotalDelay = 0;\n          }\n          if (xNeedUpdate || yNeedUpdate) {\n            if (xNeedUpdate) {\n              xTotalDelay = 0;\n            }\n            if (yNeedUpdate) {\n              yTotalDelay = 0;\n            }\n            handleDragToNewPosition(xNeedUpdate, yNeedUpdate);\n          }\n        }, options.minIntervalToShowNextCell);\n      }\n    }\n\n    function handleDragToNewPosition(xNeedUpdate, yNeedUpdate) {\n      var pageX = _draggingMouseOffset.e.pageX;\n      var pageY = _draggingMouseOffset.e.pageY;\n      var mouseOffsetX = _draggingMouseOffset.offset.x;\n      var mouseOffsetY = _draggingMouseOffset.offset.y;\n      var viewportOffset = _draggingMouseOffset.viewport.offset;\n      // ... horizontal\n      if (xNeedUpdate && mouseOffsetX) {\n        if (mouseOffsetX > 0) {\n          pageX = viewportOffset.right + _moveDistanceForOneCell.x;\n        } else {\n          pageX = viewportOffset.left - _moveDistanceForOneCell.x;\n        }\n      }\n      // ... vertical\n      if (yNeedUpdate && mouseOffsetY) {\n        if (mouseOffsetY > 0) {\n          pageY = viewportOffset.top - _moveDistanceForOneCell.y;\n        } else {\n          pageY = viewportOffset.bottom + _moveDistanceForOneCell.y;\n        }\n      }\n      handleDragTo({\n        pageX: pageX,\n        pageY: pageY\n      }, _draggingMouseOffset.dd);\n    }\n\n    function stopIntervalTimer() {\n      clearInterval(_autoScrollTimerId);\n      _autoScrollTimerId = null;\n    }\n\n    function handleDragTo(e, dd) {\n      let targetEvent = e.touches ? e.touches[0] : e;\n      let canvasOffset = Utils.offset(_activeCanvas);\n      let end = _grid.getCellFromPoint(\n        targetEvent.pageX - (canvasOffset && canvasOffset.left || 0) + _columnOffset,\n        targetEvent.pageY - (canvasOffset && canvasOffset.top || 0) + _rowOffset\n      );\n\n      // ... frozen column(s),\n      if ( _gridOptions.frozenColumn >= 0 && (!_isRightCanvas && (end.cell > _gridOptions.frozenColumn)) || (_isRightCanvas && (end.cell <= _gridOptions.frozenColumn)) ) {\n        return;\n      }\n\n      // ... or frozen row(s)\n      if ( _gridOptions.frozenRow >= 0 && (!_isBottomCanvas && (end.row >= _gridOptions.frozenRow)) || (_isBottomCanvas && (end.row < _gridOptions.frozenRow)) ) {\n        return;\n      }\n\n      // scrolling the viewport to display the target `end` cell if it is not fully displayed\n      if (options.autoScroll && _draggingMouseOffset) {\n        var endCellBox = _grid.getCellNodeBox(end.row, end.cell);\n        if (!endCellBox) {\n          return;\n        }\n        var viewport = _draggingMouseOffset.viewport;\n        if (endCellBox.left < viewport.left || endCellBox.right > viewport.right\n          || endCellBox.top < viewport.top || endCellBox.bottom > viewport.bottom) {\n          _grid.scrollCellIntoView(end.row, end.cell);\n        }\n      }\n\n      // ... or regular grid (without any frozen options)\n      if (!_grid.canCellBeSelected(end.row, end.cell)) {\n        return;\n      }\n\n      if (dd && dd.range) {\n        dd.range.end = end;\n\n        var range = new SlickRange(dd.range.start.row, dd.range.start.cell, end.row, end.cell);\n        _decorator.show(range);\n        _self.onCellRangeSelecting.notify({\n          range: range\n        });\n      }\n    }\n\n    function hasRowMoveManager() {\n      return !!(_grid.getPluginByName('RowMoveManager') || _grid.getPluginByName('CrossGridRowMoveManager'));\n    }\n\n    function handleDragEnd(e, dd) {\n      if (!_dragging) {\n        return;\n      }\n\n      _dragging = false;\n      e.stopImmediatePropagation();\n\n      stopIntervalTimer();\n      _decorator.hide();\n      _self.onCellRangeSelected.notify({\n        range: new SlickRange(\n          dd.range.start.row,\n          dd.range.start.cell,\n          dd.range.end.row,\n          dd.range.end.cell\n        )\n      });\n    }\n\n    function getCurrentRange() {\n      return _currentlySelectedRange;\n    }\n\n  Utils.extend(this, {\n      \"init\": init,\n      \"destroy\": destroy,\n      \"pluginName\": \"CellRangeSelector\",\n\n      \"getCellDecorator\": getCellDecorator,\n      \"getCurrentRange\": getCurrentRange,\n\n    \"onBeforeCellRangeSelected\": new SlickEvent(),\n    \"onCellRangeSelected\": new SlickEvent(),\n    \"onCellRangeSelecting\": new SlickEvent()\n    });\n  }\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(Slick, {\n    CellRangeSelector\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
