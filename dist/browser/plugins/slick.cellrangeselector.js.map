{
  "version": 3,
  "sources": ["../../../src/plugins/slick.cellrangeselector.ts"],
  "sourcesContent": ["import { SlickEvent as SlickEvent_, type SlickEventData, SlickEventHandler as SlickEventHandler_, SlickRange as SlickRange_, Utils as Utils_ } from '../slick.core.js';\r\nimport { Draggable as Draggable_ } from '../slick.interactions.js';\r\nimport { SlickCellRangeDecorator as SlickCellRangeDecorator_ } from './slick.cellrangedecorator.js';\r\nimport type { CellRangeSelectorOption, DragPosition, DragRange, DragRowMove, GridOption, MouseOffsetViewport, OnScrollEventArgs, SlickPlugin } from '../models/index.js';\r\nimport type { SlickGrid } from '../slick.grid.js';\r\n\r\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\r\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\r\nconst SlickEventHandler = IIFE_ONLY ? Slick.EventHandler : SlickEventHandler_;\r\nconst SlickRange = IIFE_ONLY ? Slick.Range : SlickRange_;\r\nconst Draggable = IIFE_ONLY ? Slick.Draggable : Draggable_;\r\nconst SlickCellRangeDecorator = IIFE_ONLY ? Slick.CellRangeDecorator : SlickCellRangeDecorator_;\r\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\r\n\r\nexport class SlickCellRangeSelector implements SlickPlugin {\r\n  // --\r\n  // public API\r\n  pluginName = 'CellRangeSelector' as const;\r\n  onBeforeCellRangeSelected = new SlickEvent<{ row: number; cell: number; }>('onBeforeCellRangeSelected');\r\n  onCellRangeSelected = new SlickEvent<{ range: SlickRange_; }>('onCellRangeSelected');\r\n  onCellRangeSelecting = new SlickEvent<{ range: SlickRange_; }>('onCellRangeSelecting');\r\n\r\n  // --\r\n  // protected props\r\n  protected _grid!: SlickGrid;\r\n  protected _currentlySelectedRange: DragRange | null = null;\r\n  protected _canvas: HTMLElement | null = null;\r\n  protected _decorator!: SlickCellRangeDecorator_;\r\n  protected _gridOptions!: GridOption;\r\n  protected _activeCanvas!: HTMLElement;\r\n  protected _dragging = false;\r\n  protected _handler = new SlickEventHandler();\r\n  protected _options: CellRangeSelectorOption;\r\n  protected _defaults = {\r\n    autoScroll: true,\r\n    minIntervalToShowNextCell: 30,\r\n    maxIntervalToShowNextCell: 600, // better to a multiple of minIntervalToShowNextCell\r\n    accelerateInterval: 5,          // increase 5ms when cursor 1px outside the viewport.\r\n    selectionCss: {\r\n      border: '2px dashed blue'\r\n    }\r\n  } as CellRangeSelectorOption;\r\n\r\n  // Frozen row & column variables\r\n  protected _rowOffset = 0;\r\n  protected _columnOffset = 0;\r\n  protected _isRightCanvas = false;\r\n  protected _isBottomCanvas = false;\r\n\r\n  // autoScroll related constiables\r\n  protected _activeViewport!: HTMLElement;\r\n  protected _autoScrollTimerId?: number;\r\n  protected _draggingMouseOffset!: MouseOffsetViewport;\r\n  protected _moveDistanceForOneCell!: { x: number; y: number; };\r\n  protected _xDelayForNextCell = 0;\r\n  protected _yDelayForNextCell = 0;\r\n  protected _viewportHeight = 0;\r\n  protected _viewportWidth = 0;\r\n  protected _isRowMoveRegistered = false;\r\n\r\n  // Scrollings\r\n  protected _scrollLeft = 0;\r\n  protected _scrollTop = 0;\r\n\r\n  constructor(options?: Partial<CellRangeSelectorOption>) {\r\n    this._options = Utils.extend(true, {}, this._defaults, options);\r\n  }\r\n\r\n  init(grid: SlickGrid) {\r\n    if (Draggable === undefined) {\r\n      throw new Error('Slick.Draggable is undefined, make sure to import \"slick.interactions.js\"');\r\n    }\r\n\r\n    this._decorator = this._options.cellDecorator || new SlickCellRangeDecorator(grid, this._options);\r\n    this._grid = grid;\r\n    Utils.addSlickEventPubSubWhenDefined(grid.getPubSubService(), this);\r\n    this._canvas = this._grid.getCanvasNode();\r\n    this._gridOptions = this._grid.getOptions();\r\n    this._handler\r\n      .subscribe(this._grid.onScroll, this.handleScroll.bind(this))\r\n      .subscribe(this._grid.onDragInit, this.handleDragInit.bind(this))\r\n      .subscribe(this._grid.onDragStart, this.handleDragStart.bind(this))\r\n      .subscribe(this._grid.onDrag, this.handleDrag.bind(this))\r\n      .subscribe(this._grid.onDragEnd, this.handleDragEnd.bind(this));\r\n  }\r\n\r\n  destroy() {\r\n    this._handler.unsubscribeAll();\r\n    this._activeCanvas = null as any;\r\n    this._activeViewport = null as any;\r\n    this._canvas = null;\r\n    this._decorator?.destroy();\r\n  }\r\n\r\n  getCellDecorator() {\r\n    return this._decorator;\r\n  }\r\n\r\n  protected handleScroll(_e: SlickEventData, args: OnScrollEventArgs) {\r\n    this._scrollTop = args.scrollTop;\r\n    this._scrollLeft = args.scrollLeft;\r\n  }\r\n\r\n  protected handleDragInit(e: SlickEventData) {\r\n    // Set the active canvas node because the decorator needs to append its\r\n    // box to the correct canvas\r\n    this._activeCanvas = this._grid.getActiveCanvasNode(e);\r\n    this._activeViewport = this._grid.getActiveViewportNode(e);\r\n\r\n    const scrollbarDimensions = this._grid.getDisplayedScrollbarDimensions();\r\n    this._viewportWidth = this._activeViewport.offsetWidth - scrollbarDimensions.width;\r\n    this._viewportHeight = this._activeViewport.offsetHeight - scrollbarDimensions.height;\r\n\r\n    this._moveDistanceForOneCell = {\r\n      x: this._grid.getAbsoluteColumnMinWidth() / 2,\r\n      y: this._grid.getOptions().rowHeight! / 2\r\n    };\r\n    this._isRowMoveRegistered = this.hasRowMoveManager();\r\n\r\n    this._rowOffset = 0;\r\n    this._columnOffset = 0;\r\n    this._isBottomCanvas = this._activeCanvas.classList.contains('grid-canvas-bottom');\r\n\r\n    if (this._gridOptions.frozenRow! > -1 && this._isBottomCanvas) {\r\n      const canvasSelector = `.${this._grid.getUID()} .grid-canvas-${this._gridOptions.frozenBottom ? 'bottom' : 'top'}`;\r\n      const canvasElm = document.querySelector(canvasSelector);\r\n      if (canvasElm) {\r\n        this._rowOffset = canvasElm.clientHeight || 0;\r\n      }\r\n    }\r\n\r\n    this._isRightCanvas = this._activeCanvas.classList.contains('grid-canvas-right');\r\n\r\n    if (this._gridOptions.frozenColumn! > -1 && this._isRightCanvas) {\r\n      const canvasLeftElm = document.querySelector(`.${this._grid.getUID()} .grid-canvas-left`);\r\n      if (canvasLeftElm) {\r\n        this._columnOffset = canvasLeftElm.clientWidth || 0;\r\n      }\r\n    }\r\n\r\n    // prevent the grid from cancelling drag'n'drop by default\r\n    e.stopImmediatePropagation();\r\n    e.preventDefault();\r\n  }\r\n\r\n  protected handleDragStart(e: SlickEventData, dd: DragRowMove) {\r\n    const cell = this._grid.getCellFromEvent(e);\r\n    if (cell && this.onBeforeCellRangeSelected.notify(cell).getReturnValue() !== false && this._grid.canCellBeSelected(cell.row, cell.cell)) {\r\n      this._dragging = true;\r\n      e.stopImmediatePropagation();\r\n    }\r\n    if (!this._dragging) {\r\n      return;\r\n    }\r\n\r\n    this._grid.focus();\r\n\r\n    const canvasOffset = Utils.offset(this._canvas);\r\n\r\n    let startX = dd.startX - (canvasOffset?.left ?? 0);\r\n    if (this._gridOptions.frozenColumn! >= 0 && this._isRightCanvas) {\r\n      startX += this._scrollLeft;\r\n    }\r\n\r\n    let startY = dd.startY - (canvasOffset?.top ?? 0);\r\n    if (this._gridOptions.frozenRow! >= 0 && this._isBottomCanvas) {\r\n      startY += this._scrollTop;\r\n    }\r\n\r\n    const start = this._grid.getCellFromPoint(startX, startY);\r\n\r\n    dd.range = { start, end: {} };\r\n    this._currentlySelectedRange = dd.range;\r\n    return this._decorator.show(new SlickRange(start.row, start.cell));\r\n  }\r\n\r\n  protected handleDrag(evt: SlickEventData, dd: DragRowMove) {\r\n    if (!this._dragging && !this._isRowMoveRegistered) {\r\n      return;\r\n    }\r\n    if (!this._isRowMoveRegistered) {\r\n      evt.stopImmediatePropagation();\r\n    }\r\n\r\n    const e = evt.getNativeEvent<MouseEvent>();\r\n    if (this._options.autoScroll) {\r\n      this._draggingMouseOffset = this.getMouseOffsetViewport(e, dd);\r\n      if (this._draggingMouseOffset.isOutsideViewport) {\r\n        return this.handleDragOutsideViewport();\r\n      }\r\n    }\r\n    this.stopIntervalTimer();\r\n    this.handleDragTo(e, dd);\r\n  }\r\n\r\n  protected getMouseOffsetViewport(e: MouseEvent | TouchEvent, dd: DragRowMove): MouseOffsetViewport {\r\n    const targetEvent: MouseEvent | Touch = (e as TouchEvent)?.touches?.[0] ?? e;\r\n    const viewportLeft = this._activeViewport.scrollLeft;\r\n    const viewportTop = this._activeViewport.scrollTop;\r\n    const viewportRight = viewportLeft + this._viewportWidth;\r\n    const viewportBottom = viewportTop + this._viewportHeight;\r\n\r\n    const viewportOffset = Utils.offset(this._activeViewport);\r\n    const viewportOffsetLeft = viewportOffset?.left ?? 0;\r\n    const viewportOffsetTop = viewportOffset?.top ?? 0;\r\n    const viewportOffsetRight = viewportOffsetLeft + this._viewportWidth;\r\n    const viewportOffsetBottom = viewportOffsetTop + this._viewportHeight;\r\n\r\n    const result = {\r\n      e,\r\n      dd,\r\n      viewport: {\r\n        left: viewportLeft,\r\n        top: viewportTop,\r\n        right: viewportRight,\r\n        bottom: viewportBottom,\r\n        offset: {\r\n          left: viewportOffsetLeft,\r\n          top: viewportOffsetTop,\r\n          right: viewportOffsetRight,\r\n          bottom: viewportOffsetBottom\r\n        }\r\n      },\r\n      // Consider the viewport as the origin, the `offset` is based on the coordinate system:\r\n      // the cursor is on the viewport's left/bottom when it is less than 0, and on the right/top when greater than 0.\r\n      offset: {\r\n        x: 0,\r\n        y: 0\r\n      },\r\n      isOutsideViewport: false\r\n    };\r\n    // ... horizontal\r\n    if (targetEvent.pageX < viewportOffsetLeft) {\r\n      result.offset.x = targetEvent.pageX - viewportOffsetLeft;\r\n    } else if (targetEvent.pageX > viewportOffsetRight) {\r\n      result.offset.x = targetEvent.pageX - viewportOffsetRight;\r\n    }\r\n    // ... vertical\r\n    if (targetEvent.pageY < viewportOffsetTop) {\r\n      result.offset.y = viewportOffsetTop - targetEvent.pageY;\r\n    } else if (targetEvent.pageY > viewportOffsetBottom) {\r\n      result.offset.y = viewportOffsetBottom - targetEvent.pageY;\r\n    }\r\n    result.isOutsideViewport = !!result.offset.x || !!result.offset.y;\r\n    return result;\r\n  }\r\n\r\n  protected handleDragOutsideViewport() {\r\n    this._xDelayForNextCell = this._options.maxIntervalToShowNextCell - Math.abs(this._draggingMouseOffset.offset.x) * this._options.accelerateInterval;\r\n    this._yDelayForNextCell = this._options.maxIntervalToShowNextCell - Math.abs(this._draggingMouseOffset.offset.y) * this._options.accelerateInterval;\r\n    // only one timer is created to handle the case that cursor outside the viewport\r\n    if (!this._autoScrollTimerId) {\r\n      let xTotalDelay = 0;\r\n      let yTotalDelay = 0;\r\n      this._autoScrollTimerId = window.setInterval(() => {\r\n        let xNeedUpdate = false;\r\n        let yNeedUpdate = false;\r\n        // ... horizontal\r\n        if (this._draggingMouseOffset.offset.x) {\r\n          xTotalDelay += this._options.minIntervalToShowNextCell;\r\n          xNeedUpdate = xTotalDelay >= this._xDelayForNextCell;\r\n        } else {\r\n          xTotalDelay = 0;\r\n        }\r\n        // ... vertical\r\n        if (this._draggingMouseOffset.offset.y) {\r\n          yTotalDelay += this._options.minIntervalToShowNextCell;\r\n          yNeedUpdate = yTotalDelay >= this._yDelayForNextCell;\r\n        } else {\r\n          yTotalDelay = 0;\r\n        }\r\n        if (xNeedUpdate || yNeedUpdate) {\r\n          if (xNeedUpdate) {\r\n            xTotalDelay = 0;\r\n          }\r\n          if (yNeedUpdate) {\r\n            yTotalDelay = 0;\r\n          }\r\n          this.handleDragToNewPosition(xNeedUpdate, yNeedUpdate);\r\n        }\r\n      }, this._options.minIntervalToShowNextCell);\r\n    }\r\n  }\r\n\r\n  protected handleDragToNewPosition(xNeedUpdate: boolean, yNeedUpdate: boolean) {\r\n    let pageX = this._draggingMouseOffset.e.pageX;\r\n    let pageY = this._draggingMouseOffset.e.pageY;\r\n    const mouseOffsetX = this._draggingMouseOffset.offset.x;\r\n    const mouseOffsetY = this._draggingMouseOffset.offset.y;\r\n    const viewportOffset = this._draggingMouseOffset.viewport.offset;\r\n    // ... horizontal\r\n    if (xNeedUpdate && mouseOffsetX) {\r\n      if (mouseOffsetX > 0) {\r\n        pageX = viewportOffset.right + this._moveDistanceForOneCell.x;\r\n      } else {\r\n        pageX = viewportOffset.left - this._moveDistanceForOneCell.x;\r\n      }\r\n    }\r\n    // ... vertical\r\n    if (yNeedUpdate && mouseOffsetY) {\r\n      if (mouseOffsetY > 0) {\r\n        pageY = viewportOffset.top - this._moveDistanceForOneCell.y;\r\n      } else {\r\n        pageY = viewportOffset.bottom + this._moveDistanceForOneCell.y;\r\n      }\r\n    }\r\n    this.handleDragTo({ pageX, pageY }, this._draggingMouseOffset.dd);\r\n  }\r\n\r\n  protected stopIntervalTimer() {\r\n    if (this._autoScrollTimerId) {\r\n      window.clearInterval(this._autoScrollTimerId);\r\n      this._autoScrollTimerId = undefined;\r\n    }\r\n  }\r\n\r\n  protected handleDragTo(e: { pageX: number; pageY: number; }, dd: DragPosition) {\r\n    const targetEvent: MouseEvent | Touch = (e as unknown as TouchEvent)?.touches?.[0] ?? e;\r\n    const canvasOffset = Utils.offset(this._activeCanvas);\r\n    const end = this._grid.getCellFromPoint(\r\n      targetEvent.pageX - (canvasOffset?.left ?? 0) + this._columnOffset,\r\n      targetEvent.pageY - (canvasOffset?.top ?? 0) + this._rowOffset\r\n    );\r\n\r\n    // ... frozen column(s),\r\n    if (this._gridOptions.frozenColumn! >= 0 && (!this._isRightCanvas && (end.cell > this._gridOptions.frozenColumn!)) || (this._isRightCanvas && (end.cell <= this._gridOptions.frozenColumn!))) {\r\n      return;\r\n    }\r\n\r\n    // ... or frozen row(s)\r\n    if (this._gridOptions.frozenRow! >= 0 && (!this._isBottomCanvas && (end.row >= this._gridOptions.frozenRow!)) || (this._isBottomCanvas && (end.row < this._gridOptions.frozenRow!))) {\r\n      return;\r\n    }\r\n\r\n    // scrolling the viewport to display the target `end` cell if it is not fully displayed\r\n    if (this._options.autoScroll && this._draggingMouseOffset) {\r\n      const endCellBox = this._grid.getCellNodeBox(end.row, end.cell);\r\n      if (!endCellBox) {\r\n        return;\r\n      }\r\n      const viewport = this._draggingMouseOffset.viewport;\r\n      if (endCellBox.left < viewport.left || endCellBox.right > viewport.right\r\n        || endCellBox.top < viewport.top || endCellBox.bottom > viewport.bottom) {\r\n        this._grid.scrollCellIntoView(end.row, end.cell);\r\n      }\r\n    }\r\n\r\n    // ... or regular grid (without any frozen options)\r\n    if (!this._grid.canCellBeSelected(end.row, end.cell)) {\r\n      return;\r\n    }\r\n\r\n    if (dd?.range) {\r\n      dd.range.end = end;\r\n\r\n      const range = new SlickRange(dd.range.start.row ?? 0, dd.range.start.cell ?? 0, end.row, end.cell);\r\n      this._decorator.show(range);\r\n      this.onCellRangeSelecting.notify({\r\n        range\r\n      });\r\n    }\r\n  }\r\n\r\n  protected hasRowMoveManager() {\r\n    return !!(this._grid.getPluginByName('RowMoveManager') || this._grid.getPluginByName('CrossGridRowMoveManager'));\r\n  }\r\n\r\n  protected handleDragEnd(e: SlickEventData, dd: DragPosition) {\r\n    this._decorator.hide();\r\n    if (!this._dragging) {\r\n      return;\r\n    }\r\n\r\n    this._dragging = false;\r\n    e.stopImmediatePropagation();\r\n\r\n    this.stopIntervalTimer();\r\n    this.onCellRangeSelected.notify({\r\n      range: new SlickRange(\r\n        dd.range.start.row ?? 0,\r\n        dd.range.start.cell ?? 0,\r\n        dd.range.end.row,\r\n        dd.range.end.cell\r\n      )\r\n    });\r\n  }\r\n\r\n  getCurrentRange() {\r\n    return this._currentlySelectedRange;\r\n  }\r\n}\r\n\r\n// extend Slick namespace on window object when building as iife\r\nif (IIFE_ONLY && window.Slick) {\r\n  Utils.extend(Slick, {\r\n    CellRangeSelector: SlickCellRangeSelector\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
