{
  "version": 3,
  "sources": ["../../../src/plugins/slick.cellrangeselector.ts"],
  "sourcesContent": ["import { SlickEvent as SlickEvent_, SlickEventData, SlickEventHandler as SlickEventHandler_, SlickRange as SlickRange_, Utils as Utils_ } from '../slick.core';\nimport { Draggable as Draggable_ } from '../slick.interactions';\nimport { SlickCellRangeDecorator as SlickCellRangeDecorator_ } from './slick.cellrangedecorator';\nimport type { CellRangeSelectorOption, DOMMouseOrTouchEvent, DragPosition, DragRange, GridOption, MouseOffsetViewport, OnScrollEventArgs, SlickPlugin } from '../models/index';\nimport type { SlickGrid } from '../slick.grid';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst SlickEventHandler = IIFE_ONLY ? Slick.EventHandler : SlickEventHandler_;\nconst SlickRange = IIFE_ONLY ? Slick.Range : SlickRange_;\nconst Draggable = IIFE_ONLY ? Slick.Draggable : Draggable_;\nconst SlickCellRangeDecorator = IIFE_ONLY ? Slick.CellRangeDecorator : SlickCellRangeDecorator_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\nexport class SlickCellRangeSelector implements SlickPlugin {\n  // --\n  // public API\n  pluginName = 'CellRangeSelector' as const;\n  onBeforeCellRangeSelected = new SlickEvent<{ row: number; cell: number; }>();\n  onCellRangeSelected = new SlickEvent<{ range: SlickRange_; }>();\n  onCellRangeSelecting = new SlickEvent<{ range: SlickRange_; }>();\n\n  // --\n  // protected props\n  protected _grid!: SlickGrid;\n  protected _currentlySelectedRange: DragRange | null = null;\n  protected _canvas: HTMLElement | null = null;\n  protected _decorator!: SlickCellRangeDecorator_;\n  protected _gridOptions!: GridOption;\n  protected _activeCanvas!: HTMLElement;\n  protected _dragging = false;\n  protected _handler = new SlickEventHandler();\n  protected _options: CellRangeSelectorOption;\n  protected _defaults = {\n    autoScroll: true,\n    minIntervalToShowNextCell: 30,\n    maxIntervalToShowNextCell: 600, // better to a multiple of minIntervalToShowNextCell\n    accelerateInterval: 5,          // increase 5ms when cursor 1px outside the viewport.\n    selectionCss: {\n      border: '2px dashed blue'\n    }\n  } as CellRangeSelectorOption;\n\n  // Frozen row & column variables\n  protected _rowOffset = 0;\n  protected _columnOffset = 0;\n  protected _isRightCanvas = false;\n  protected _isBottomCanvas = false;\n\n  // autoScroll related constiables\n  protected _activeViewport!: HTMLElement;\n  protected _autoScrollTimerId?: NodeJS.Timeout;\n  protected _draggingMouseOffset!: MouseOffsetViewport;\n  protected _moveDistanceForOneCell!: { x: number; y: number; };\n  protected _xDelayForNextCell = 0;\n  protected _yDelayForNextCell = 0;\n  protected _viewportHeight = 0;\n  protected _viewportWidth = 0;\n  protected _isRowMoveRegistered = false;\n\n  // Scrollings\n  protected _scrollLeft = 0;\n  protected _scrollTop = 0;\n\n  constructor(options?: Partial<CellRangeSelectorOption>) {\n    this._options = Utils.extend(true, {}, this._defaults, options);\n  }\n\n  init(grid: SlickGrid) {\n    if (Draggable === undefined) {\n      throw new Error('Slick.Draggable is undefined, make sure to import \"slick.interactions.js\"');\n    }\n\n    this._decorator = this._options.cellDecorator || new SlickCellRangeDecorator(grid, this._options);\n    this._grid = grid;\n    this._canvas = this._grid.getCanvasNode();\n    this._gridOptions = this._grid.getOptions();\n    this._handler\n      .subscribe(this._grid.onScroll, this.handleScroll.bind(this))\n      .subscribe(this._grid.onDragInit, this.handleDragInit.bind(this))\n      .subscribe(this._grid.onDragStart, this.handleDragStart.bind(this))\n      .subscribe(this._grid.onDrag, this.handleDrag.bind(this))\n      .subscribe(this._grid.onDragEnd, this.handleDragEnd.bind(this));\n  }\n\n  destroy() {\n    this._handler.unsubscribeAll();\n    this._activeCanvas = null as any;\n    this._activeViewport = null as any;\n    this._canvas = null;\n    this._decorator?.destroy();\n  }\n\n  getCellDecorator() {\n    return this._decorator;\n  }\n\n  protected handleScroll(_e: DOMMouseOrTouchEvent<HTMLDivElement>, args: OnScrollEventArgs) {\n    this._scrollTop = args.scrollTop;\n    this._scrollLeft = args.scrollLeft;\n  }\n\n  protected handleDragInit(e: Event) {\n    // Set the active canvas node because the decorator needs to append its\n    // box to the correct canvas\n    this._activeCanvas = this._grid.getActiveCanvasNode(e);\n    this._activeViewport = this._grid.getActiveViewportNode(e);\n\n    const scrollbarDimensions = this._grid.getDisplayedScrollbarDimensions();\n    this._viewportWidth = this._activeViewport.offsetWidth - scrollbarDimensions.width;\n    this._viewportHeight = this._activeViewport.offsetHeight - scrollbarDimensions.height;\n\n    this._moveDistanceForOneCell = {\n      x: this._grid.getAbsoluteColumnMinWidth() / 2,\n      y: this._grid.getOptions().rowHeight! / 2\n    };\n    this._isRowMoveRegistered = this.hasRowMoveManager();\n\n    this._rowOffset = 0;\n    this._columnOffset = 0;\n    this._isBottomCanvas = this._activeCanvas.classList.contains('grid-canvas-bottom');\n\n    if (this._gridOptions.frozenRow! > -1 && this._isBottomCanvas) {\n      const canvasSelector = `.${this._grid.getUID()} .grid-canvas-${this._gridOptions.frozenBottom ? 'bottom' : 'top'}`;\n      const canvasElm = document.querySelector(canvasSelector);\n      if (canvasElm) {\n        this._rowOffset = canvasElm.clientHeight || 0;\n      }\n    }\n\n    this._isRightCanvas = this._activeCanvas.classList.contains('grid-canvas-right');\n\n    if (this._gridOptions.frozenColumn! > -1 && this._isRightCanvas) {\n      const canvasLeftElm = document.querySelector(`.${this._grid.getUID()} .grid-canvas-left`);\n      if (canvasLeftElm) {\n        this._columnOffset = canvasLeftElm.clientWidth || 0;\n      }\n    }\n\n    // prevent the grid from cancelling drag'n'drop by default\n    e.stopImmediatePropagation();\n    e.preventDefault();\n  }\n\n  protected handleDragStart(e: DOMMouseOrTouchEvent<HTMLDivElement>, dd: DragPosition) {\n    const cell = this._grid.getCellFromEvent(e);\n    if (cell && this.onBeforeCellRangeSelected.notify(cell).getReturnValue() !== false && this._grid.canCellBeSelected(cell.row, cell.cell)) {\n      this._dragging = true;\n      e.stopImmediatePropagation();\n    }\n    if (!this._dragging) {\n      return;\n    }\n\n    this._grid.focus();\n\n    const canvasOffset = Utils.offset(this._canvas);\n\n    let startX = dd.startX - (canvasOffset?.left ?? 0);\n    if (this._gridOptions.frozenColumn! >= 0 && this._isRightCanvas) {\n      startX += this._scrollLeft;\n    }\n\n    let startY = dd.startY - (canvasOffset?.top ?? 0);\n    if (this._gridOptions.frozenRow! >= 0 && this._isBottomCanvas) {\n      startY += this._scrollTop;\n    }\n\n    const start = this._grid.getCellFromPoint(startX, startY);\n\n    dd.range = { start, end: {} };\n    this._currentlySelectedRange = dd.range;\n    return this._decorator.show(new SlickRange(start.row, start.cell));\n  }\n\n  protected handleDrag(evt: SlickEventData, dd: DragPosition) {\n    if (!this._dragging && !this._isRowMoveRegistered) {\n      return;\n    }\n    if (!this._isRowMoveRegistered) {\n      evt.stopImmediatePropagation();\n    }\n\n    const e = evt.getNativeEvent<MouseEvent>();\n    if (this._options.autoScroll) {\n      this._draggingMouseOffset = this.getMouseOffsetViewport(e, dd);\n      if (this._draggingMouseOffset.isOutsideViewport) {\n        return this.handleDragOutsideViewport();\n      }\n    }\n    this.stopIntervalTimer();\n    this.handleDragTo(e, dd);\n  }\n\n  protected getMouseOffsetViewport(e: MouseEvent | TouchEvent, dd: DragPosition): MouseOffsetViewport {\n    const targetEvent: MouseEvent | Touch = (e as TouchEvent)?.touches?.[0] ?? e;\n    const viewportLeft = this._activeViewport.scrollLeft;\n    const viewportTop = this._activeViewport.scrollTop;\n    const viewportRight = viewportLeft + this._viewportWidth;\n    const viewportBottom = viewportTop + this._viewportHeight;\n\n    const viewportOffset = Utils.offset(this._activeViewport);\n    const viewportOffsetLeft = viewportOffset?.left ?? 0;\n    const viewportOffsetTop = viewportOffset?.top ?? 0;\n    const viewportOffsetRight = viewportOffsetLeft + this._viewportWidth;\n    const viewportOffsetBottom = viewportOffsetTop + this._viewportHeight;\n\n    const result = {\n      e,\n      dd,\n      viewport: {\n        left: viewportLeft,\n        top: viewportTop,\n        right: viewportRight,\n        bottom: viewportBottom,\n        offset: {\n          left: viewportOffsetLeft,\n          top: viewportOffsetTop,\n          right: viewportOffsetRight,\n          bottom: viewportOffsetBottom\n        }\n      },\n      // Consider the viewport as the origin, the `offset` is based on the coordinate system:\n      // the cursor is on the viewport's left/bottom when it is less than 0, and on the right/top when greater than 0.\n      offset: {\n        x: 0,\n        y: 0\n      },\n      isOutsideViewport: false\n    };\n    // ... horizontal\n    if (targetEvent.pageX < viewportOffsetLeft) {\n      result.offset.x = targetEvent.pageX - viewportOffsetLeft;\n    } else if (targetEvent.pageX > viewportOffsetRight) {\n      result.offset.x = targetEvent.pageX - viewportOffsetRight;\n    }\n    // ... vertical\n    if (targetEvent.pageY < viewportOffsetTop) {\n      result.offset.y = viewportOffsetTop - targetEvent.pageY;\n    } else if (targetEvent.pageY > viewportOffsetBottom) {\n      result.offset.y = viewportOffsetBottom - targetEvent.pageY;\n    }\n    result.isOutsideViewport = !!result.offset.x || !!result.offset.y;\n    return result;\n  }\n\n  protected handleDragOutsideViewport() {\n    this._xDelayForNextCell = this._options.maxIntervalToShowNextCell - Math.abs(this._draggingMouseOffset.offset.x) * this._options.accelerateInterval;\n    this._yDelayForNextCell = this._options.maxIntervalToShowNextCell - Math.abs(this._draggingMouseOffset.offset.y) * this._options.accelerateInterval;\n    // only one timer is created to handle the case that cursor outside the viewport\n    if (!this._autoScrollTimerId) {\n      let xTotalDelay = 0;\n      let yTotalDelay = 0;\n      this._autoScrollTimerId = setInterval(() => {\n        let xNeedUpdate = false;\n        let yNeedUpdate = false;\n        // ... horizontal\n        if (this._draggingMouseOffset.offset.x) {\n          xTotalDelay += this._options.minIntervalToShowNextCell;\n          xNeedUpdate = xTotalDelay >= this._xDelayForNextCell;\n        } else {\n          xTotalDelay = 0;\n        }\n        // ... vertical\n        if (this._draggingMouseOffset.offset.y) {\n          yTotalDelay += this._options.minIntervalToShowNextCell;\n          yNeedUpdate = yTotalDelay >= this._yDelayForNextCell;\n        } else {\n          yTotalDelay = 0;\n        }\n        if (xNeedUpdate || yNeedUpdate) {\n          if (xNeedUpdate) {\n            xTotalDelay = 0;\n          }\n          if (yNeedUpdate) {\n            yTotalDelay = 0;\n          }\n          this.handleDragToNewPosition(xNeedUpdate, yNeedUpdate);\n        }\n      }, this._options.minIntervalToShowNextCell);\n    }\n  }\n\n  protected handleDragToNewPosition(xNeedUpdate: boolean, yNeedUpdate: boolean) {\n    let pageX = this._draggingMouseOffset.e.pageX;\n    let pageY = this._draggingMouseOffset.e.pageY;\n    const mouseOffsetX = this._draggingMouseOffset.offset.x;\n    const mouseOffsetY = this._draggingMouseOffset.offset.y;\n    const viewportOffset = this._draggingMouseOffset.viewport.offset;\n    // ... horizontal\n    if (xNeedUpdate && mouseOffsetX) {\n      if (mouseOffsetX > 0) {\n        pageX = viewportOffset.right + this._moveDistanceForOneCell.x;\n      } else {\n        pageX = viewportOffset.left - this._moveDistanceForOneCell.x;\n      }\n    }\n    // ... vertical\n    if (yNeedUpdate && mouseOffsetY) {\n      if (mouseOffsetY > 0) {\n        pageY = viewportOffset.top - this._moveDistanceForOneCell.y;\n      } else {\n        pageY = viewportOffset.bottom + this._moveDistanceForOneCell.y;\n      }\n    }\n    this.handleDragTo({ pageX, pageY }, this._draggingMouseOffset.dd);\n  }\n\n  protected stopIntervalTimer() {\n    if (this._autoScrollTimerId) {\n      clearInterval(this._autoScrollTimerId);\n      this._autoScrollTimerId = undefined;\n    }\n  }\n\n  protected handleDragTo(e: { pageX: number; pageY: number; }, dd: DragPosition) {\n    const targetEvent: MouseEvent | Touch = (e as unknown as TouchEvent)?.touches?.[0] ?? e;\n    const canvasOffset = Utils.offset(this._activeCanvas);\n    const end = this._grid.getCellFromPoint(\n      targetEvent.pageX - (canvasOffset?.left ?? 0) + this._columnOffset,\n      targetEvent.pageY - (canvasOffset?.top ?? 0) + this._rowOffset\n    );\n\n    // ... frozen column(s),\n    if (this._gridOptions.frozenColumn! >= 0 && (!this._isRightCanvas && (end.cell > this._gridOptions.frozenColumn!)) || (this._isRightCanvas && (end.cell <= this._gridOptions.frozenColumn!))) {\n      return;\n    }\n\n    // ... or frozen row(s)\n    if (this._gridOptions.frozenRow! >= 0 && (!this._isBottomCanvas && (end.row >= this._gridOptions.frozenRow!)) || (this._isBottomCanvas && (end.row < this._gridOptions.frozenRow!))) {\n      return;\n    }\n\n    // scrolling the viewport to display the target `end` cell if it is not fully displayed\n    if (this._options.autoScroll && this._draggingMouseOffset) {\n      const endCellBox = this._grid.getCellNodeBox(end.row, end.cell);\n      if (!endCellBox) {\n        return;\n      }\n      const viewport = this._draggingMouseOffset.viewport;\n      if (endCellBox.left < viewport.left || endCellBox.right > viewport.right\n        || endCellBox.top < viewport.top || endCellBox.bottom > viewport.bottom) {\n        this._grid.scrollCellIntoView(end.row, end.cell);\n      }\n    }\n\n    // ... or regular grid (without any frozen options)\n    if (!this._grid.canCellBeSelected(end.row, end.cell)) {\n      return;\n    }\n\n    if (dd?.range) {\n      dd.range.end = end;\n\n      const range = new SlickRange(dd.range.start.row ?? 0, dd.range.start.cell ?? 0, end.row, end.cell);\n      this._decorator.show(range);\n      this.onCellRangeSelecting.notify({\n        range\n      });\n    }\n  }\n\n  protected hasRowMoveManager() {\n    return !!(this._grid.getPluginByName('RowMoveManager') || this._grid.getPluginByName('CrossGridRowMoveManager'));\n  }\n\n  protected handleDragEnd(e: Event, dd: DragPosition) {\n    this._decorator.hide();\n    if (!this._dragging) {\n      return;\n    }\n\n    this._dragging = false;\n    e.stopImmediatePropagation();\n\n    this.stopIntervalTimer();\n    this.onCellRangeSelected.notify({\n      range: new SlickRange(\n        dd.range.start.row ?? 0,\n        dd.range.start.cell ?? 0,\n        dd.range.end.row,\n        dd.range.end.cell\n      )\n    });\n  }\n\n  getCurrentRange() {\n    return this._currentlySelectedRange;\n  }\n}\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(Slick, {\n    CellRangeSelector: SlickCellRangeSelector\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
