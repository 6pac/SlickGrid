{
  "version": 3,
  "sources": ["../../../src/plugins/slick.cellexternalcopymanager.ts"],
  "sourcesContent": ["import type { Column, CssStyleHash, ExcelCopyBufferOption, ExternalCopyClipCommand, SlickPlugin } from '../models/index.js';\r\nimport type { SlickGrid } from '../slick.grid.js';\r\nimport { SlickEvent as SlickEvent_, type SlickEventData, SlickRange as SlickRange_, Utils as Utils_ } from '../slick.core.js';\r\n\r\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\r\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\r\nconst SlickRange = IIFE_ONLY ? Slick.Range : SlickRange_;\r\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\r\n\r\nconst CLEAR_COPY_SELECTION_DELAY = 2000;\r\nconst CLIPBOARD_PASTE_DELAY = 100;\r\n\r\n/***\r\n  This manager enables users to copy/paste data from/to an external Spreadsheet application\r\n  such as MS-Excel\u00AE or OpenOffice-Spreadsheet.\r\n\r\n  Since it is not possible to access directly the clipboard in javascript, the plugin uses\r\n  a trick to do it's job. After detecting the keystroke, we dynamically create a textarea\r\n  where the browser copies/pastes the serialized data.\r\n\r\n  options:\r\n    copiedCellStyle : sets the css className used for copied cells. default : \"copied\"\r\n    copiedCellStyleLayerKey : sets the layer key for setting css values of copied cells. default : \"copy-manager\"\r\n    dataItemColumnValueExtractor : option to specify a custom column value extractor function\r\n    dataItemColumnValueSetter : option to specify a custom column value setter function\r\n    clipboardCommandHandler : option to specify a custom handler for paste actions\r\n    includeHeaderWhenCopying : set to true and the plugin will take the name property from each column (which is usually what appears in your header) and put that as the first row of the text that's copied to the clipboard\r\n    bodyElement: option to specify a custom DOM element which to will be added the hidden textbox. It's useful if the grid is inside a modal dialog.\r\n    onCopyInit: optional handler to run when copy action initializes\r\n    onCopySuccess: optional handler to run when copy action is complete\r\n    newRowCreator: function to add rows to table if paste overflows bottom of table, if this function is not provided new rows will be ignored.\r\n    readOnlyMode: suppresses paste\r\n    headerColumnValueExtractor : option to specify a custom column header value extractor function\r\n*/\r\nexport class SlickCellExternalCopyManager implements SlickPlugin {\r\n  // --\r\n  // public API\r\n  pluginName = 'CellExternalCopyManager' as const;\r\n  onCopyCells = new SlickEvent<{ ranges: SlickRange_[]; }>('onCopyCells');\r\n  onCopyCancelled = new SlickEvent<{ ranges: SlickRange_[]; }>('onCopyCancelled');\r\n  onPasteCells = new SlickEvent<{ ranges: SlickRange_[]; }>('onPasteCells');\r\n\r\n  // --\r\n  // protected props\r\n  protected _grid!: SlickGrid;\r\n  protected _bodyElement: HTMLElement;\r\n  protected _copiedRanges: SlickRange_[] | null = null;\r\n  protected _clearCopyTI?: number;\r\n  protected _copiedCellStyle: string;\r\n  protected _copiedCellStyleLayerKey: string;\r\n  protected _onCopyInit?: () => void;\r\n  protected _onCopySuccess?: (rowCount: number) => void;\r\n  protected _options: ExcelCopyBufferOption;\r\n\r\n  protected keyCodes = {\r\n    'C': 67,\r\n    'V': 86,\r\n    'ESC': 27,\r\n    'INSERT': 45\r\n  };\r\n\r\n  constructor(options: ExcelCopyBufferOption) {\r\n    this._options = options || {};\r\n    this._copiedCellStyleLayerKey = this._options.copiedCellStyleLayerKey || 'copy-manager';\r\n    this._copiedCellStyle = this._options.copiedCellStyle || 'copied';\r\n    this._bodyElement = this._options.bodyElement || document.body;\r\n    this._onCopyInit = this._options.onCopyInit || undefined;\r\n    this._onCopySuccess = this._options.onCopySuccess || undefined;\r\n  }\r\n\r\n  init(grid: SlickGrid) {\r\n    this._grid = grid;\r\n    Utils.addSlickEventPubSubWhenDefined(grid.getPubSubService(), this);\r\n    this._grid.onKeyDown.subscribe(this.handleKeyDown.bind(this));\r\n\r\n    // we need a cell selection model\r\n    const cellSelectionModel = grid.getSelectionModel();\r\n    if (!cellSelectionModel) {\r\n      throw new Error('Selection model is mandatory for this plugin. Please set a selection model on the grid before adding this plugin: grid.setSelectionModel(new Slick.CellSelectionModel())');\r\n    }\r\n    // we give focus on the grid when a selection is done on it.\r\n    // without this, if the user selects a range of cell without giving focus on a particular cell, the grid doesn't get the focus and key stroke handles (ctrl+c) don't work\r\n    cellSelectionModel.onSelectedRangesChanged.subscribe(() => {\r\n      if (!this._grid.getEditorLock().isActive()) {\r\n        this._grid.focus();\r\n      }\r\n    });\r\n  }\r\n\r\n  destroy() {\r\n    this._grid.onKeyDown.unsubscribe(this.handleKeyDown.bind(this));\r\n  }\r\n\r\n  protected getHeaderValueForColumn(columnDef: Column): string {\r\n    if (this._options.headerColumnValueExtractor) {\r\n      const val = Utils.getHtmlStringOutput(this._options.headerColumnValueExtractor(columnDef));\r\n      if (val) {\r\n        return val;\r\n      }\r\n    }\r\n\r\n    return Utils.getHtmlStringOutput(columnDef.name || '');\r\n  }\r\n\r\n  protected getDataItemValueForColumn(item: any, columnDef: Column, event: SlickEventData): string {\r\n    if (typeof this._options.dataItemColumnValueExtractor === 'function') {\r\n      const val = this._options.dataItemColumnValueExtractor(item, columnDef) as string | null;\r\n      if (val) {\r\n        return val;\r\n      }\r\n    }\r\n\r\n    let retVal = '';\r\n\r\n    // if a custom getter is not defined, we call serializeValue of the editor to serialize\r\n    if (columnDef?.editor) {\r\n      const tmpP = document.createElement('p');\r\n      const editor = new (columnDef.editor as any)({\r\n        container: tmpP,  // a dummy container\r\n        column: columnDef,\r\n        event,\r\n        position: { top: 0, left: 0 },  // a dummy position required by some editors\r\n        grid: this._grid,\r\n      });\r\n      editor.loadValue(item);\r\n      retVal = editor.serializeValue();\r\n      editor.destroy();\r\n      tmpP.remove();\r\n    } else {\r\n      retVal = item[columnDef.field || ''];\r\n    }\r\n\r\n    return retVal;\r\n  }\r\n\r\n  protected setDataItemValueForColumn(item: any, columnDef: Column, value: string): null | string | void {\r\n    if (columnDef.denyPaste) {\r\n      return null;\r\n    }\r\n\r\n    if (this._options.dataItemColumnValueSetter) {\r\n      return this._options.dataItemColumnValueSetter(item, columnDef, value) as string;\r\n    }\r\n\r\n    // if a custom setter is not defined, we call applyValue of the editor to unserialize\r\n    if (columnDef.editor) {\r\n      const tmpDiv = document.createElement('div');\r\n      const editor = new (columnDef.editor as any)({\r\n        container: tmpDiv, // a dummy container\r\n        column: columnDef,\r\n        position: { top: 0, left: 0 },  // a dummy position required by some editors\r\n        grid: this._grid\r\n      });\r\n      editor.loadValue(item);\r\n      editor.applyValue(item, value);\r\n      editor.destroy();\r\n      tmpDiv.remove();\r\n    } else {\r\n      item[columnDef.field] = value;\r\n    }\r\n  }\r\n\r\n\r\n  protected _createTextBox(innerText: string) {\r\n    const scrollPos = document.documentElement.scrollTop || document.body.scrollTop;\r\n    const ta = document.createElement('textarea');\r\n    ta.style.position = 'absolute';\r\n    ta.style.opacity = '0';\r\n    ta.value = innerText;\r\n    ta.style.top = `${scrollPos}px`;\r\n    this._bodyElement.appendChild(ta);\r\n    ta.select();\r\n\r\n    return ta;\r\n  }\r\n\r\n  protected _decodeTabularData(grid: SlickGrid, ta: HTMLTextAreaElement) {\r\n    const columns = grid.getColumns();\r\n    const clipText = ta.value;\r\n    const clipRows = clipText.split(/[\\n\\f\\r]/);\r\n    // trim trailing CR if present\r\n    if (clipRows[clipRows.length - 1] === '') {\r\n      clipRows.pop();\r\n    }\r\n\r\n    let j = 0;\r\n    const clippedRange: any[] = [];\r\n\r\n    this._bodyElement.removeChild(ta);\r\n    for (let i = 0; i < clipRows.length; i++) {\r\n      if (clipRows[i] !== '') {\r\n        clippedRange[j++] = clipRows[i].split('\\t');\r\n      } else {\r\n        clippedRange[j++] = [''];\r\n      }\r\n    }\r\n    const selectedCell = grid.getActiveCell();\r\n    const ranges = grid.getSelectionModel()?.getSelectedRanges();\r\n    const selectedRange = ranges && ranges.length ? ranges[0] : null;   // pick only one selection\r\n    let activeRow: number;\r\n    let activeCell: number;\r\n\r\n    if (selectedRange) {\r\n      activeRow = selectedRange.fromRow;\r\n      activeCell = selectedRange.fromCell;\r\n    } else if (selectedCell) {\r\n      activeRow = selectedCell.row;\r\n      activeCell = selectedCell.cell;\r\n    } else {\r\n      // we don't know where to paste\r\n      return;\r\n    }\r\n\r\n    let oneCellToMultiple = false;\r\n    let destH = clippedRange.length;\r\n    let destW = clippedRange.length ? clippedRange[0].length : 0;\r\n    if (clippedRange.length === 1 && clippedRange[0].length === 1 && selectedRange) {\r\n      oneCellToMultiple = true;\r\n      destH = selectedRange.toRow - selectedRange.fromRow + 1;\r\n      destW = selectedRange.toCell - selectedRange.fromCell + 1;\r\n    }\r\n    const availableRows = (grid.getData() as any[]).length - (activeRow || 0);\r\n    let addRows = 0;\r\n\r\n    // ignore new rows if we don't have a \"newRowCreator\"\r\n    if (availableRows < destH && typeof this._options.newRowCreator === 'function') {\r\n      const d = grid.getData<any[]>();\r\n      for (addRows = 1; addRows <= destH - availableRows; addRows++) {\r\n        d.push({});\r\n      }\r\n      grid.setData(d);\r\n      grid.render();\r\n    }\r\n\r\n    const overflowsBottomOfGrid = (activeRow || 0) + destH > grid.getDataLength();\r\n    if (this._options.newRowCreator && overflowsBottomOfGrid) {\r\n      const newRowsNeeded = (activeRow || 0) + destH - grid.getDataLength();\r\n      this._options.newRowCreator(newRowsNeeded);\r\n    }\r\n\r\n    const clipCommand: ExternalCopyClipCommand = {\r\n      isClipboardCommand: true,\r\n      clippedRange,\r\n      oldValues: [],\r\n      cellExternalCopyManager: this,\r\n      _options: this._options,\r\n      setDataItemValueForColumn: this.setDataItemValueForColumn.bind(this),\r\n      markCopySelection: this.markCopySelection.bind(this),\r\n      oneCellToMultiple,\r\n      activeRow,\r\n      activeCell,\r\n      destH,\r\n      destW,\r\n      maxDestY: grid.getDataLength(),\r\n      maxDestX: grid.getColumns().length,\r\n      h: 0,\r\n      w: 0,\r\n      execute: () => {\r\n        clipCommand.h = 0;\r\n        for (let y = 0; y < clipCommand.destH; y++) {\r\n          clipCommand.oldValues[y] = [];\r\n          clipCommand.w = 0;\r\n          clipCommand.h++;\r\n          let xOffset = 0; // the x offset for hidden col\r\n\r\n          for (let x = 0; x < clipCommand.destW; x++) {\r\n            const desty = activeRow + y;\r\n            const destx = activeCell + x;\r\n            const column = columns[destx];\r\n\r\n            // paste on hidden column will be skipped, but we need to paste 1 cell further on X axis\r\n            // we'll increase our X and increase the offset`\r\n            if (column.hidden) {\r\n              clipCommand.destW++;\r\n              xOffset++;\r\n              continue;\r\n            }\r\n            clipCommand.w++;\r\n\r\n            if (desty < clipCommand.maxDestY && destx < clipCommand.maxDestX) {\r\n              const dt = grid.getDataItem(desty);\r\n\r\n              clipCommand.oldValues[y][x - xOffset] = dt[column['field']];\r\n              if (oneCellToMultiple) {\r\n                clipCommand.setDataItemValueForColumn(dt, column, clippedRange[0][0]);\r\n              } else {\r\n                clipCommand.setDataItemValueForColumn(dt, column, clippedRange[y] ? clippedRange[y][x - xOffset] : '');\r\n              }\r\n              grid.updateCell(desty, destx);\r\n              grid.onCellChange.notify({\r\n                row: desty,\r\n                cell: destx,\r\n                item: dt,\r\n                grid,\r\n                column: {} as Column\r\n              });\r\n            }\r\n          }\r\n        }\r\n\r\n        const bRange = new SlickRange(\r\n          activeRow,\r\n          activeCell,\r\n          activeRow + clipCommand.h - 1,\r\n          activeCell + clipCommand.w - 1\r\n        );\r\n\r\n        this.markCopySelection([bRange]);\r\n        grid.getSelectionModel()?.setSelectedRanges([bRange]);\r\n        this.onPasteCells.notify({ ranges: [bRange] });\r\n      },\r\n      undo: () => {\r\n        for (let y = 0; y < clipCommand.destH; y++) {\r\n          for (let x = 0; x < clipCommand.destW; x++) {\r\n            const desty = activeRow + y;\r\n            const destx = activeCell + x;\r\n\r\n            if (desty < clipCommand.maxDestY && destx < clipCommand.maxDestX) {\r\n              const dt = grid.getDataItem(desty);\r\n              if (oneCellToMultiple) {\r\n                clipCommand.setDataItemValueForColumn(dt, columns[destx], clipCommand.oldValues[0][0]);\r\n              } else {\r\n                clipCommand.setDataItemValueForColumn(dt, columns[destx], clipCommand.oldValues[y][x]);\r\n              }\r\n              grid.updateCell(desty, destx);\r\n              grid.onCellChange.notify({\r\n                row: desty,\r\n                cell: destx,\r\n                item: dt,\r\n                grid,\r\n                column: {} as Column\r\n              });\r\n            }\r\n          }\r\n        }\r\n\r\n        const bRange = new SlickRange(\r\n          activeRow,\r\n          activeCell,\r\n          activeRow + clipCommand.h - 1,\r\n          activeCell + clipCommand.w - 1\r\n        );\r\n\r\n        this.markCopySelection([bRange]);\r\n        grid.getSelectionModel()?.setSelectedRanges([bRange]);\r\n        if (typeof this._options.onPasteCells === 'function') {\r\n          this.onPasteCells.notify({ ranges: [bRange] });\r\n        }\r\n\r\n        if (addRows > 1) {\r\n          const d = grid.getData<any[]>();\r\n          for (; addRows > 1; addRows--) {\r\n            d.splice(d.length - 1, 1);\r\n          }\r\n          grid.setData(d);\r\n          grid.render();\r\n        }\r\n      }\r\n    };\r\n\r\n    if (typeof this._options.clipboardCommandHandler === 'function') {\r\n      this._options.clipboardCommandHandler(clipCommand);\r\n    } else {\r\n      clipCommand.execute();\r\n    }\r\n  }\r\n\r\n  protected handleKeyDown(e: SlickEventData): boolean | void {\r\n    let ranges: SlickRange_[];\r\n    if (!this._grid.getEditorLock().isActive() || this._grid.getOptions().autoEdit) {\r\n      if (e.which === this.keyCodes.ESC) {\r\n        if (this._copiedRanges) {\r\n          e.preventDefault();\r\n          this.clearCopySelection();\r\n          this.onCopyCancelled.notify({ ranges: this._copiedRanges });\r\n          this._copiedRanges = null;\r\n        }\r\n      }\r\n\r\n      if ((e.which === this.keyCodes.C || e.which === this.keyCodes.INSERT) && (e.ctrlKey || e.metaKey) && !e.shiftKey) {    // CTRL+C or CTRL+INS\r\n        if (typeof this._onCopyInit === 'function') {\r\n          this._onCopyInit.call(this);\r\n        }\r\n        ranges = this._grid.getSelectionModel()?.getSelectedRanges() ?? [];\r\n        if (ranges.length !== 0) {\r\n          this._copiedRanges = ranges;\r\n          this.markCopySelection(ranges);\r\n          this.onCopyCells.notify({ ranges });\r\n\r\n          const columns = this._grid.getColumns();\r\n          let clipText = '';\r\n\r\n          for (let rg = 0; rg < ranges.length; rg++) {\r\n            const range = ranges[rg];\r\n            const clipTextRows: string[] = [];\r\n            for (let i = range.fromRow; i < range.toRow + 1; i++) {\r\n              const clipTextCells: string[] = [];\r\n              const dt = this._grid.getDataItem(i);\r\n\r\n              if (clipTextRows.length === 0 && this._options.includeHeaderWhenCopying) {\r\n                const clipTextHeaders: string[] = [];\r\n                for (let j = range.fromCell; j < range.toCell + 1; j++) {\r\n                  const colName: string = columns[j].name instanceof HTMLElement\r\n                    ? (columns[j].name as HTMLElement).innerHTML\r\n                    : columns[j].name as string;\r\n                  if (colName.length > 0 && !columns[j].hidden) {\r\n                    clipTextHeaders.push(this.getHeaderValueForColumn(columns[j]) || '');\r\n                  }\r\n                }\r\n                clipTextRows.push(clipTextHeaders.join('\\t'));\r\n              }\r\n\r\n              for (let j = range.fromCell; j < range.toCell + 1; j++) {\r\n                const colName: string = columns[j].name instanceof HTMLElement\r\n                  ? (columns[j].name as HTMLElement).innerHTML\r\n                  : columns[j].name as string;\r\n                if (colName.length > 0 && !columns[j].hidden) {\r\n                  clipTextCells.push(this.getDataItemValueForColumn(dt, columns[j], e));\r\n                }\r\n              }\r\n              clipTextRows.push(clipTextCells.join('\\t'));\r\n            }\r\n            clipText += clipTextRows.join('\\r\\n') + '\\r\\n';\r\n          }\r\n\r\n          if ((window as any).clipboardData) {\r\n            (window as any).clipboardData.setData('Text', clipText);\r\n            return true;\r\n          }\r\n          else {\r\n            const focusEl = document.activeElement as HTMLElement;\r\n            const ta = this._createTextBox(clipText);\r\n            ta.focus();\r\n\r\n            window.setTimeout(() => {\r\n              this._bodyElement.removeChild(ta);\r\n              // restore focus when possible\r\n              focusEl\r\n                ? focusEl.focus()\r\n                : console.log('No element to restore focus to after copy?');\r\n            }, this._options?.clipboardPasteDelay ?? CLIPBOARD_PASTE_DELAY);\r\n\r\n            if (typeof this._onCopySuccess === 'function') {\r\n              let rowCount = 0;\r\n              // If it's cell selection, use the toRow/fromRow fields\r\n              if (ranges.length === 1) {\r\n                rowCount = (ranges[0].toRow + 1) - ranges[0].fromRow;\r\n              } else {\r\n                rowCount = ranges.length;\r\n              }\r\n              this._onCopySuccess(rowCount);\r\n            }\r\n\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!this._options.readOnlyMode && (\r\n        (e.which === this.keyCodes.V && (e.ctrlKey || e.metaKey) && !e.shiftKey)\r\n        || (e.which === this.keyCodes.INSERT && e.shiftKey && !e.ctrlKey)\r\n      )) {    // CTRL+V or Shift+INS\r\n        const focusEl = document.activeElement as HTMLElement;\r\n        const ta = this._createTextBox('');\r\n        window.setTimeout(() => {\r\n          this._decodeTabularData(this._grid, ta);\r\n          // restore focus when possible\r\n          focusEl?.focus();\r\n        }, this._options?.clipboardPasteDelay ?? CLIPBOARD_PASTE_DELAY);\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  protected markCopySelection(ranges: SlickRange_[]) {\r\n    this.clearCopySelection();\r\n\r\n    const columns = this._grid.getColumns();\r\n    const hash: CssStyleHash = {};\r\n    for (let i = 0; i < ranges.length; i++) {\r\n      for (let j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\r\n        hash[j] = {};\r\n        for (let k = ranges[i].fromCell; k <= ranges[i].toCell && k < columns.length; k++) {\r\n          hash[j][columns[k].id] = this._copiedCellStyle;\r\n        }\r\n      }\r\n    }\r\n    this._grid.setCellCssStyles(this._copiedCellStyleLayerKey, hash);\r\n    window.clearTimeout(this._clearCopyTI);\r\n    this._clearCopyTI = window.setTimeout(() => {\r\n      this.clearCopySelection();\r\n    }, this._options?.clearCopySelectionDelay || CLEAR_COPY_SELECTION_DELAY);\r\n  }\r\n\r\n  clearCopySelection() {\r\n    this._grid.removeCellCssStyles(this._copiedCellStyleLayerKey);\r\n  }\r\n\r\n  setIncludeHeaderWhenCopying(includeHeaderWhenCopying: boolean) {\r\n    this._options.includeHeaderWhenCopying = includeHeaderWhenCopying;\r\n  }\r\n}\r\n\r\n// extend Slick namespace on window object when building as iife\r\nif (IIFE_ONLY && window.Slick) {\r\n  Utils.extend(true, window, {\r\n    Slick: {\r\n      CellExternalCopyManager: SlickCellExternalCopyManager\r\n    }\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": ["_a"]
}
