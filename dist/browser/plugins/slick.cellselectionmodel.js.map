{
  "version": 3,
  "sources": ["../../../src/plugins/slick.cellselectionmodel.ts"],
  "sourcesContent": ["import { SlickEvent as SlickEvent_, SlickEventData as SlickEventData_, SlickRange as SlickRange_, Utils as Utils_ } from '../slick.core';\nimport { SlickCellRangeSelector as SlickCellRangeSelector_ } from './slick.cellrangeselector';\nimport type { CellRange, OnActiveCellChangedEventArgs } from '../models/index';\nimport type { SlickGrid } from '../slick.grid';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst SlickEventData = IIFE_ONLY ? Slick.EventData : SlickEventData_;\nconst SlickRange = IIFE_ONLY ? Slick.Range : SlickRange_;\nconst SlickCellRangeSelector = IIFE_ONLY ? Slick.CellRangeSelector : SlickCellRangeSelector_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\nexport interface CellSelectionModelOption {\n  selectActiveCell: boolean;\n  cellRangeSelector?: SlickCellRangeSelector_;\n}\n\nexport class SlickCellSelectionModel {\n  // --\n  // public API\n  pluginName = 'CellSelectionModel' as const;\n  onSelectedRangesChanged = new SlickEvent<CellRange[]>();\n\n  // --\n  // protected props\n  protected _grid!: SlickGrid;\n  protected _ranges: CellRange[] = [];\n  protected _selector: SlickCellRangeSelector_;\n  protected _options?: CellSelectionModelOption;\n  protected _defaults: CellSelectionModelOption = {\n    selectActiveCell: true\n  };\n\n  constructor(options?: { selectActiveCell: boolean; cellRangeSelector: SlickCellRangeSelector_; }) {\n    if (options === undefined || options.cellRangeSelector === undefined) {\n      this._selector = new SlickCellRangeSelector({ selectionCss: { border: '2px solid black' } as CSSStyleDeclaration });\n    } else {\n      this._selector = options.cellRangeSelector;\n    }\n  }\n\n  init(grid: SlickGrid) {\n    this._options = Utils.extend(true, {}, this._defaults, this._options);\n    this._grid = grid;\n    this._grid.onActiveCellChanged.subscribe(this.handleActiveCellChange.bind(this));\n    this._grid.onKeyDown.subscribe(this.handleKeyDown.bind(this));\n    grid.registerPlugin(this._selector);\n    this._selector.onCellRangeSelected.subscribe(this.handleCellRangeSelected.bind(this));\n    this._selector.onBeforeCellRangeSelected.subscribe(this.handleBeforeCellRangeSelected.bind(this));\n  }\n\n  destroy() {\n    this._grid.onActiveCellChanged.unsubscribe(this.handleActiveCellChange.bind(this));\n    this._grid.onKeyDown.unsubscribe(this.handleKeyDown.bind(this));\n    this._selector.onCellRangeSelected.unsubscribe(this.handleCellRangeSelected.bind(this));\n    this._selector.onBeforeCellRangeSelected.unsubscribe(this.handleBeforeCellRangeSelected.bind(this));\n    this._grid.unregisterPlugin(this._selector);\n    this._selector?.destroy();\n  }\n\n  protected removeInvalidRanges(ranges: CellRange[]) {\n    const result: CellRange[] = [];\n\n    for (let i = 0; i < ranges.length; i++) {\n      const r = ranges[i];\n      if (this._grid.canCellBeSelected(r.fromRow, r.fromCell) && this._grid.canCellBeSelected(r.toRow, r.toCell)) {\n        result.push(r);\n      }\n    }\n\n    return result;\n  }\n\n  protected rangesAreEqual(range1: CellRange[], range2: CellRange[]) {\n    let areDifferent = (range1.length !== range2.length);\n    if (!areDifferent) {\n      for (let i = 0; i < range1.length; i++) {\n        if (\n          range1[i].fromCell !== range2[i].fromCell\n          || range1[i].fromRow !== range2[i].fromRow\n          || range1[i].toCell !== range2[i].toCell\n          || range1[i].toRow !== range2[i].toRow\n        ) {\n          areDifferent = true;\n          break;\n        }\n      }\n    }\n    return !areDifferent;\n  }\n\n  setSelectedRanges(ranges: CellRange[], caller = 'SlickCellSelectionModel.setSelectedRanges') {\n    // simple check for: empty selection didn't change, prevent firing onSelectedRangesChanged\n    if ((!this._ranges || this._ranges.length === 0) && (!ranges || ranges.length === 0)) { return; }\n\n    // if range has not changed, don't fire onSelectedRangesChanged\n    const rangeHasChanged = !this.rangesAreEqual(this._ranges, ranges);\n\n    this._ranges = this.removeInvalidRanges(ranges);\n    if (rangeHasChanged) {\n      // provide extra \"caller\" argument through SlickEventData to avoid breaking pubsub event that only accepts an array of selected range\n      const eventData = new SlickEventData(null, this._ranges);\n      Object.defineProperty(eventData, 'detail', { writable: true, configurable: true, value: { caller: caller || \"SlickCellSelectionModel.setSelectedRanges\" } });\n      this.onSelectedRangesChanged.notify(this._ranges, eventData);\n    }\n  }\n\n  getSelectedRanges() {\n    return this._ranges;\n  }\n\n  refreshSelections() {\n    this.setSelectedRanges(this.getSelectedRanges());\n  }\n\n  protected handleBeforeCellRangeSelected(e: Event): boolean | void {\n    if (this._grid.getEditorLock().isActive()) {\n      e.stopPropagation();\n      return false;\n    }\n  }\n\n  protected handleCellRangeSelected(_e: any, args: { range: CellRange; }) {\n    this._grid.setActiveCell(args.range.fromRow, args.range.fromCell, false, false, true);\n    this.setSelectedRanges([args.range]);\n  }\n\n  protected handleActiveCellChange(_e: Event, args: OnActiveCellChangedEventArgs) {\n    if (this._options?.selectActiveCell && args.row != null && args.cell != null) {\n      this.setSelectedRanges([new SlickRange(args.row, args.cell)]);\n    }\n    else if (!this._options?.selectActiveCell) {\n      // clear the previous selection once the cell changes\n      this.setSelectedRanges([]);\n    }\n  }\n\n  protected handleKeyDown(e: KeyboardEvent) {\n    /***\n     * \u041Aey codes\n     * 37 left\n     * 38 up\n     * 39 right\n     * 40 down\n     */\n    let ranges: CellRange[], last: SlickRange_;\n    const active = this._grid.getActiveCell();\n    const metaKey = e.ctrlKey || e.metaKey;\n\n    if (active && e.shiftKey && !metaKey && !e.altKey &&\n      (e.which == 37 || e.which == 39 || e.which == 38 || e.which == 40)) {\n\n      ranges = this.getSelectedRanges().slice();\n      if (!ranges.length)\n        ranges.push(new SlickRange(active.row, active.cell));\n\n      // keyboard can work with last range only\n      last = ranges.pop() as SlickRange_;\n\n      // can't handle selection out of active cell\n      if (!last.contains(active.row, active.cell))\n        last = new SlickRange(active.row, active.cell);\n\n      let dRow = last.toRow - last.fromRow,\n        dCell = last.toCell - last.fromCell;\n\n      // walking direction\n      const dirRow = active.row == last.fromRow ? 1 : -1;\n      const dirCell = active.cell == last.fromCell ? 1 : -1;\n\n      if (e.which == 37) {\n        dCell -= dirCell;\n      } else if (e.which == 39) {\n        dCell += dirCell;\n      } else if (e.which == 38) {\n        dRow -= dirRow;\n      } else if (e.which == 40) {\n        dRow += dirRow;\n      }\n\n      // define new selection range\n      const new_last = new SlickRange(active.row, active.cell, active.row + dirRow * dRow, active.cell + dirCell * dCell);\n      if (this.removeInvalidRanges([new_last]).length) {\n        ranges.push(new_last);\n        const viewRow = dirRow > 0 ? new_last.toRow : new_last.fromRow;\n        const viewCell = dirCell > 0 ? new_last.toCell : new_last.fromCell;\n        this._grid.scrollRowIntoView(viewRow);\n        this._grid.scrollCellIntoView(viewRow, viewCell);\n      }\n      else\n        ranges.push(last);\n\n      this.setSelectedRanges(ranges);\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n}\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(true, window, {\n    Slick: {\n      CellSelectionModel: SlickCellSelectionModel\n    }\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
