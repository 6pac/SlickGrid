{
  "version": 3,
  "sources": ["../../../src/plugins/slick.rowselectionmodel.ts"],
  "sourcesContent": ["import { keyCode as keyCode_, SlickEvent as SlickEvent_, SlickEventData as SlickEventData_, SlickEventHandler as SlickEventHandler_, SlickRange as SlickRange_, Utils as Utils_ } from '../slick.core';\nimport { Draggable as Draggable_ } from '../slick.interactions';\nimport { SlickCellRangeDecorator as SlickCellRangeDecorator_ } from './slick.cellrangedecorator';\nimport { SlickCellRangeSelector as SlickCellRangeSelector_ } from './slick.cellrangeselector';\nimport type { SlickCrossGridRowMoveManager as SlickCrossGridRowMoveManager_ } from './slick.crossgridrowmovemanager';\nimport type { SlickRowMoveManager as SlickRowMoveManager_ } from './slick.rowmovemanager';\nimport type { CellRange, OnActiveCellChangedEventArgs, RowSelectionModelOption } from '../models/index';\nimport type { SlickGrid } from '../slick.grid';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\nconst Draggable = IIFE_ONLY ? Slick.Draggable : Draggable_;\nconst keyCode = IIFE_ONLY ? Slick.keyCode : keyCode_;\nconst SlickCellRangeDecorator = IIFE_ONLY ? Slick.CellRangeDecorator : SlickCellRangeDecorator_;\nconst SlickCellRangeSelector = IIFE_ONLY ? Slick.CellRangeSelector : SlickCellRangeSelector_;\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst SlickEventData = IIFE_ONLY ? Slick.EventData : SlickEventData_;\nconst SlickEventHandler = IIFE_ONLY ? Slick.EventHandler : SlickEventHandler_;\nconst SlickRange = IIFE_ONLY ? Slick.Range : SlickRange_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\nexport class SlickRowSelectionModel {\n  // --\n  // public API\n  pluginName = 'RowSelectionModel' as const;\n  onSelectedRangesChanged = new SlickEvent<CellRange[]>();\n  // _handler, _inHandler, _isRowMoveManagerHandler, _options, wrapHandler\n  // --\n  // protected props\n  protected _grid!: SlickGrid;\n  protected _ranges: CellRange[] = [];\n  protected _eventHandler = new SlickEventHandler();\n  protected _inHandler = false;\n  protected _selector?: SlickCellRangeSelector_;\n  protected _isRowMoveManagerHandler: any;\n  protected _options: RowSelectionModelOption;\n  protected _defaults: RowSelectionModelOption = {\n    selectActiveRow: true,\n    dragToSelect: false,\n    autoScrollWhenDrag: true,\n    cellRangeSelector: undefined\n  };\n\n  constructor(options?: Partial<RowSelectionModelOption>) {\n    this._options = Utils.extend(true, {}, this._defaults, options);\n  }\n\n  init(grid: SlickGrid) {\n    if (Draggable === undefined) {\n      throw new Error('Slick.Draggable is undefined, make sure to import \"slick.interactions.js\"');\n    }\n\n    this._selector = this._options.cellRangeSelector;\n    this._grid = grid;\n\n    if (!this._selector && this._options.dragToSelect) {\n      if (!SlickCellRangeDecorator) {\n        throw new Error('Slick.CellRangeDecorator is required when option dragToSelect set to true');\n      }\n      this._selector = new SlickCellRangeSelector({\n        selectionCss: { border: 'none' } as CSSStyleDeclaration,\n        autoScroll: this._options.autoScrollWhenDrag\n      });\n    }\n\n    this._eventHandler.subscribe(this._grid.onActiveCellChanged, this.wrapHandler(this.handleActiveCellChange).bind(this));\n    this._eventHandler.subscribe(this._grid.onKeyDown, this.wrapHandler(this.handleKeyDown).bind(this));\n    this._eventHandler.subscribe(this._grid.onClick, this.wrapHandler(this.handleClick).bind(this));\n    if (this._selector) {\n      grid.registerPlugin(this._selector);\n      this._selector.onCellRangeSelecting.subscribe(this.handleCellRangeSelected.bind(this));\n      this._selector.onCellRangeSelected.subscribe(this.handleCellRangeSelected.bind(this));\n      this._selector.onBeforeCellRangeSelected.subscribe(this.handleBeforeCellRangeSelected.bind(this));\n    }\n  }\n\n  destroy() {\n    this._eventHandler.unsubscribeAll();\n    if (this._selector) {\n      this._selector.onCellRangeSelecting.unsubscribe(this.handleCellRangeSelected.bind(this));\n      this._selector.onCellRangeSelected.unsubscribe(this.handleCellRangeSelected.bind(this));\n      this._selector.onBeforeCellRangeSelected.unsubscribe(this.handleBeforeCellRangeSelected.bind(this));\n      this._grid.unregisterPlugin(this._selector);\n      if (this._selector.destroy) {\n        this._selector.destroy();\n      }\n    }\n  }\n\n  protected wrapHandler(handler: (...args: any) => void) {\n    return (...args: any) => {\n      if (!this._inHandler) {\n        this._inHandler = true;\n        handler.apply(this, args);\n        this._inHandler = false;\n      }\n    };\n  }\n\n  protected rangesToRows(ranges: CellRange[]): number[] {\n    const rows: number[] = [];\n    for (let i = 0; i < ranges.length; i++) {\n      for (let j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n        rows.push(j);\n      }\n    }\n    return rows;\n  }\n\n  protected rowsToRanges(rows: number[]) {\n    const ranges: SlickRange_[] = [];\n    const lastCell = this._grid.getColumns().length - 1;\n    for (let i = 0; i < rows.length; i++) {\n      ranges.push(new SlickRange(rows[i], 0, rows[i], lastCell));\n    }\n    return ranges;\n  }\n\n  protected getRowsRange(from: number, to: number) {\n    let i;\n    const rows: number[] = [];\n    for (i = from; i <= to; i++) {\n      rows.push(i);\n    }\n    for (i = to; i < from; i++) {\n      rows.push(i);\n    }\n    return rows;\n  }\n\n  getSelectedRows() {\n    return this.rangesToRows(this._ranges);\n  }\n\n  setSelectedRows(rows: number[]) {\n    this.setSelectedRanges(this.rowsToRanges(rows), 'SlickRowSelectionModel.setSelectedRows');\n  }\n\n  setSelectedRanges(ranges: CellRange[], caller = 'SlickRowSelectionModel.setSelectedRanges') {\n    // simple check for: empty selection didn't change, prevent firing onSelectedRangesChanged\n    if ((!this._ranges || this._ranges.length === 0) && (!ranges || ranges.length === 0)) {\n      return;\n    }\n    this._ranges = ranges;\n\n    // provide extra \"caller\" argument through SlickEventData to avoid breaking pubsub event that only accepts an array of selected range\n    const eventData = new SlickEventData(null, this._ranges);\n    Object.defineProperty(eventData, 'detail', { writable: true, configurable: true, value: { caller: caller || \"SlickRowSelectionModel.setSelectedRanges\" } });\n    this.onSelectedRangesChanged.notify(this._ranges, eventData);\n  }\n\n  getSelectedRanges() {\n    return this._ranges;\n  }\n\n  refreshSelections() {\n    this.setSelectedRows(this.getSelectedRows());\n  }\n\n  protected handleActiveCellChange(_e: SlickEventData_, args: OnActiveCellChangedEventArgs) {\n    if (this._options.selectActiveRow && Utils.isDefined(args.row)) {\n      this.setSelectedRanges([new SlickRange(args.row, 0, args.row, this._grid.getColumns().length - 1)]);\n    }\n  }\n\n  protected handleKeyDown(e: KeyboardEvent) {\n    const activeRow = this._grid.getActiveCell();\n    if (this._grid.getOptions().multiSelect && activeRow\n      && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey\n      && (e.which === keyCode.UP || e.which === keyCode.DOWN)) {\n      let selectedRows = this.getSelectedRows();\n      selectedRows.sort(function (x, y) {\n        return x - y;\n      });\n\n      if (!selectedRows.length) {\n        selectedRows = [activeRow.row];\n      }\n\n      let top = selectedRows[0];\n      let bottom = selectedRows[selectedRows.length - 1];\n      let active: number;\n\n      if (e.which === keyCode.DOWN) {\n        active = activeRow.row < bottom || top === bottom ? ++bottom : ++top;\n      } else {\n        active = activeRow.row < bottom ? --bottom : --top;\n      }\n\n      if (active >= 0 && active < this._grid.getDataLength()) {\n        this._grid.scrollRowIntoView(active);\n        const tempRanges = this.rowsToRanges(this.getRowsRange(top, bottom));\n        this.setSelectedRanges(tempRanges);\n      }\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  protected handleClick(e: MouseEvent): boolean | void {\n    const cell = this._grid.getCellFromEvent(e);\n    if (!cell || !this._grid.canCellBeActive(cell.row, cell.cell)) {\n      return false;\n    }\n\n    if (!this._grid.getOptions().multiSelect || (\n      !e.ctrlKey && !e.shiftKey && !e.metaKey)) {\n      return false;\n    }\n\n    let selection = this.rangesToRows(this._ranges);\n    const idx = selection.indexOf(cell.row);\n\n    if (idx === -1 && (e.ctrlKey || e.metaKey)) {\n      selection.push(cell.row);\n      this._grid.setActiveCell(cell.row, cell.cell);\n    } else if (idx !== -1 && (e.ctrlKey || e.metaKey)) {\n      selection = selection.filter((o) => o !== cell.row);\n      this._grid.setActiveCell(cell.row, cell.cell);\n    } else if (selection.length && e.shiftKey) {\n      const last = selection.pop() as number;\n      const from = Math.min(cell.row, last);\n      const to = Math.max(cell.row, last);\n      selection = [];\n      for (let i = from; i <= to; i++) {\n        if (i !== last) {\n          selection.push(i);\n        }\n      }\n      selection.push(last);\n      this._grid.setActiveCell(cell.row, cell.cell);\n    }\n\n    const tempRanges = this.rowsToRanges(selection);\n    this.setSelectedRanges(tempRanges);\n    e.stopImmediatePropagation();\n\n    return true;\n  }\n\n  protected handleBeforeCellRangeSelected(e: SlickEventData_, cell: { row: number; cell: number; }): boolean | void {\n    if (!this._isRowMoveManagerHandler) {\n      const rowMoveManager = this._grid.getPluginByName<SlickRowMoveManager_>('RowMoveManager') || this._grid.getPluginByName<SlickCrossGridRowMoveManager_>('CrossGridRowMoveManager');\n      this._isRowMoveManagerHandler = rowMoveManager ? rowMoveManager.isHandlerColumn : Utils.noop;\n    }\n    if (this._grid.getEditorLock().isActive() || this._isRowMoveManagerHandler(cell.cell)) {\n      e.stopPropagation();\n      return false;\n    }\n    this._grid.setActiveCell(cell.row, cell.cell);\n  }\n\n  protected handleCellRangeSelected(_e: SlickEventData_, args: { range: CellRange; }): boolean | void {\n    if (!this._grid.getOptions().multiSelect || !this._options.selectActiveRow) {\n      return false;\n    }\n    this.setSelectedRanges([new SlickRange(args.range.fromRow, 0, args.range.toRow, this._grid.getColumns().length - 1)]);\n  }\n}\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(true, window, {\n    Slick: {\n      RowSelectionModel: SlickRowSelectionModel\n    }\n  });\n}\n\n"],
  "mappings": "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",
  "names": []
}
