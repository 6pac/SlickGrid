{
  "version": 3,
  "sources": ["../../../src/plugins/slick.rowselectionmodel.js"],
  "sourcesContent": ["import { Event as SlickEvent_, EventData as EventData_, EventHandler as EventHandler_, keyCode as keyCode_, Range as SlickRange_, Utils as Utils_ } from '../slick.core';\nimport { Draggable as Draggable_ } from '../slick.interactions';\nimport { CellRangeDecorator as CellRangeDecorator_ } from './slick.cellrangedecorator';\nimport { CellRangeSelector as CellRangeSelector_ } from './slick.cellrangeselector';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (cjs/esm)\nconst EventData = IIFE_ONLY ? Slick.EventData : EventData_;\nconst EventHandler = IIFE_ONLY ? Slick.EventHandler : EventHandler_;\nconst keyCode = IIFE_ONLY ? Slick.keyCode : keyCode_;\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst SlickRange = IIFE_ONLY ? Slick.Range : SlickRange_;\nconst Draggable = IIFE_ONLY ? Slick.Draggable : Draggable_;\nconst CellRangeDecorator = IIFE_ONLY ? Slick.CellRangeDecorator : CellRangeDecorator_;\nconst CellRangeSelector = IIFE_ONLY ? Slick.CellRangeSelector : CellRangeSelector_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\nexport function RowSelectionModel(options) {\n    var _grid;\n    var _ranges = [];\n    var _self = this;\n  var _handler = new EventHandler();\n    var _inHandler;\n    var _options;\n    var _selector;\n    var _isRowMoveManagerHandler;\n    var _defaults = {\n      selectActiveRow: true,\n      dragToSelect: false,\n      autoScrollWhenDrag: true,\n      cellRangeSelector: undefined\n    };\n\n    function init(grid) {\n      if (typeof Draggable === \"undefined\") {\n        throw new Error('Slick.Draggable is undefined, make sure to import \"slick.interactions.js\"');\n      }\n\n      _options = Utils.extend(true, {}, _defaults, options);\n      _selector = _options.cellRangeSelector;\n      _grid = grid;\n\n      if (!_selector && _options.dragToSelect) {\n        if (!CellRangeDecorator) {\n            throw new Error(\"Slick.CellRangeDecorator is required when option dragToSelect set to true\");\n        }\n        _selector = new CellRangeSelector({\n          selectionCss: {\n            \"border\": \"none\"\n          },\n          autoScroll: _options.autoScrollWhenDrag\n        })\n      }\n\n      _handler.subscribe(_grid.onActiveCellChanged,\n          wrapHandler(handleActiveCellChange));\n      _handler.subscribe(_grid.onKeyDown,\n          wrapHandler(handleKeyDown));\n      _handler.subscribe(_grid.onClick,\n          wrapHandler(handleClick));\n      if (_selector) {\n        grid.registerPlugin(_selector);\n        _selector.onCellRangeSelecting.subscribe(handleCellRangeSelected);\n        _selector.onCellRangeSelected.subscribe(handleCellRangeSelected);\n        _selector.onBeforeCellRangeSelected.subscribe(handleBeforeCellRangeSelected);\n      }\n    }\n\n    function destroy() {\n      _handler.unsubscribeAll();\n      if (_selector) {\n        _selector.onCellRangeSelecting.unsubscribe(handleCellRangeSelected);\n        _selector.onCellRangeSelected.unsubscribe(handleCellRangeSelected);\n        _selector.onBeforeCellRangeSelected.unsubscribe(handleBeforeCellRangeSelected);\n        _grid.unregisterPlugin(_selector);\n        if (_selector.destroy) {\n          _selector.destroy();\n        }\n      }\n    }\n\n    function wrapHandler(handler) {\n      return function () {\n        if (!_inHandler) {\n          _inHandler = true;\n          handler.apply(this, arguments);\n          _inHandler = false;\n        }\n      };\n    }\n\n    function rangesToRows(ranges) {\n      var rows = [];\n      for (var i = 0; i < ranges.length; i++) {\n        for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n          rows.push(j);\n        }\n      }\n      return rows;\n    }\n\n    function rowsToRanges(rows) {\n      var ranges = [];\n      var lastCell = _grid.getColumns().length - 1;\n      for (var i = 0; i < rows.length; i++) {\n        ranges.push(new SlickRange(rows[i], 0, rows[i], lastCell));\n      }\n      return ranges;\n    }\n\n    function getRowsRange(from, to) {\n      var i, rows = [];\n      for (i = from; i <= to; i++) {\n        rows.push(i);\n      }\n      for (i = to; i < from; i++) {\n        rows.push(i);\n      }\n      return rows;\n    }\n\n    function getSelectedRows() {\n      return rangesToRows(_ranges);\n    }\n\n    function setSelectedRows(rows) {\n      setSelectedRanges(rowsToRanges(rows), \"SlickRowSelectionModel.setSelectedRows\");\n    }\n\n    function setSelectedRanges(ranges, caller) {\n      // simple check for: empty selection didn't change, prevent firing onSelectedRangesChanged\n      if ((!_ranges || _ranges.length === 0) && (!ranges || ranges.length === 0)) {\n        return;\n      }\n      _ranges = ranges;\n\n      // provide extra \"caller\" argument through SlickEventData to avoid breaking pubsub event that only accepts an array of selected range\n      var eventData = new EventData(null, _ranges);\n      Object.defineProperty(eventData, 'detail', { writable: true, configurable: true, value: { caller: caller || \"SlickRowSelectionModel.setSelectedRanges\" } });\n      _self.onSelectedRangesChanged.notify(_ranges, eventData);\n    }\n\n    function getSelectedRanges() {\n      return _ranges;\n    }\n\n    function refreshSelections() {\n      setSelectedRows(getSelectedRows());\n    }\n\n    function handleActiveCellChange(e, data) {\n      if (_options.selectActiveRow && data.row != null) {\n        setSelectedRanges([new SlickRange(data.row, 0, data.row, _grid.getColumns().length - 1)]);\n      }\n    }\n\n    function handleKeyDown(e) {\n      var activeRow = _grid.getActiveCell();\n      if (_grid.getOptions().multiSelect && activeRow\n        && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey\n        && (e.which == keyCode.UP || e.which == keyCode.DOWN)) {\n        var selectedRows = getSelectedRows();\n        selectedRows.sort(function (x, y) {\n          return x - y;\n        });\n\n        if (!selectedRows.length) {\n          selectedRows = [activeRow.row];\n        }\n\n        var top = selectedRows[0];\n        var bottom = selectedRows[selectedRows.length - 1];\n        var active;\n\n        if (e.which == keyCode.DOWN) {\n          active = activeRow.row < bottom || top == bottom ? ++bottom : ++top;\n        } else {\n          active = activeRow.row < bottom ? --bottom : --top;\n        }\n\n        if (active >= 0 && active < _grid.getDataLength()) {\n          _grid.scrollRowIntoView(active);\n          var tempRanges = rowsToRanges(getRowsRange(top, bottom));\n          setSelectedRanges(tempRanges);\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n\n    function handleClick(e) {\n      var cell = _grid.getCellFromEvent(e);\n      if (!cell || !_grid.canCellBeActive(cell.row, cell.cell)) {\n        return false;\n      }\n\n      if (!_grid.getOptions().multiSelect || (\n          !e.ctrlKey && !e.shiftKey && !e.metaKey)) {\n        return false;\n      }\n\n      var selection = rangesToRows(_ranges);\n      var idx = selection.indexOf(cell.row);\n\n      if (idx === -1 && (e.ctrlKey || e.metaKey)) {\n        selection.push(cell.row);\n        _grid.setActiveCell(cell.row, cell.cell);\n      } else if (idx !== -1 && (e.ctrlKey || e.metaKey)) {\n        selection = selection.filter((o) => o !== cell.row);\n        _grid.setActiveCell(cell.row, cell.cell);\n      } else if (selection.length && e.shiftKey) {\n        var last = selection.pop();\n        var from = Math.min(cell.row, last);\n        var to = Math.max(cell.row, last);\n        selection = [];\n        for (var i = from; i <= to; i++) {\n          if (i !== last) {\n            selection.push(i);\n          }\n        }\n        selection.push(last);\n        _grid.setActiveCell(cell.row, cell.cell);\n      }\n\n      var tempRanges = rowsToRanges(selection);\n      setSelectedRanges(tempRanges);\n      e.stopImmediatePropagation();\n\n      return true;\n    }\n\n    function handleBeforeCellRangeSelected(e, cell) {\n      if (!_isRowMoveManagerHandler) {\n        var rowMoveManager = _grid.getPluginByName('RowMoveManager') || _grid.getPluginByName('CrossGridRowMoveManager');\n        _isRowMoveManagerHandler = rowMoveManager ? rowMoveManager.isHandlerColumn : Utils.noop;\n      }\n      if (_grid.getEditorLock().isActive() || _isRowMoveManagerHandler(cell.cell)) {\n        e.stopPropagation();\n        return false;\n      }\n      _grid.setActiveCell(cell.row, cell.cell);\n    }\n\n    function handleCellRangeSelected(e, args) {\n      if (!_grid.getOptions().multiSelect || !_options.selectActiveRow) {\n        return false;\n      }\n      setSelectedRanges([new SlickRange(args.range.fromRow, 0, args.range.toRow, _grid.getColumns().length - 1)])\n    }\n\n  Utils.extend(this, {\n      \"getSelectedRows\": getSelectedRows,\n      \"setSelectedRows\": setSelectedRows,\n\n      \"getSelectedRanges\": getSelectedRanges,\n      \"setSelectedRanges\": setSelectedRanges,\n\n      \"refreshSelections\": refreshSelections,\n\n      \"init\": init,\n      \"destroy\": destroy,\n      \"pluginName\": \"RowSelectionModel\",\n\n    \"onSelectedRangesChanged\": new SlickEvent()\n    });\n  }\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(true, window, {\n    Slick: {\n      RowSelectionModel\n    }\n  });\n}\n\n"],
  "mappings": "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",
  "names": []
}
