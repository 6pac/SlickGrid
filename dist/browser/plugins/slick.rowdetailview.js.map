{
  "version": 3,
  "sources": ["../../../src/plugins/slick.rowdetailview.ts"],
  "sourcesContent": ["import { SlickEvent as SlickEvent_, SlickEventHandler as SlickEventHandler_, Utils as Utils_ } from '../slick.core';\nimport type { Column, DOMEvent, FormatterResultWithHtml, FormatterResultWithText, GridOption, OnAfterRowDetailToggleArgs, OnBeforeRowDetailToggleArgs, OnRowBackToViewportRangeArgs, OnRowDetailAsyncEndUpdateArgs, OnRowDetailAsyncResponseArgs, OnRowOutOfViewportRangeArgs, RowDetailViewOption, UsabilityOverrideFn } from '../models/index';\nimport type { SlickDataView } from '../slick.dataview';\nimport type { SlickGrid } from '../slick.grid';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst SlickEventHandler = IIFE_ONLY ? Slick.EventHandler : SlickEventHandler_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\n/**\n * A plugin to add row detail panel\n * Original StackOverflow question & article making this possible (thanks to violet313)\n * https://stackoverflow.com/questions/10535164/can-slickgrids-row-height-be-dynamically-altered#29399927\n * http://violet313.org/slickgrids/#intro\n *\n * USAGE:\n * Add the slick.rowDetailView.(js|css) files and register the plugin with the grid.\n *\n * AVAILABLE ROW DETAIL OPTIONS:\n *    cssClass:               A CSS class to be added to the row detail\n *    expandedClass:          Extra classes to be added to the expanded Toggle\n *    expandableOverride:     callback method that user can override the default behavior of making every row an expandable row (the logic to show or not the expandable icon).\n *    collapsedClass:         Extra classes to be added to the collapse Toggle\n *    loadOnce:               Defaults to false, when set to True it will load the data once and then reuse it.\n *    preTemplate:            Template that will be used before the async process (typically used to show a spinner/loading)\n *    postTemplate:           Template that will be loaded once the async function finishes\n *    process:                Async server function call\n *    panelRows:              Row count to use for the template panel\n *    singleRowExpand:        Defaults to false, limit expanded row to 1 at a time.\n *    useRowClick:            Boolean flag, when True will open the row detail on a row click (from any column), default to False\n *    keyPrefix:              Defaults to '_', prefix used for all the plugin metadata added to the item object (meta e.g.: padding, collapsed, parent)\n *    collapseAllOnSort:      Defaults to true, which will collapse all row detail views when user calls a sort. Unless user implements a sort to deal with padding\n *    saveDetailViewOnScroll: Defaults to true, which will save the row detail view in a cache when it detects that it will become out of the viewport buffer\n *    useSimpleViewportCalc:  Defaults to false, which will use simplified calculation of out or back of viewport visibility\n *\n * AVAILABLE PUBLIC METHODS:\n *    init:                 initiliaze the plugin\n *    expandableOverride:   callback method that user can override the default behavior of making every row an expandable row (the logic to show or not the expandable icon).\n *    destroy:              destroy the plugin and it's events\n *    collapseAll:          collapse all opened row detail panel\n *    collapseDetailView:   collapse a row by passing the item object (row detail)\n *    expandDetailView:     expand a row by passing the item object (row detail)\n *    getColumnDefinition:  get the column definitions\n *    getExpandedRows:      get all the expanded rows\n *    getFilterItem:        takes in the item we are filtering and if it is an expanded row returns it's parents row to filter on\n *    getOptions:           get current plugin options\n *    resizeDetailView:     resize a row detail view, it will auto-calculate the number of rows it needs\n *    saveDetailView:       save a row detail view content by passing the row object\n *    setOptions:           set or change some of the plugin options\n *\n * THE PLUGIN EXPOSES THE FOLLOWING SLICK EVENTS:\n *    onAsyncResponse:  This event must be used with the \"notify\" by the end user once the Asynchronous Server call returns the item detail\n *      Event args:\n *        item:         Item detail returned from the async server call\n *        detailView:   An explicit view to use instead of template (Optional)\n *\n *    onAsyncEndUpdate: Fired when the async response finished\n *      Event args:\n *        grid:         Reference to the grid.\n *        item:         Item data context\n *\n *    onBeforeRowDetailToggle: Fired before the row detail gets toggled\n *      Event args:\n *        grid:         Reference to the grid.\n *        item:         Item data context\n *\n *    onAfterRowDetailToggle: Fired after the row detail gets toggled\n *      Event args:\n *        grid:         Reference to the grid.\n *        item:         Item data context\n *        expandedRows: Array of the Expanded Rows\n *\n *    onRowOutOfViewportRange: Fired after a row becomes out of viewport range (user can't see the row anymore)\n *      Event args:\n *        grid:         Reference to the grid.\n *        item:         Item data context\n *        rowId:        Id of the Row object (datacontext) in the Grid\n *        rowIndex:     Index of the Row in the Grid\n *        expandedRows: Array of the Expanded Rows\n *        rowIdsOutOfViewport: Array of the Out of viewport Range Rows\n *\n *    onRowBackToViewportRange: Fired after a row is back to viewport range (user can visually see the row detail)\n *      Event args:\n *        grid:         Reference to the grid.\n *        item:         Item data context\n *        rowId:        Id of the Row object (datacontext) in the Grid\n *        rowIndex:     Index of the Row in the Grid\n *        expandedRows: Array of the Expanded Rows\n *        rowIdsOutOfViewport: Array of the Out of viewport Range Rows\n */\nexport class SlickRowDetailView {\n  // --\n  // public API\n  pluginName = 'RowDetailView' as const;\n  onAsyncResponse = new SlickEvent<OnRowDetailAsyncResponseArgs>();\n  onAsyncEndUpdate = new SlickEvent<OnRowDetailAsyncEndUpdateArgs>();\n  onAfterRowDetailToggle = new SlickEvent<OnAfterRowDetailToggleArgs>();\n  onBeforeRowDetailToggle = new SlickEvent<OnBeforeRowDetailToggleArgs>();\n  onRowBackToViewportRange = new SlickEvent<OnRowBackToViewportRangeArgs>();\n  onRowOutOfViewportRange = new SlickEvent<OnRowOutOfViewportRangeArgs>();\n\n  // --\n  // protected props\n  protected _grid!: SlickGrid;\n  protected _gridOptions!: GridOption;\n  protected _gridUid = '';\n  protected _dataView!: SlickDataView;\n  protected _dataViewIdProperty = 'id';\n  protected _expandableOverride: UsabilityOverrideFn | null = null;\n  protected _lastRange: { bottom: number; top: number; } | null = null;\n  protected _expandedRows: any[] = [];\n  protected _eventHandler: SlickEventHandler_;\n  protected _outsideRange = 5;\n  protected _visibleRenderedCellCount = 0;\n  protected _options: RowDetailViewOption;\n  protected _defaults = {\n    columnId: '_detail_selector',\n    cssClass: 'detailView-toggle',\n    expandedClass: undefined,\n    collapsedClass: undefined,\n    keyPrefix: '_',\n    loadOnce: false,\n    collapseAllOnSort: true,\n    saveDetailViewOnScroll: true,\n    singleRowExpand: false,\n    useSimpleViewportCalc: false,\n    alwaysRenderColumn: true,\n    toolTip: '',\n    width: 30,\n    maxRows: undefined\n  } as RowDetailViewOption;\n  protected _keyPrefix = this._defaults.keyPrefix;\n  protected _gridRowBuffer = 0;\n  protected _rowIdsOutOfViewport: Array<number | string> = [];\n\n  /** Constructor of the Row Detail View Plugin which accepts optional options */\n  constructor(options: RowDetailViewOption) {\n    this._options = Utils.extend(true, {}, this._defaults, options);\n    this._eventHandler = new SlickEventHandler();\n\n    // user could override the expandable icon logic from within the options or after instantiating the plugin\n    if (typeof this._options.expandableOverride === 'function') {\n      this.expandableOverride(this._options.expandableOverride);\n    }\n  }\n\n  /**\n   * Initialize the plugin, which requires user to pass the SlickGrid Grid object\n   * @param grid: SlickGrid Grid object\n   */\n  init(grid: SlickGrid) {\n    if (!grid) {\n      throw new Error('RowDetailView Plugin requires the Grid instance to be passed as argument to the \"init()\" method');\n    }\n    this._grid = grid;\n    this._gridUid = grid.getUID();\n    this._gridOptions = grid.getOptions() || {};\n    this._dataView = this._grid.getData<SlickDataView>();\n    this._keyPrefix = this._options?.keyPrefix ?? '_';\n\n    // Update the minRowBuffer so that the view doesn't disappear when it's at top of screen + the original default 3\n    this._gridRowBuffer = this._gridOptions.minRowBuffer || 0;\n    this._gridOptions.minRowBuffer = this._options.panelRows + 3;\n\n    this._eventHandler\n      .subscribe(this._grid.onClick, this.handleClick.bind(this))\n      .subscribe(this._grid.onScroll, this.handleScroll.bind(this));\n\n    // Sort will, by default, Collapse all of the open items (unless user implements his own onSort which deals with open row and padding)\n    if (this._options.collapseAllOnSort) {\n      this._eventHandler.subscribe(this._grid.onSort, this.collapseAll.bind(this));\n      this._expandedRows = [];\n      this._rowIdsOutOfViewport = [];\n    }\n\n    this._eventHandler.subscribe(this._dataView.onRowCountChanged, () => {\n      this._grid.updateRowCount();\n      this._grid.render();\n    });\n\n    this._eventHandler.subscribe(this._dataView.onRowsChanged, (_e, a) => {\n      this._grid.invalidateRows(a.rows);\n      this._grid.render();\n    });\n\n    // subscribe to the onAsyncResponse so that the plugin knows when the user server side calls finished\n    this.subscribeToOnAsyncResponse();\n\n    // after data is set, let's get the DataView Id Property name used (defaults to \"id\")\n    this._eventHandler.subscribe(this._dataView.onSetItemsCalled, () => {\n      this._dataViewIdProperty = this._dataView?.getIdPropertyName() ?? 'id';\n    });\n\n    // if we use the alternative & simpler calculation of the out of viewport range\n    // we will need to know how many rows are rendered on the screen and we need to wait for grid to be rendered\n    // unfortunately there is no triggered event for knowing when grid is finished, so we use 250ms delay and it's typically more than enough\n    if (this._options.useSimpleViewportCalc) {\n      this._eventHandler.subscribe(this._grid.onRendered, (_e, args) => {\n        if (args?.endRow) {\n          this._visibleRenderedCellCount = args.endRow - args.startRow;\n        }\n      });\n    }\n  }\n\n  /** destroy the plugin and it's events */\n  destroy() {\n    this._eventHandler.unsubscribeAll();\n    this.onAsyncResponse.unsubscribe();\n    this.onAsyncEndUpdate.unsubscribe();\n    this.onAfterRowDetailToggle.unsubscribe();\n    this.onBeforeRowDetailToggle.unsubscribe();\n    this.onRowOutOfViewportRange.unsubscribe();\n    this.onRowBackToViewportRange.unsubscribe();\n  }\n\n  /** Get current plugin options */\n  getOptions() {\n    return this._options;\n  }\n\n  /** set or change some of the plugin options */\n  setOptions(options: Partial<RowDetailViewOption>) {\n    this._options = Utils.extend(true, {}, this._options, options);\n    if (this._options?.singleRowExpand) {\n      this.collapseAll();\n    }\n  }\n\n  /** Find a value in an array and return the index when (or -1 when not found) */\n  protected arrayFindIndex(sourceArray: any[], value: any) {\n    if (Array.isArray(sourceArray)) {\n      for (let i = 0; i < sourceArray.length; i++) {\n        if (sourceArray[i] === value) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /** Handle mouse click event */\n  protected handleClick(e: DOMEvent<HTMLDivElement>, args: { row: number; cell: number; }) {\n    const dataContext = this._grid.getDataItem(args.row);\n    if (!this.checkExpandableOverride(args.row, dataContext, this._grid)) {\n      return;\n    }\n\n    // clicking on a row select checkbox\n    if (this._options.useRowClick || this._grid.getColumns()[args.cell]['id'] === this._options.columnId && e.target.classList.contains(this._options.cssClass || '')) {\n      // if editing, try to commit\n      if (this._grid.getEditorLock().isActive() && !this._grid.getEditorLock().commitCurrentEdit()) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return;\n      }\n\n      // trigger an event before toggling\n      // user could cancel the Row Detail opening when event is returning false\n      if (this.onBeforeRowDetailToggle.notify({ grid: this._grid, item: dataContext }, e, this).getReturnValue() === false) {\n        return;\n      }\n\n      this.toggleRowSelection(args.row, dataContext);\n\n      // trigger an event after toggling\n      this.onAfterRowDetailToggle.notify({\n        grid: this._grid,\n        item: dataContext,\n        expandedRows: this._expandedRows,\n      }, e, this);\n\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  /** If we scroll save detail views that go out of cache range */\n  protected handleScroll() {\n    if (this._options.useSimpleViewportCalc) {\n      this.calculateOutOfRangeViewsSimplerVersion();\n    } else {\n      this.calculateOutOfRangeViews();\n    }\n  }\n\n  /** Calculate when expanded rows become out of view range */\n  protected calculateOutOfRangeViews() {\n    let scrollDir = '';\n    if (this._grid) {\n      const renderedRange = this._grid.getRenderedRange();\n      // Only check if we have expanded rows\n      if (this._expandedRows.length > 0) {\n        // Assume scroll direction is down by default.\n        scrollDir = 'DOWN';\n        if (this._lastRange) {\n          // Some scrolling isn't anything as the range is the same\n          if (this._lastRange.top === renderedRange.top && this._lastRange.bottom === renderedRange.bottom) {\n            return;\n          }\n\n          // If our new top is smaller we are scrolling up\n          if (this._lastRange.top > renderedRange.top ||\n            // Or we are at very top but our bottom is increasing\n            (this._lastRange.top === 0 && renderedRange.top === 0) && this._lastRange.bottom > renderedRange.bottom) {\n            scrollDir = 'UP';\n          }\n        }\n      }\n\n      this._expandedRows.forEach((row) => {\n        const rowIndex = this._dataView?.getRowById(row[this._dataViewIdProperty]) ?? 0;\n        const rowPadding = row[`${this._keyPrefix}sizePadding`];\n        const rowOutOfRange = this.arrayFindIndex(this._rowIdsOutOfViewport, row[this._dataViewIdProperty]) >= 0;\n\n        if (scrollDir === 'UP') {\n          // save the view when asked\n          if (this._options.saveDetailViewOnScroll) {\n            // If the bottom item within buffer range is an expanded row save it.\n            if (rowIndex >= renderedRange.bottom - this._gridRowBuffer) {\n              this.saveDetailView(row);\n            }\n          }\n\n          // If the row expanded area is within the buffer notify that it is back in range\n          if (rowOutOfRange && rowIndex - this._outsideRange < renderedRange.top && rowIndex >= renderedRange.top) {\n            this.notifyBackToViewportWhenDomExist(row, row[this._dataViewIdProperty]);\n          }\n\n          // if our first expanded row is about to go off the bottom\n          else if (!rowOutOfRange && (rowIndex + rowPadding) > renderedRange.bottom) {\n            this.notifyOutOfViewport(row, row[this._dataViewIdProperty]);\n          }\n        }\n        else if (scrollDir === 'DOWN') {\n          // save the view when asked\n          if (this._options.saveDetailViewOnScroll) {\n            // If the top item within buffer range is an expanded row save it.\n            if (rowIndex <= renderedRange.top + this._gridRowBuffer) {\n              this.saveDetailView(row);\n            }\n          }\n\n          // If row index is i higher than bottom with some added value (To ignore top rows off view) and is with view and was our of range\n          if (rowOutOfRange && (rowIndex + rowPadding + this._outsideRange) > renderedRange.bottom && rowIndex < rowIndex + rowPadding) {\n            this.notifyBackToViewportWhenDomExist(row, row[this._dataViewIdProperty]);\n          }\n          // if our row is outside top of and the buffering zone but not in the array of outOfVisable range notify it\n          else if (!rowOutOfRange && rowIndex < renderedRange.top) {\n            this.notifyOutOfViewport(row, row[this._dataViewIdProperty]);\n          }\n        }\n      });\n      this._lastRange = renderedRange;\n    }\n  }\n\n  /** This is an alternative & more simpler version of the Calculate when expanded rows become out of view range */\n  protected calculateOutOfRangeViewsSimplerVersion() {\n    if (this._grid) {\n      const renderedRange = this._grid.getRenderedRange();\n\n      this._expandedRows.forEach((row) => {\n        const rowIndex = this._dataView.getRowById(row[this._dataViewIdProperty]) ?? -1;\n        const isOutOfVisibility = this.checkIsRowOutOfViewportRange(rowIndex, renderedRange);\n        if (!isOutOfVisibility && this.arrayFindIndex(this._rowIdsOutOfViewport, row[this._dataViewIdProperty]) >= 0) {\n          this.notifyBackToViewportWhenDomExist(row, row[this._dataViewIdProperty]);\n        } else if (isOutOfVisibility) {\n          this.notifyOutOfViewport(row, row[this._dataViewIdProperty]);\n        }\n      });\n    }\n  }\n\n  /**\n   * Check if the row became out of visible range (when user can't see it anymore)\n   * @param rowIndex\n   * @param renderedRange from SlickGrid\n   */\n  protected checkIsRowOutOfViewportRange(rowIndex: number, renderedRange: any) {\n    if (Math.abs(renderedRange.bottom - this._gridRowBuffer - rowIndex) > this._visibleRenderedCellCount * 2) {\n      return true;\n    }\n    return false;\n  }\n\n  /** Send a notification, through \"onRowOutOfViewportRange\", that is out of the viewport range */\n  protected notifyOutOfViewport(item: any, rowId: number | string) {\n    const rowIndex = (item.rowIndex || this._dataView.getRowById(item[this._dataViewIdProperty])) as number;\n\n    this.onRowOutOfViewportRange.notify({\n      grid: this._grid,\n      item,\n      rowId,\n      rowIndex,\n      expandedRows: this._expandedRows,\n      rowIdsOutOfViewport: this.syncOutOfViewportArray(rowId, true)\n    }, null, this);\n  }\n\n  /** Send a notification, through \"onRowBackToViewportRange\", that a row came back into the viewport visible range */\n  protected notifyBackToViewportWhenDomExist(item: any, rowId: number | string) {\n    const rowIndex = (item.rowIndex || this._dataView.getRowById(item[this._dataViewIdProperty])) as number;\n\n    setTimeout(() => {\n      // make sure View Row DOM Element really exist before notifying that it's a row that is visible again\n      if (document.querySelector(`.${this._gridUid} .cellDetailView_${item[this._dataViewIdProperty]}`)) {\n        this.onRowBackToViewportRange.notify({\n          grid: this._grid,\n          item,\n          rowId,\n          rowIndex,\n          expandedRows: this._expandedRows,\n          rowIdsOutOfViewport: this.syncOutOfViewportArray(rowId, false)\n        }, null, this);\n      }\n    }, 100);\n  }\n\n  /**\n   * This function will sync the \"out of viewport\" array whenever necessary.\n   * The sync can add a detail row (when necessary, no need to add again if it already exist) or delete a row from the array.\n   * @param rowId: number\n   * @param isAdding: are we adding or removing a row?\n   */\n  protected syncOutOfViewportArray(rowId: number | string, isAdding: boolean) {\n    const arrayRowIndex = this.arrayFindIndex(this._rowIdsOutOfViewport, rowId);\n\n    if (isAdding && arrayRowIndex < 0) {\n      this._rowIdsOutOfViewport.push(rowId);\n    } else if (!isAdding && arrayRowIndex >= 0) {\n      this._rowIdsOutOfViewport.splice(arrayRowIndex, 1);\n    }\n    return this._rowIdsOutOfViewport;\n  }\n\n  // Toggle between showing or hiding a row\n  protected toggleRowSelection(rowNumber: number, dataContext: any) {\n    if (!this.checkExpandableOverride(rowNumber, dataContext, this._grid)) {\n      return;\n    }\n\n    this._dataView.beginUpdate();\n    this.handleAccordionShowHide(dataContext);\n    this._dataView.endUpdate();\n  }\n\n  /** Collapse all of the open detail rows */\n  collapseAll() {\n    this._dataView.beginUpdate();\n    for (let i = this._expandedRows.length - 1; i >= 0; i--) {\n      this.collapseDetailView(this._expandedRows[i], true);\n    }\n    this._dataView.endUpdate();\n  }\n\n  /** Collapse a detail row so that it is not longer open */\n  collapseDetailView(item: any, isMultipleCollapsing = false) {\n    if (!isMultipleCollapsing) {\n      this._dataView.beginUpdate();\n    }\n    // Save the details on the collapse assuming onetime loading\n    if (this._options.loadOnce) {\n      this.saveDetailView(item);\n    }\n\n    item[`${this._keyPrefix}collapsed`] = true;\n    for (let idx = 1; idx <= item[`${this._keyPrefix}sizePadding`]; idx++) {\n      this._dataView.deleteItem(item[this._dataViewIdProperty] + '.' + idx);\n    }\n    item[`${this._keyPrefix}sizePadding`] = 0;\n    this._dataView.updateItem(item[this._dataViewIdProperty], item);\n\n    // Remove the item from the expandedRows\n    this._expandedRows = this._expandedRows.filter((r) => {\n      return r[this._dataViewIdProperty] !== item[this._dataViewIdProperty];\n    });\n\n    if (!isMultipleCollapsing) {\n      this._dataView.endUpdate();\n    }\n  }\n\n  /** Expand a detail row by providing the dataview item that is to be expanded */\n  expandDetailView(item: any) {\n    if (this._options?.singleRowExpand) {\n      this.collapseAll();\n    }\n\n    item[`${this._keyPrefix}collapsed`] = false;\n    this._expandedRows.push(item);\n\n    // In the case something went wrong loading it the first time such a scroll of screen before loaded\n    if (!item[`${this._keyPrefix}detailContent`]) {\n      item[`${this._keyPrefix}detailViewLoaded`] = false;\n    }\n    // display pre-loading template\n    if (!item[`${this._keyPrefix}detailViewLoaded`] || this._options.loadOnce !== true) {\n      item[`${this._keyPrefix}detailContent`] = this._options?.preTemplate?.(item);\n    } else {\n      this.onAsyncResponse.notify({\n        item,\n        itemDetail: item,\n        detailView: item[`${this._keyPrefix}detailContent`]\n      }, undefined, this);\n      this.applyTemplateNewLineHeight(item);\n      this._dataView.updateItem(item[this._dataViewIdProperty], item);\n\n      return;\n    }\n\n    this.applyTemplateNewLineHeight(item);\n    this._dataView.updateItem(item[this._dataViewIdProperty], item);\n\n    // async server call\n    this._options.process(item);\n  }\n\n  /** Saves the current state of the detail view */\n  saveDetailView(item: any) {\n    const view = document.querySelector(`.${this._gridUid} .innerDetailView_${item[this._dataViewIdProperty]}`);\n    if (view) {\n      const html = view.innerHTML;\n      if (html !== undefined) {\n        item[`${this._keyPrefix}detailContent`] = html;\n      }\n    }\n  }\n\n  /**\n   * subscribe to the onAsyncResponse so that the plugin knows when the user server side calls finished\n   * the response has to be as \"args.item\" (or \"args.itemDetail\") with it's data back\n   */\n  protected subscribeToOnAsyncResponse() {\n    this.onAsyncResponse.subscribe((e, args) => {\n      if (!args || (!args.item && !args.itemDetail)) {\n        throw 'Slick.RowDetailView plugin requires the onAsyncResponse() to supply \"args.item\" property.';\n      }\n\n      // we accept item/itemDetail, just get the one which has data\n      const itemDetail = args.item || args.itemDetail;\n\n      // If we just want to load in a view directly we can use detailView property to do so\n      if (args.detailView) {\n        itemDetail[`${this._keyPrefix}detailContent`] = args.detailView;\n      } else {\n        itemDetail[`${this._keyPrefix}detailContent`] = this._options?.postTemplate?.(itemDetail);\n      }\n\n      itemDetail[`${this._keyPrefix}detailViewLoaded`] = true;\n      this._dataView.updateItem(itemDetail[this._dataViewIdProperty], itemDetail);\n\n      // trigger an event once the post template is finished loading\n      this.onAsyncEndUpdate.notify({\n        grid: this._grid,\n        item: itemDetail,\n        itemDetail\n      }, e, this);\n    });\n  }\n\n  /** When row is getting toggled, we will handle the action of collapsing/expanding */\n  protected handleAccordionShowHide(item: any) {\n    if (item) {\n      if (!item[`${this._keyPrefix}collapsed`]) {\n        this.collapseDetailView(item);\n      } else {\n        this.expandDetailView(item);\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////\n\n  /** Get the Row Detail padding (which are the rows dedicated to the detail panel) */\n  protected getPaddingItem(parent: any, offset: any) {\n    const item: any = {};\n\n    for (const prop in this._dataView) {\n      item[prop] = null;\n    }\n    item[this._dataViewIdProperty] = parent[this._dataViewIdProperty] + '.' + offset;\n\n    // additional hidden padding metadata fields\n    item[`${this._keyPrefix}collapsed`] = true;\n    item[`${this._keyPrefix}isPadding`] = true;\n    item[`${this._keyPrefix}parent`] = parent;\n    item[`${this._keyPrefix}offset`] = offset;\n\n    return item;\n  };\n\n  /** Create the detail ctr node. this belongs to the dev & can be custom-styled as per */\n  protected applyTemplateNewLineHeight(item: any) {\n    // the height is calculated by the template row count (how many line of items does the template view have)\n    const rowCount = this._options.panelRows;\n\n    // calculate padding requirements based on detail-content..\n    // ie. worst-case: create an invisible dom node now & find it's height.\n    const lineHeight = 13; // we know cuz we wrote the custom css init ;)\n    item[`${this._keyPrefix}sizePadding`] = Math.ceil(((rowCount * 2) * lineHeight) / this._gridOptions.rowHeight!);\n    item[`${this._keyPrefix}height`] = (item[`${this._keyPrefix}sizePadding`] * this._gridOptions.rowHeight!);\n    const idxParent = this._dataView.getIdxById(item[this._dataViewIdProperty]) ?? 0;\n    for (let idx = 1; idx <= item[`${this._keyPrefix}sizePadding`]; idx++) {\n      this._dataView.insertItem(idxParent + idx, this.getPaddingItem(item, idx));\n    }\n  }\n\n  /** Get the Column Definition of the first column dedicated to toggling the Row Detail View */\n  getColumnDefinition() {\n    return {\n      id: this._options.columnId,\n      name: '',\n      toolTip: this._options.toolTip,\n      field: 'sel',\n      width: this._options.width,\n      resizable: false,\n      sortable: false,\n      alwaysRenderColumn: this._options.alwaysRenderColumn,\n      cssClass: this._options.cssClass,\n      formatter: this.detailSelectionFormatter.bind(this)\n    };\n  }\n\n  /** Return the currently expanded rows */\n  getExpandedRows() {\n    return this._expandedRows;\n  }\n\n  /** The cell Formatter that shows the icon that will be used to toggle the Row Detail */\n  protected detailSelectionFormatter(row: number, _cell: number, _val: any, _column: Column, dataContext: any, grid: SlickGrid): FormatterResultWithHtml | FormatterResultWithText | string {\n    if (!this.checkExpandableOverride(row, dataContext, grid)) {\n      return '';\n    } else {\n      if (dataContext[`${this._keyPrefix}collapsed`] === undefined) {\n        dataContext[`${this._keyPrefix}collapsed`] = true;\n        dataContext[`${this._keyPrefix}sizePadding`] = 0;     //the required number of pading rows\n        dataContext[`${this._keyPrefix}height`] = 0;     //the actual height in pixels of the detail field\n        dataContext[`${this._keyPrefix}isPadding`] = false;\n        dataContext[`${this._keyPrefix}parent`] = undefined;\n        dataContext[`${this._keyPrefix}offset`] = 0;\n      }\n\n      if (dataContext[`${this._keyPrefix}isPadding`]) {\n        // render nothing\n      }\n      else if (dataContext[`${this._keyPrefix}collapsed`]) {\n        let collapsedClasses = this._options.cssClass + ' expand ';\n        if (this._options.collapsedClass) {\n          collapsedClasses += this._options.collapsedClass;\n        }\n        return '<div class=\"' + collapsedClasses + '\"></div>';\n      }\n      else {\n        const html: string[] = [];\n        const rowHeight = this._gridOptions.rowHeight;\n        let outterHeight = dataContext[`${this._keyPrefix}sizePadding`] * this._gridOptions.rowHeight!;\n\n        if (this._options.maxRows !== undefined && dataContext[`${this._keyPrefix}sizePadding`] > this._options.maxRows) {\n          outterHeight = this._options.maxRows * rowHeight!;\n          dataContext[`${this._keyPrefix}sizePadding`] = this._options.maxRows;\n        }\n\n        // V313HAX:\n        // putting in an extra closing div after the closing toggle div and ommiting a\n        // final closing div for the detail ctr div causes the slickgrid renderer to\n        // insert our detail div as a new column ;) ~since it wraps whatever we provide\n        // in a generic div column container. so our detail becomes a child directly of\n        // the row not the cell. nice =)  ~no need to apply a css change to the parent\n        // slick-cell to escape the cell overflow clipping.\n\n        // sneaky extra </div> inserted here-----------------v\n        let expandedClasses = this._options.cssClass + ' collapse ';\n        if (this._options.expandedClass) {\n          expandedClasses += this._options.expandedClass;\n        }\n        html.push('<div class=\"' + expandedClasses + '\"></div></div>');\n\n        html.push(`<div class=\"dynamic-cell-detail cellDetailView_${dataContext[this._dataViewIdProperty]}\" `);   //apply custom css to detail\n        html.push(`style=\"height: ${outterHeight}px;`); //set total height of padding\n        html.push(`top: ${rowHeight}px\">`);             //shift detail below 1st row\n        html.push(`<div class=\"detail-container detailViewContainer_${dataContext[this._dataViewIdProperty]}\">`); //sub ctr for custom styling\n        html.push(`<div class=\"innerDetailView_${dataContext[this._dataViewIdProperty]}\">${dataContext[`${this._keyPrefix}detailContent`]}</div></div>`);\n        // omit a final closing detail container </div> that would come next\n\n        return html.join('');\n      }\n    }\n    return '';\n  }\n\n  /** Resize the Row Detail View */\n  resizeDetailView(item: any) {\n    if (!item) {\n      return;\n    }\n\n    // Grad each of the DOM elements\n    const mainContainer = document.querySelector<HTMLDivElement>(`.${this._gridUid} .detailViewContainer_${item[this._dataViewIdProperty]}`);\n    const cellItem = document.querySelector<HTMLDivElement>(`.${this._gridUid} .cellDetailView_${item[this._dataViewIdProperty]}`);\n    const inner = document.querySelector<HTMLDivElement>(`.${this._gridUid} .innerDetailView_${item[this._dataViewIdProperty]}`);\n\n    if (!mainContainer || !cellItem || !inner) {\n      return;\n    }\n\n    for (let idx = 1; idx <= item[`${this._keyPrefix}sizePadding`]; idx++) {\n      this._dataView.deleteItem(`${item[this._dataViewIdProperty]}.${idx}`);\n    }\n\n    const rowHeight = this._gridOptions.rowHeight; // height of a row\n    const lineHeight = 13; // we know cuz we wrote the custom css innit ;)\n\n    // remove the height so we can calculate the height\n    mainContainer.style.minHeight = '';\n\n    // Get the scroll height for the main container so we know the actual size of the view\n    const itemHeight = mainContainer.scrollHeight;\n\n    // Now work out how many rows\n    const rowCount = Math.ceil(itemHeight / rowHeight!);\n\n    item[`${this._keyPrefix}sizePadding`] = Math.ceil(((rowCount * 2) * lineHeight) / rowHeight!);\n    item[`${this._keyPrefix}height`] = itemHeight;\n\n    let outterHeight = (item[`${this._keyPrefix}sizePadding`] * rowHeight!);\n    if (this._options.maxRows !== undefined && item[`${this._keyPrefix}sizePadding`] > this._options.maxRows) {\n      outterHeight = this._options.maxRows * rowHeight!;\n      item[`${this._keyPrefix}sizePadding`] = this._options.maxRows;\n    }\n\n    // If the padding is now more than the original minRowBuff we need to increase it\n    if (this._grid.getOptions().minRowBuffer! < item[`${this._keyPrefix}sizePadding`]) {\n      // Update the minRowBuffer so that the view doesn't disappear when it's at top of screen + the original default 3\n      this._grid.getOptions().minRowBuffer = item[`${this._keyPrefix}sizePadding`] + 3;\n    }\n\n    mainContainer.setAttribute('style', 'min-height: ' + item[`${this._keyPrefix}height`] + 'px');\n    if (cellItem) {\n      cellItem.setAttribute('style', 'height: ' + outterHeight + 'px; top:' + rowHeight + 'px');\n    }\n\n    const idxParent = this._dataView.getIdxById(item[this._dataViewIdProperty]) ?? 0;\n    for (let idx = 1; idx <= item[`${this._keyPrefix}sizePadding`]; idx++) {\n      this._dataView.insertItem(idxParent + idx, this.getPaddingItem(item, idx));\n    }\n\n    // Lastly save the updated state\n    this.saveDetailView(item);\n  }\n\n  /** Takes in the item we are filtering and if it is an expanded row returns it's parents row to filter on */\n  getFilterItem(item: any) {\n    if (item[`${this._keyPrefix}isPadding`] && item[`${this._keyPrefix}parent`]) {\n      item = item[`${this._keyPrefix}parent`];\n    }\n    return item;\n  }\n\n  protected checkExpandableOverride(row: number, dataContext: any, grid: SlickGrid) {\n    if (typeof this._expandableOverride === 'function') {\n      return this._expandableOverride(row, dataContext, grid);\n    }\n    return true;\n  }\n\n  /**\n   * Method that user can pass to override the default behavior or making every row an expandable row.\n   * In order word, user can choose which rows to be an available row detail (or not) by providing his own logic.\n   * @param overrideFn: override function callback\n   */\n  expandableOverride(overrideFn: UsabilityOverrideFn) {\n    this._expandableOverride = overrideFn;\n  }\n}\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(true, window, {\n    Slick: {\n      Plugins: {\n        RowDetailView: SlickRowDetailView\n      }\n    }\n  });\n}\n\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}
