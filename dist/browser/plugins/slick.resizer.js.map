{
  "version": 3,
  "sources": ["../../../src/plugins/slick.resizer.js"],
  "sourcesContent": ["import { BindingEventService as BindingEventService_, Event as SlickEvent_, Utils as Utils_ } from '../slick.core';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (cjs/esm)\nconst BindingEventService = IIFE_ONLY ? Slick.BindingEventService : BindingEventService_;\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\n\n/***\n * A Resizer plugin that can be used to auto-resize a grid and/or resize with fixed dimensions.\n * When fixed height is defined, it will auto-resize only the width and vice versa with the width defined.\n * You can also choose to use the flag \"enableAutoSizeColumns\" if you want to the plugin to\n * automatically call the grid \"autosizeColumns()\" method after each resize.\n *\n * USAGE:\n *\n * Add the \"slick.resizer.js\" file and register it with the grid.\n *\n * You can specify certain options as arguments when instantiating the plugin like so:\n * var resizer = new Slick.Plugins.Resizer({\n *   container: '#gridContainer',\n *   rightPadding: 15,\n *   bottomPadding: 20,\n *   minHeight: 180,\n *   minWidth: 300,\n * });\n * grid.registerPlugin(resizer);\n *\n *\n * The plugin exposes the following events:\n *\n *    onGridAfterResize:  Fired after the grid got resized.  You can customize the menu or dismiss it by returning false.\n *        Event args:\n *            grid:       Reference to the grid.\n *            dimensions: Resized grid dimensions used\n *\n *    onGridBeforeResize:   Fired before the grid gets resized.  You can customize the menu or dismiss it by returning false.\n *        Event args:\n *            grid:     Reference to the grid.\n *\n *\n * @param {Object} options available plugin options that can be passed in the constructor:\n *   container:      (REQUIRED) DOM element selector of the page container, basically what element in the page will be used to calculate the available space\n *   gridContainer:             DOM element selector of the grid container, optional but when provided it will be resized with same size as the grid (typically a container holding the grid and extra custom footer/pagination)\n *   applyResizeToContainer:    Defaults to false, do we want to apply the resized dimentions to the grid container as well?\n *   rightPadding:              Defaults to 0, right side padding to remove from the total dimension\n *   bottomPadding:             Defaults to 20, bottom padding to remove from the total dimension\n *   minHeight:                 Defaults to 180, minimum height of the grid\n *   minWidth:                  Defaults to 300, minimum width of the grid\n *   maxHeight:                 Maximum height of the grid\n *   maxWidth:                  Maximum width of the grid\n *   calculateAvailableSizeBy:  Defaults to \"window\", which DOM element (\"container\" or \"window\") are we using to calculate the available size for the grid?\n *\n * @class Slick.Plugins.Resizer\n * @constructor\n */\n\nexport function Resizer(_options, fixedDimensions) {\n    // global variables, height/width are in pixels\n    let DATAGRID_MIN_HEIGHT = 180;\n    let DATAGRID_MIN_WIDTH = 300;\n    let DATAGRID_BOTTOM_PADDING = 20;\n\n    let _self = this;\n    let _fixedHeight;\n    let _fixedWidth;\n    let _grid;\n    let _gridOptions;\n    let _gridUid;\n    let _lastDimensions;\n    let _timer;\n    let _resizePaused = false;\n    let _gridDomElm;\n    let _pageContainerElm;\n    let _gridContainerElm;\n    let _defaults = {\n      bottomPadding: 20,\n      applyResizeToContainer: false,\n      minHeight: 180,\n      minWidth: 300,\n      rightPadding: 0\n    };\n\n    let options = {};\n  let _bindingEventService = new BindingEventService();\n\n    function setOptions(_newOptions){\n      options = Utils.extend(true, {}, _defaults, options, _newOptions);\n    }\n\n    function init(grid) {\n      setOptions(_options);\n      _grid = grid;\n      _gridOptions = _grid.getOptions();\n      _gridUid = _grid.getUID();\n      _gridDomElm = _grid.getContainerNode();\n\n      if (typeof _options.container === 'string') {\n        _pageContainerElm = typeof _options.container === 'string' ? document.querySelector(_options.container) : _options.container;\n      } else {\n        _pageContainerElm = _options.container;\n      }\n\n      if (options.gridContainer) {\n        _gridContainerElm = options.gridContainer;\n      }\n\n      if (fixedDimensions) {\n        _fixedHeight = fixedDimensions.height;\n        _fixedWidth = fixedDimensions.width;\n      }\n\n      if (_gridOptions) {\n        bindAutoResizeDataGrid();\n      }\n    }\n\n    /** Bind an auto resize trigger on the datagrid, if that is enable then it will resize itself to the available space\n    * Options: we could also provide a % factor to resize on each height/width independently\n    */\n    function bindAutoResizeDataGrid(newSizes) {\n      const gridElmOffset = Utils.offset(_gridDomElm);\n\n      // if we can't find the grid to resize, return without binding anything\n      if (_gridDomElm !== undefined || gridElmOffset !== undefined) {\n        // -- 1st resize the datagrid size at first load (we need this because the .on event is not triggered on first load)\n        // -- also we add a slight delay (in ms) so that we resize after the grid render is done\n        resizeGrid(0, newSizes, null);\n\n        // -- 2nd bind a trigger on the Window DOM element, so that it happens also when resizing after first load\n        // -- bind auto-resize to Window object only if it exist\n        _bindingEventService.bind(window, 'resize', function (event) {\n          _self.onGridBeforeResize.notify({ grid: _grid }, event, _self);\n\n          // unless the resizer is paused, let's go and resize the grid\n          if (!_resizePaused) {\n            // for some yet unknown reason, calling the resize twice removes any stuttering/flickering\n            // when changing the height and makes it much smoother experience\n            resizeGrid(0, newSizes, event);\n            resizeGrid(0, newSizes, event);\n          }\n        });\n      }\n    }\n\n   /**\n    * Calculate the datagrid new height/width from the available space, also consider that a % factor might be applied to calculation\n    */\n    function calculateGridNewDimensions() {\n      const gridElmOffset = Utils.offset(_gridDomElm);\n\n      if (!window || _pageContainerElm === undefined || _gridDomElm === undefined || gridElmOffset === undefined) {\n        return null;\n      }\n\n      // calculate bottom padding\n      let bottomPadding = (options && options.bottomPadding !== undefined) ? options.bottomPadding : DATAGRID_BOTTOM_PADDING;\n\n      let gridHeight = 0;\n      let gridOffsetTop = 0;\n\n      // which DOM element are we using to calculate the available size for the grid?\n      // defaults to \"window\"\n      if (options.calculateAvailableSizeBy === 'container') {\n        // uses the container's height to calculate grid height without any top offset\n        gridHeight = Utils.innerSize(_pageContainerElm, 'height') || 0;\n      } else {\n        // uses the browser's window height with its top offset to calculate grid height\n        gridHeight = window.innerHeight || 0;\n        gridOffsetTop = (gridElmOffset !== undefined) ? gridElmOffset.top : 0;\n      }\n\n      let availableHeight = gridHeight - gridOffsetTop - bottomPadding;\n      let availableWidth = Utils.innerSize(_pageContainerElm, 'width') || window.innerWidth || 0;\n      let maxHeight = options && options.maxHeight || undefined;\n      let minHeight = (options && options.minHeight !== undefined) ? options.minHeight : DATAGRID_MIN_HEIGHT;\n      let maxWidth = options && options.maxWidth || undefined;\n      let minWidth = (options && options.minWidth !== undefined) ? options.minWidth : DATAGRID_MIN_WIDTH;\n\n      let newHeight = availableHeight;\n      let newWidth = (options && options.rightPadding) ? availableWidth - options.rightPadding : availableWidth;\n\n      // optionally (when defined), make sure that grid height & width are within their thresholds\n      if (newHeight < minHeight) {\n        newHeight = minHeight;\n      }\n      if (maxHeight && newHeight > maxHeight) {\n        newHeight = maxHeight;\n      }\n      if (newWidth < minWidth) {\n        newWidth = minWidth;\n      }\n      if (maxWidth && newWidth > maxWidth) {\n        newWidth = maxWidth;\n      }\n\n      // return the new dimensions unless a fixed height/width was defined\n      return {\n        height: _fixedHeight || newHeight,\n        width: _fixedWidth || newWidth\n      };\n    }\n\n    /** Destroy function when element is destroyed */\n    function destroy() {\n      _self.onGridBeforeResize.unsubscribe();\n      _self.onGridAfterResize.unsubscribe();\n      _bindingEventService.unbindAll();\n    }\n\n    /**\n    * Return the last resize dimensions used by the service\n    * @return {object} last dimensions (height: number, width: number)\n    */\n    function getLastResizeDimensions() {\n      return _lastDimensions;\n    }\n\n    /**\n     * Provide the possibility to pause the resizer for some time, until user decides to re-enabled it later if he wish to.\n     * @param {boolean} isResizePaused are we pausing the resizer?\n     */\n    function pauseResizer(isResizePaused) {\n      _resizePaused = isResizePaused;\n    }\n\n    /**\n     * Resize the datagrid to fit the browser height & width.\n     * @param {number} delay to wait before resizing, defaults to 0 (in milliseconds)\n     * @param {object} newSizes can optionally be passed (height: number, width: number)\n     * @param {object} event that triggered the resize, defaults to null\n     * @return If the browser supports it, we can return a Promise that would resolve with the new dimensions\n     */\n    function resizeGrid(delay, newSizes, event) {\n      // because of the javascript async nature, we might want to delay the resize a little bit\n      delay = delay || 0;\n\n      // return a Promise when supported by the browser\n      if (typeof Promise === 'function') {\n        return new Promise(function (resolve) {\n          if (delay > 0) {\n            clearTimeout(_timer);\n            _timer = setTimeout(function () {\n              resolve(resizeGridCallback(newSizes, event));\n            }, delay);\n          } else {\n            resolve(resizeGridCallback(newSizes, event));\n          }\n        });\n      } else {\n        // OR no return when Promise isn't supported\n        if (delay > 0) {\n          clearTimeout(_timer);\n          _timer = setTimeout(function () {\n            resizeGridCallback(newSizes, event);\n          }, delay);\n        } else {\n          resizeGridCallback(newSizes, event);\n        }\n      }\n    }\n\n    function resizeGridCallback(newSizes, event) {\n      let lastDimensions = resizeGridWithDimensions(newSizes);\n      _self.onGridAfterResize.notify({ grid: _grid, dimensions: lastDimensions }, event, _self);\n      return lastDimensions;\n    }\n\n    function resizeGridWithDimensions(newSizes) {\n      // calculate the available sizes with minimum height defined as a varant\n      let availableDimensions = calculateGridNewDimensions();\n\n      if ((newSizes || availableDimensions) && _gridDomElm) {\n        try {\n          // get the new sizes, if new sizes are passed (not 0), we will use them else use available space\n          // basically if user passes 1 of the dimension, let say he passes just the height,\n          // we will use the height as a fixed height but the width will be resized by it's available space\n          let newHeight = (newSizes && newSizes.height) ? newSizes.height : availableDimensions.height;\n          let newWidth = (newSizes && newSizes.width) ? newSizes.width : availableDimensions.width;\n\n          // apply these new height/width to the datagrid\n          if (!_gridOptions.autoHeight) {\n            _gridDomElm.style.height = `${newHeight}px`;\n          }\n          _gridDomElm.style.width = `${newWidth}px`;\n          if (_gridContainerElm) {\n            _gridContainerElm.style.width = `${newWidth}px`;\n          }\n\n          // resize the slickgrid canvas on all browser except some IE versions\n          // exclude all IE below IE11\n          // IE11 wants to be a better standard (W3C) follower (finally) they even changed their appName output to also have 'Netscape'\n          if (new RegExp('MSIE [6-8]').exec(navigator.userAgent) === null && _grid && _grid.resizeCanvas) {\n            _grid.resizeCanvas();\n          }\n\n          // also call the grid auto-size columns so that it takes available when going bigger\n          if (_gridOptions && _gridOptions.enableAutoSizeColumns && _grid.autosizeColumns) {\n            // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree) to avoid SlickGrid error \"missing stylesheet\"\n            if (_gridUid && document.querySelector(`.${_gridUid}`)) {\n              _grid.autosizeColumns();\n            }\n          }\n\n          // keep last resized dimensions & resolve them to the Promise\n          _lastDimensions = {\n            height: newHeight,\n            width: newWidth\n          };\n        } catch (e) {\n          destroy();\n        }\n      }\n\n      return _lastDimensions;\n    }\n\n  Utils.extend(this, {\n      \"init\": init,\n      \"destroy\": destroy,\n      \"pluginName\": \"Resizer\",\n      \"bindAutoResizeDataGrid\": bindAutoResizeDataGrid,\n      \"getLastResizeDimensions\": getLastResizeDimensions,\n      \"pauseResizer\": pauseResizer,\n      \"resizeGrid\": resizeGrid,\n      \"setOptions\": setOptions,\n\n    \"onGridAfterResize\": new SlickEvent(),\n    \"onGridBeforeResize\": new SlickEvent()\n    });\n  }\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(true, window, {\n    Slick: {\n      Plugins: {\n        Resizer\n      }\n    }\n  });\n}\n\n"],
  "mappings": "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",
  "names": []
}
