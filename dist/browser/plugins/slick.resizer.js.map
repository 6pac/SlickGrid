{
  "version": 3,
  "sources": ["../../../src/plugins/slick.resizer.ts"],
  "sourcesContent": ["import { BindingEventService as BindingEventService_, Event as SlickEvent_, Utils as Utils_ } from '../slick.core';\nimport type { GridOption, GridSize, ResizerOption } from '../models/index';\nimport type { SlickGrid } from '../slick.grid';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\nconst BindingEventService = IIFE_ONLY ? Slick.BindingEventService : BindingEventService_;\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\n// define some constants, height/width are in pixels\nconst DATAGRID_MIN_HEIGHT = 180;\nconst DATAGRID_MIN_WIDTH = 300;\nconst DATAGRID_BOTTOM_PADDING = 20;\n\n/***\n * A Resizer plugin that can be used to auto-resize a grid and/or resize with fixed dimensions.\n * When fixed height is defined, it will auto-resize only the width and vice versa with the width defined.\n * You can also choose to use the flag \"enableAutoSizeColumns\" if you want to the plugin to\n * automatically call the grid \"autosizeColumns()\" method after each resize.\n *\n * USAGE:\n *\n * Add the \"slick.resizer.js\" file and register it with the grid.\n *\n * You can specify certain options as arguments when instantiating the plugin like so:\n * var resizer = new Slick.Plugins.Resizer({\n *   container: '#gridContainer',\n *   rightPadding: 15,\n *   bottomPadding: 20,\n *   minHeight: 180,\n *   minWidth: 300,\n * });\n * grid.registerPlugin(resizer);\n *\n *\n * The plugin exposes the following events:\n *\n *    onGridAfterResize:  Fired after the grid got resized.  You can customize the menu or dismiss it by returning false.\n *        Event args:\n *            grid:       Reference to the grid.\n *            dimensions: Resized grid dimensions used\n *\n *    onGridBeforeResize:   Fired before the grid gets resized.  You can customize the menu or dismiss it by returning false.\n *        Event args:\n *            grid:     Reference to the grid.\n *\n *\n * @param {Object} options available plugin options that can be passed in the constructor:\n *   container:      (REQUIRED) DOM element selector of the page container, basically what element in the page will be used to calculate the available space\n *   gridContainer:             DOM element selector of the grid container, optional but when provided it will be resized with same size as the grid (typically a container holding the grid and extra custom footer/pagination)\n *   applyResizeToContainer:    Defaults to false, do we want to apply the resized dimentions to the grid container as well?\n *   rightPadding:              Defaults to 0, right side padding to remove from the total dimension\n *   bottomPadding:             Defaults to 20, bottom padding to remove from the total dimension\n *   minHeight:                 Defaults to 180, minimum height of the grid\n *   minWidth:                  Defaults to 300, minimum width of the grid\n *   maxHeight:                 Maximum height of the grid\n *   maxWidth:                  Maximum width of the grid\n *   calculateAvailableSizeBy:  Defaults to \"window\", which DOM element (\"container\" or \"window\") are we using to calculate the available size for the grid?\n *\n * @class Slick.Plugins.Resizer\n */\n\nexport class SlickResizer {\n  // --\n  // public API\n  pluginName = 'Resizer' as const;\n  onGridAfterResize = new SlickEvent<{ grid: SlickGrid; dimensions: GridSize; }>('onGridAfterResize');\n  onGridBeforeResize = new SlickEvent<{ grid: SlickGrid; }>('onGridBeforeResize');\n\n  // --\n  // protected props\n  protected _bindingEventService: BindingEventService_;\n  protected _fixedHeight?: number | null;\n  protected _fixedWidth?: number | null;\n  protected _grid!: SlickGrid;\n  protected _gridDomElm!: HTMLElement;\n  protected _gridContainerElm!: HTMLElement;\n  protected _pageContainerElm!: HTMLElement;\n  protected _gridOptions!: GridOption;\n  protected _gridUid = '';\n  protected _lastDimensions?: GridSize;\n  protected _resizePaused = false;\n  protected _timer!: NodeJS.Timeout;\n  protected _options: ResizerOption;\n  protected _defaults: ResizerOption = {\n    bottomPadding: 20,\n    applyResizeToContainer: false,\n    minHeight: 180,\n    minWidth: 300,\n    rightPadding: 0\n  };\n\n  constructor(options: Partial<ResizerOption>, fixedDimensions?: { height?: number; width?: number; }) {\n    this._bindingEventService = new BindingEventService();\n    this._options = Utils.extend(true, {}, this._defaults, options);\n    if (fixedDimensions) {\n      this._fixedHeight = fixedDimensions.height;\n      this._fixedWidth = fixedDimensions.width;\n    }\n  }\n\n  setOptions(newOptions: Partial<ResizerOption>) {\n    this._options = Utils.extend(true, {}, this._defaults, this._options, newOptions);\n  }\n\n  init(grid: SlickGrid) {\n    this.setOptions(this._options);\n    this._grid = grid;\n    this._gridOptions = this._grid.getOptions();\n    this._gridUid = this._grid.getUID();\n    this._gridDomElm = this._grid.getContainerNode();\n    this._pageContainerElm = typeof this._options.container === 'string'\n      ? document.querySelector(this._options.container) as HTMLElement\n      : this._options.container as HTMLElement;\n\n    if (this._options.gridContainer) {\n      this._gridContainerElm = this._options.gridContainer as HTMLElement;\n    }\n\n    Utils.addSlickEventPubSubWhenDefined(grid.getPubSubService(), this);\n    if (this._gridOptions) {\n      this.bindAutoResizeDataGrid();\n    }\n  }\n\n  /** Bind an auto resize trigger on the datagrid, if that is enable then it will resize itself to the available space\n  * Options: we could also provide a % factor to resize on each height/width independently\n  */\n  bindAutoResizeDataGrid(newSizes?: GridSize) {\n    const gridElmOffset = Utils.offset(this._gridDomElm);\n\n    // if we can't find the grid to resize, return without binding anything\n    if (this._gridDomElm !== undefined || gridElmOffset !== undefined) {\n      // -- 1st resize the datagrid size at first load (we need this because the .on event is not triggered on first load)\n      // -- also we add a slight delay (in ms) so that we resize after the grid render is done\n      this.resizeGrid(0, newSizes, null);\n\n      // -- 2nd bind a trigger on the Window DOM element, so that it happens also when resizing after first load\n      // -- bind auto-resize to Window object only if it exist\n      this._bindingEventService.bind(window, 'resize', (event) => {\n        this.onGridBeforeResize.notify({ grid: this._grid }, event, this);\n\n        // unless the resizer is paused, let's go and resize the grid\n        if (!this._resizePaused) {\n          // for some yet unknown reason, calling the resize twice removes any stuttering/flickering\n          // when changing the height and makes it much smoother experience\n          this.resizeGrid(0, newSizes, event);\n          this.resizeGrid(0, newSizes, event);\n        }\n      });\n    }\n  }\n\n  /**\n   * Calculate the datagrid new height/width from the available space, also consider that a % factor might be applied to calculation\n   */\n  calculateGridNewDimensions(): GridSize | null {\n    const gridElmOffset = Utils.offset(this._gridDomElm);\n\n    if (!window || this._pageContainerElm === undefined || this._gridDomElm === undefined || gridElmOffset === undefined) {\n      return null;\n    }\n\n    // calculate bottom padding\n    const bottomPadding = (this._options?.bottomPadding !== undefined) ? this._options.bottomPadding : DATAGRID_BOTTOM_PADDING;\n\n    let gridHeight = 0;\n    let gridOffsetTop = 0;\n\n    // which DOM element are we using to calculate the available size for the grid?\n    // defaults to \"window\"\n    if (this._options.calculateAvailableSizeBy === 'container') {\n      // uses the container's height to calculate grid height without any top offset\n      gridHeight = Utils.innerSize(this._pageContainerElm, 'height') || 0;\n    } else {\n      // uses the browser's window height with its top offset to calculate grid height\n      gridHeight = window.innerHeight || 0;\n      gridOffsetTop = (gridElmOffset !== undefined) ? gridElmOffset.top : 0;\n    }\n\n    const availableHeight = gridHeight - gridOffsetTop - bottomPadding;\n    const availableWidth = Utils.innerSize(this._pageContainerElm, 'width') || window.innerWidth || 0;\n    const maxHeight = this._options?.maxHeight || undefined;\n    const minHeight = (this._options?.minHeight !== undefined) ? this._options.minHeight : DATAGRID_MIN_HEIGHT;\n    const maxWidth = this._options?.maxWidth || undefined;\n    const minWidth = (this._options?.minWidth !== undefined) ? this._options.minWidth : DATAGRID_MIN_WIDTH;\n\n    let newHeight = availableHeight;\n    let newWidth = (this._options?.rightPadding) ? availableWidth - this._options.rightPadding : availableWidth;\n\n    // optionally (when defined), make sure that grid height & width are within their thresholds\n    if (newHeight < minHeight) {\n      newHeight = minHeight;\n    }\n    if (maxHeight && newHeight > maxHeight) {\n      newHeight = maxHeight;\n    }\n    if (newWidth < minWidth) {\n      newWidth = minWidth;\n    }\n    if (maxWidth && newWidth > maxWidth) {\n      newWidth = maxWidth;\n    }\n\n    // return the new dimensions unless a fixed height/width was defined\n    return {\n      height: this._fixedHeight || newHeight,\n      width: this._fixedWidth || newWidth\n    };\n  }\n\n  /** Destroy function when element is destroyed */\n  destroy() {\n    this.onGridBeforeResize.unsubscribe();\n    this.onGridAfterResize.unsubscribe();\n    this._bindingEventService.unbindAll();\n  }\n\n  /**\n  * Return the last resize dimensions used by the service\n  * @return {object} last dimensions (height: number, width: number)\n  */\n  getLastResizeDimensions() {\n    return this._lastDimensions;\n  }\n\n  /**\n   * Provide the possibility to pause the resizer for some time, until user decides to re-enabled it later if he wish to.\n   * @param {boolean} isResizePaused are we pausing the resizer?\n   */\n  pauseResizer(isResizePaused: boolean) {\n    this._resizePaused = isResizePaused;\n  }\n\n  /**\n   * Resize the datagrid to fit the browser height & width.\n   * @param {number} [delay] to wait before resizing, defaults to 0 (in milliseconds)\n   * @param {object} [newSizes] can optionally be passed (height: number, width: number)\n   * @param {object} [event] that triggered the resize, defaults to null\n   * @return If the browser supports it, we can return a Promise that would resolve with the new dimensions\n   */\n  resizeGrid(delay?: number, newSizes?: GridSize, event?: Event | null): Promise<GridSize | undefined> | void {\n    // because of the javascript async nature, we might want to delay the resize a little bit\n    const resizeDelay = delay || 0;\n\n    // return a Promise when supported by the browser\n    if (typeof Promise === 'function') {\n      return new Promise((resolve) => {\n        if (resizeDelay > 0) {\n          clearTimeout(this._timer);\n          this._timer = setTimeout(() => {\n            resolve(this.resizeGridCallback(newSizes, event));\n          }, resizeDelay);\n        } else {\n          resolve(this.resizeGridCallback(newSizes, event));\n        }\n      });\n    } else {\n      // OR no return when Promise isn't supported\n      if (resizeDelay > 0) {\n        clearTimeout(this._timer);\n        this._timer = setTimeout(() => {\n          this.resizeGridCallback(newSizes, event);\n        }, resizeDelay);\n      } else {\n        this.resizeGridCallback(newSizes, event);\n      }\n    }\n  }\n\n  protected resizeGridCallback(newSizes?: GridSize, event?: Event | null) {\n    const lastDimensions = this.resizeGridWithDimensions(newSizes) as GridSize;\n    this.onGridAfterResize.notify({ grid: this._grid, dimensions: lastDimensions }, event, this);\n    return lastDimensions;\n  }\n\n  protected resizeGridWithDimensions(newSizes?: GridSize): GridSize | undefined {\n    // calculate the available sizes with minimum height defined as a varant\n    const availableDimensions = this.calculateGridNewDimensions();\n\n    if ((newSizes || availableDimensions) && this._gridDomElm) {\n      try {\n        // get the new sizes, if new sizes are passed (not 0), we will use them else use available space\n        // basically if user passes 1 of the dimension, let say he passes just the height,\n        // we will use the height as a fixed height but the width will be resized by it's available space\n        const newHeight = (newSizes?.height) ? newSizes.height : availableDimensions?.height;\n        const newWidth = (newSizes?.width) ? newSizes.width : availableDimensions?.width;\n\n        // apply these new height/width to the datagrid\n        if (!this._gridOptions.autoHeight) {\n          this._gridDomElm.style.height = `${newHeight}px`;\n        }\n        this._gridDomElm.style.width = `${newWidth}px`;\n        if (this._gridContainerElm) {\n          this._gridContainerElm.style.width = `${newWidth}px`;\n        }\n\n        // resize the slickgrid canvas on all browser\n        if (this._grid?.resizeCanvas) {\n          this._grid.resizeCanvas();\n        }\n\n        // also call the grid auto-size columns so that it takes available when going bigger\n        if (this._gridOptions?.enableAutoSizeColumns && this._grid.autosizeColumns) {\n          // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree) to avoid SlickGrid error \"missing stylesheet\"\n          if (this._gridUid && document.querySelector(`.${this._gridUid}`)) {\n            this._grid.autosizeColumns();\n          }\n        }\n\n        // keep last resized dimensions & resolve them to the Promise\n        this._lastDimensions = {\n          height: newHeight,\n          width: newWidth\n        };\n      } catch (e) {\n        this.destroy();\n      }\n    }\n\n    return this._lastDimensions;\n  }\n}\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(true, window, {\n    Slick: {\n      Plugins: {\n        Resizer: SlickResizer\n      }\n    }\n  });\n}\n\n"],
  "mappings": "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",
  "names": []
}
