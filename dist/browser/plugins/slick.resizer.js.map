{
  "version": 3,
  "sources": ["../../../src/plugins/slick.resizer.ts"],
  "sourcesContent": ["import { BindingEventService as BindingEventService_, Event as SlickEvent_, Utils as Utils_ } from '../slick.core.js';\r\nimport type { GridOption, GridSize, ResizerOption } from '../models/index.js';\r\nimport type { SlickGrid } from '../slick.grid.js';\r\n\r\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\r\nconst BindingEventService = IIFE_ONLY ? Slick.BindingEventService : BindingEventService_;\r\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\r\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\r\n\r\n// define some constants, height/width are in pixels\r\nconst DATAGRID_MIN_HEIGHT = 180;\r\nconst DATAGRID_MIN_WIDTH = 300;\r\nconst DATAGRID_BOTTOM_PADDING = 20;\r\n\r\n/***\r\n * A Resizer plugin that can be used to auto-resize a grid and/or resize with fixed dimensions.\r\n * When fixed height is defined, it will auto-resize only the width and vice versa with the width defined.\r\n * You can also choose to use the flag \"enableAutoSizeColumns\" if you want to the plugin to\r\n * automatically call the grid \"autosizeColumns()\" method after each resize.\r\n *\r\n * USAGE:\r\n *\r\n * Add the \"slick.resizer.js\" file and register it with the grid.\r\n *\r\n * You can specify certain options as arguments when instantiating the plugin like so:\r\n * var resizer = new Slick.Plugins.Resizer({\r\n *   container: '#gridContainer',\r\n *   rightPadding: 15,\r\n *   bottomPadding: 20,\r\n *   minHeight: 180,\r\n *   minWidth: 300,\r\n * });\r\n * grid.registerPlugin(resizer);\r\n *\r\n *\r\n * The plugin exposes the following events:\r\n *\r\n *    onGridAfterResize:  Fired after the grid got resized.  You can customize the menu or dismiss it by returning false.\r\n *        Event args:\r\n *            grid:       Reference to the grid.\r\n *            dimensions: Resized grid dimensions used\r\n *\r\n *    onGridBeforeResize:   Fired before the grid gets resized.  You can customize the menu or dismiss it by returning false.\r\n *        Event args:\r\n *            grid:     Reference to the grid.\r\n *\r\n *\r\n * @param {Object} options available plugin options that can be passed in the constructor:\r\n *   container:      (REQUIRED) DOM element selector of the page container, basically what element in the page will be used to calculate the available space\r\n *   gridContainer:             DOM element selector of the grid container, optional but when provided it will be resized with same size as the grid (typically a container holding the grid and extra custom footer/pagination)\r\n *   applyResizeToContainer:    Defaults to false, do we want to apply the resized dimentions to the grid container as well?\r\n *   rightPadding:              Defaults to 0, right side padding to remove from the total dimension\r\n *   bottomPadding:             Defaults to 20, bottom padding to remove from the total dimension\r\n *   minHeight:                 Defaults to 180, minimum height of the grid\r\n *   minWidth:                  Defaults to 300, minimum width of the grid\r\n *   maxHeight:                 Maximum height of the grid\r\n *   maxWidth:                  Maximum width of the grid\r\n *   calculateAvailableSizeBy:  Defaults to \"window\", which DOM element (\"container\" or \"window\") are we using to calculate the available size for the grid?\r\n *\r\n * @class Slick.Plugins.Resizer\r\n */\r\n\r\nexport class SlickResizer {\r\n  // --\r\n  // public API\r\n  pluginName = 'Resizer' as const;\r\n  onGridAfterResize = new SlickEvent<{ grid: SlickGrid; dimensions: GridSize; }>('onGridAfterResize');\r\n  onGridBeforeResize = new SlickEvent<{ grid: SlickGrid; }>('onGridBeforeResize');\r\n\r\n  // --\r\n  // protected props\r\n  protected _bindingEventService: BindingEventService_;\r\n  protected _fixedHeight?: number | null;\r\n  protected _fixedWidth?: number | null;\r\n  protected _grid!: SlickGrid;\r\n  protected _gridDomElm!: HTMLElement;\r\n  protected _gridContainerElm!: HTMLElement;\r\n  protected _pageContainerElm!: HTMLElement;\r\n  protected _gridOptions!: GridOption;\r\n  protected _gridUid = '';\r\n  protected _lastDimensions?: GridSize;\r\n  protected _resizePaused = false;\r\n  protected _timer?: number;\r\n  protected _options: ResizerOption;\r\n  protected _defaults: ResizerOption = {\r\n    bottomPadding: 20,\r\n    applyResizeToContainer: false,\r\n    minHeight: 180,\r\n    minWidth: 300,\r\n    rightPadding: 0\r\n  };\r\n\r\n  constructor(options: Partial<ResizerOption>, fixedDimensions?: { height?: number; width?: number; }) {\r\n    this._bindingEventService = new BindingEventService();\r\n    this._options = Utils.extend(true, {}, this._defaults, options);\r\n    if (fixedDimensions) {\r\n      this._fixedHeight = fixedDimensions.height;\r\n      this._fixedWidth = fixedDimensions.width;\r\n    }\r\n  }\r\n\r\n  setOptions(newOptions: Partial<ResizerOption>) {\r\n    this._options = Utils.extend(true, {}, this._defaults, this._options, newOptions);\r\n  }\r\n\r\n  init(grid: SlickGrid) {\r\n    this.setOptions(this._options);\r\n    this._grid = grid;\r\n    this._gridOptions = this._grid.getOptions();\r\n    this._gridUid = this._grid.getUID();\r\n    this._gridDomElm = this._grid.getContainerNode();\r\n    this._pageContainerElm = typeof this._options.container === 'string'\r\n      ? document.querySelector(this._options.container) as HTMLElement\r\n      : this._options.container as HTMLElement;\r\n\r\n    if (this._options.gridContainer) {\r\n      this._gridContainerElm = this._options.gridContainer as HTMLElement;\r\n    }\r\n\r\n    Utils.addSlickEventPubSubWhenDefined(grid.getPubSubService(), this);\r\n    if (this._gridOptions) {\r\n      this.bindAutoResizeDataGrid();\r\n    }\r\n  }\r\n\r\n  /** Bind an auto resize trigger on the datagrid, if that is enable then it will resize itself to the available space\r\n  * Options: we could also provide a % factor to resize on each height/width independently\r\n  */\r\n  bindAutoResizeDataGrid(newSizes?: GridSize) {\r\n    const gridElmOffset = Utils.offset(this._gridDomElm);\r\n\r\n    // if we can't find the grid to resize, return without binding anything\r\n    if (this._gridDomElm !== undefined || gridElmOffset !== undefined) {\r\n      // -- 1st resize the datagrid size at first load (we need this because the .on event is not triggered on first load)\r\n      // -- also we add a slight delay (in ms) so that we resize after the grid render is done\r\n      this.resizeGrid(0, newSizes, null);\r\n\r\n      // -- 2nd bind a trigger on the Window DOM element, so that it happens also when resizing after first load\r\n      // -- bind auto-resize to Window object only if it exist\r\n      this._bindingEventService.bind(window, 'resize', (event) => {\r\n        this.onGridBeforeResize.notify({ grid: this._grid }, event, this);\r\n\r\n        // unless the resizer is paused, let's go and resize the grid\r\n        if (!this._resizePaused) {\r\n          // for some yet unknown reason, calling the resize twice removes any stuttering/flickering\r\n          // when changing the height and makes it much smoother experience\r\n          this.resizeGrid(0, newSizes, event);\r\n          this.resizeGrid(0, newSizes, event);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate the datagrid new height/width from the available space, also consider that a % factor might be applied to calculation\r\n   */\r\n  calculateGridNewDimensions(): GridSize | null {\r\n    const gridElmOffset = Utils.offset(this._gridDomElm);\r\n\r\n    if (!window || this._pageContainerElm === undefined || this._gridDomElm === undefined || gridElmOffset === undefined) {\r\n      return null;\r\n    }\r\n\r\n    // calculate bottom padding\r\n    const bottomPadding = (this._options?.bottomPadding !== undefined) ? this._options.bottomPadding : DATAGRID_BOTTOM_PADDING;\r\n\r\n    let gridHeight = 0;\r\n    let gridOffsetTop = 0;\r\n\r\n    // which DOM element are we using to calculate the available size for the grid?\r\n    // defaults to \"window\"\r\n    if (this._options.calculateAvailableSizeBy === 'container') {\r\n      // uses the container's height to calculate grid height without any top offset\r\n      gridHeight = Utils.innerSize(this._pageContainerElm, 'height') || 0;\r\n    } else {\r\n      // uses the browser's window height with its top offset to calculate grid height\r\n      gridHeight = window.innerHeight || 0;\r\n      gridOffsetTop = (gridElmOffset !== undefined) ? gridElmOffset.top : 0;\r\n    }\r\n\r\n    const availableHeight = gridHeight - gridOffsetTop - bottomPadding;\r\n    const availableWidth = Utils.innerSize(this._pageContainerElm, 'width') || window.innerWidth || 0;\r\n    const maxHeight = this._options?.maxHeight || undefined;\r\n    const minHeight = (this._options?.minHeight !== undefined) ? this._options.minHeight : DATAGRID_MIN_HEIGHT;\r\n    const maxWidth = this._options?.maxWidth || undefined;\r\n    const minWidth = (this._options?.minWidth !== undefined) ? this._options.minWidth : DATAGRID_MIN_WIDTH;\r\n\r\n    let newHeight = availableHeight;\r\n    let newWidth = (this._options?.rightPadding) ? availableWidth - this._options.rightPadding : availableWidth;\r\n\r\n    // optionally (when defined), make sure that grid height & width are within their thresholds\r\n    if (newHeight < minHeight) {\r\n      newHeight = minHeight;\r\n    }\r\n    if (maxHeight && newHeight > maxHeight) {\r\n      newHeight = maxHeight;\r\n    }\r\n    if (newWidth < minWidth) {\r\n      newWidth = minWidth;\r\n    }\r\n    if (maxWidth && newWidth > maxWidth) {\r\n      newWidth = maxWidth;\r\n    }\r\n\r\n    // return the new dimensions unless a fixed height/width was defined\r\n    return {\r\n      height: this._fixedHeight || newHeight,\r\n      width: this._fixedWidth || newWidth\r\n    };\r\n  }\r\n\r\n  /** Destroy function when element is destroyed */\r\n  destroy() {\r\n    this.onGridBeforeResize.unsubscribe();\r\n    this.onGridAfterResize.unsubscribe();\r\n    this._bindingEventService.unbindAll();\r\n  }\r\n\r\n  /**\r\n  * Return the last resize dimensions used by the service\r\n  * @return {object} last dimensions (height: number, width: number)\r\n  */\r\n  getLastResizeDimensions() {\r\n    return this._lastDimensions;\r\n  }\r\n\r\n  /**\r\n   * Provide the possibility to pause the resizer for some time, until user decides to re-enabled it later if he wish to.\r\n   * @param {boolean} isResizePaused are we pausing the resizer?\r\n   */\r\n  pauseResizer(isResizePaused: boolean) {\r\n    this._resizePaused = isResizePaused;\r\n  }\r\n\r\n  /**\r\n   * Resize the datagrid to fit the browser height & width.\r\n   * @param {number} [delay] to wait before resizing, defaults to 0 (in milliseconds)\r\n   * @param {object} [newSizes] can optionally be passed (height: number, width: number)\r\n   * @param {object} [event] that triggered the resize, defaults to null\r\n   * @return If the browser supports it, we can return a Promise that would resolve with the new dimensions\r\n   */\r\n  resizeGrid(delay?: number, newSizes?: GridSize, event?: Event | null): Promise<GridSize | undefined> | void {\r\n    // because of the javascript async nature, we might want to delay the resize a little bit\r\n    const resizeDelay = delay || 0;\r\n\r\n    // return a Promise when supported by the browser\r\n    if (typeof Promise === 'function') {\r\n      return new Promise((resolve) => {\r\n        if (resizeDelay > 0) {\r\n          window.clearTimeout(this._timer);\r\n          this._timer = window.setTimeout(() => {\r\n            resolve(this.resizeGridCallback(newSizes, event));\r\n          }, resizeDelay);\r\n        } else {\r\n          resolve(this.resizeGridCallback(newSizes, event));\r\n        }\r\n      });\r\n    } else {\r\n      // OR no return when Promise isn't supported\r\n      if (resizeDelay > 0) {\r\n        window.clearTimeout(this._timer);\r\n        this._timer = window.setTimeout(() => {\r\n          this.resizeGridCallback(newSizes, event);\r\n        }, resizeDelay);\r\n      } else {\r\n        this.resizeGridCallback(newSizes, event);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected resizeGridCallback(newSizes?: GridSize, event?: Event | null) {\r\n    const lastDimensions = this.resizeGridWithDimensions(newSizes) as GridSize;\r\n    this.onGridAfterResize.notify({ grid: this._grid, dimensions: lastDimensions }, event, this);\r\n    return lastDimensions;\r\n  }\r\n\r\n  protected resizeGridWithDimensions(newSizes?: GridSize): GridSize | undefined {\r\n    // calculate the available sizes with minimum height defined as a varant\r\n    const availableDimensions = this.calculateGridNewDimensions();\r\n\r\n    if ((newSizes || availableDimensions) && this._gridDomElm) {\r\n      try {\r\n        // get the new sizes, if new sizes are passed (not 0), we will use them else use available space\r\n        // basically if user passes 1 of the dimension, let say he passes just the height,\r\n        // we will use the height as a fixed height but the width will be resized by it's available space\r\n        const newHeight = (newSizes?.height) ? newSizes.height : availableDimensions?.height;\r\n        const newWidth = (newSizes?.width) ? newSizes.width : availableDimensions?.width;\r\n\r\n        // apply these new height/width to the datagrid\r\n        if (!this._gridOptions.autoHeight) {\r\n          this._gridDomElm.style.height = `${newHeight}px`;\r\n        }\r\n        this._gridDomElm.style.width = `${newWidth}px`;\r\n        if (this._gridContainerElm) {\r\n          this._gridContainerElm.style.width = `${newWidth}px`;\r\n        }\r\n\r\n        // resize the slickgrid canvas on all browser\r\n        if (this._grid?.resizeCanvas) {\r\n          this._grid.resizeCanvas();\r\n        }\r\n\r\n        // also call the grid auto-size columns so that it takes available when going bigger\r\n        if (this._gridOptions?.enableAutoSizeColumns && this._grid.autosizeColumns) {\r\n          // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree) to avoid SlickGrid error \"missing stylesheet\"\r\n          if (this._gridUid && document.querySelector(`.${this._gridUid}`)) {\r\n            this._grid.autosizeColumns();\r\n          }\r\n        }\r\n\r\n        // keep last resized dimensions & resolve them to the Promise\r\n        this._lastDimensions = {\r\n          height: newHeight,\r\n          width: newWidth\r\n        };\r\n      } catch (e) {\r\n        this.destroy();\r\n      }\r\n    }\r\n\r\n    return this._lastDimensions;\r\n  }\r\n}\r\n\r\n// extend Slick namespace on window object when building as iife\r\nif (IIFE_ONLY && window.Slick) {\r\n  Utils.extend(true, window, {\r\n    Slick: {\r\n      Plugins: {\r\n        Resizer: SlickResizer\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": []
}
