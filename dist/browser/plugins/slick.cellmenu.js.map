{
  "version": 3,
  "sources": ["../../../src/plugins/slick.cellmenu.js"],
  "sourcesContent": ["import {\n  BindingEventService as BindingEventService_,\n  Event as SlickEvent_,\n  EventData as EventData_,\n  EventHandler as EventHandler_,\n  Utils as Utils_\n} from '../slick.core';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (cjs/esm)\nconst BindingEventService = IIFE_ONLY ? Slick.BindingEventService : BindingEventService_;\nconst SlickEvent = IIFE_ONLY ? Slick.Event : SlickEvent_;\nconst EventData = IIFE_ONLY ? Slick.EventData : EventData_;\nconst EventHandler = IIFE_ONLY ? Slick.EventHandler : EventHandler_;\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\n/***\n   * A plugin to add Menu on a Cell click (click on the cell that has the cellMenu object defined)\n   * The \"cellMenu\" is defined in a Column Definition object\n   * Similar to the ContextMenu plugin (could be used in combo),\n   * except that it subscribes to the cell \"onClick\" event (regular mouse click or touch).\n   *\n   * A general use of this plugin is for an Action Dropdown Menu to do certain things on the row that was clicked\n   * You can use it to change the cell data property through a list of Options AND/OR through a list of Commands.\n   *\n   * USAGE:\n   *\n   * Add the slick.cellMenu.(js|css) files and register it with the grid.\n   *\n   * To specify a menu in a column header, extend the column definition like so:\n   * var cellMenuPlugin = new Slick.Plugins.CellMenu(columns, grid, options);\n   *\n   * Available cellMenu options, by defining a cellMenu object:\n   *\n   *  var columns = [\n   *    {\n   *      id: \"action\", name: \"Action\", field: \"action\", formatter: fakeButtonFormatter,\n   *      cellMenu: {\n   *        optionTitle: \"Change Effort Driven\",\n   *        optionItems: [\n   *          { option: true, title: \"True\", iconCssClass: 'checkmark' },\n   *          { option: false, title: \"False\" }\n   *        ],\n   *        commandTitle: \"Commands\",\n   *        commandItems: [\n   *          { command: \"delete-row\", title: \"Delete Row\", iconCssClass: \"sgi sgi-close\", cssClass: 'bold', textCssClass: \"red\" },\n   *          { divider: true },\n   *          \"divider\" // you can pass \"divider\" as a string or an object\n   *          { command: \"help\", title: \"Help\", iconCssClass: \"icon-help\" },\n   *          { command: \"help\", title: \"Disabled Command\", disabled: true },\n   *        ],\n   *      }\n   *    }\n   *  ];\n   *\n   *\n   * Available cellMenu properties:\n   *    commandTitle:               Title of the Command section (optional)\n   *    commandItems:               Array of Command item objects (command/title pair)\n   *    optionTitle:                Title of the Option section (optional)\n   *    optionItems:                Array of Options item objects (option/title pair)\n   *    hideCloseButton:            Hide the Close button on top right (defaults to false)\n   *    hideCommandSection:         Hide the Commands section even when the commandItems array is filled (defaults to false)\n   *    hideMenuOnScroll:           Do we want to hide the Cell Menu when a scrolling event occurs (defaults to true)?\n   *    hideOptionSection:          Hide the Options section even when the optionItems array is filled (defaults to false)\n   *    maxHeight:                  Maximum height that the drop menu will have, can be a number (250) or text (\"none\")\n   *    width:                      Width that the drop menu will have, can be a number (250) or text (defaults to \"auto\")\n   *    autoAdjustDrop:             Auto-align dropup or dropdown menu to the left or right depending on grid viewport available space (defaults to true)\n   *    autoAdjustDropOffset:       Optionally add an offset to the auto-align of the drop menu (defaults to 0)\n   *    autoAlignSide:              Auto-align drop menu to the left or right depending on grid viewport available space (defaults to true)\n   *    autoAlignSideOffset:        Optionally add an offset to the left/right side auto-align (defaults to 0)\n   *    menuUsabilityOverride:      Callback method that user can override the default behavior of enabling/disabling the menu from being usable (must be combined with a custom formatter)\n   *\n   *\n   * Available menu Command/Option item properties:\n   *    action:                     Optionally define a callback function that gets executed when item is chosen (and/or use the onCommand event)\n   *    command:                    A command identifier to be passed to the onCommand event handlers (when using \"commandItems\").\n   *    option:                     An option to be passed to the onOptionSelected event handlers (when using \"optionItems\").\n   *    title:                      Menu item text label.\n   *    divider:                    Boolean which tells if the current item is a divider, not an actual command. You could also pass \"divider\" instead of an object\n   *    disabled:                   Whether the item/command is disabled.\n   *    hidden:                     Whether the item/command is hidden.\n   *    tooltip:                    Item tooltip.\n   *    cssClass:                   A CSS class to be added to the menu item container.\n   *    iconCssClass:               A CSS class to be added to the menu item icon.\n   *    textCssClass:               A CSS class to be added to the menu item text.\n   *    iconImage:                  A url to the icon image.\n   *    itemVisibilityOverride:     Callback method that user can override the default behavior of showing/hiding an item from the list\n   *    itemUsabilityOverride:      Callback method that user can override the default behavior of enabling/disabling an item from the list\n   *\n   *\n   * The plugin exposes the following events:\n   *\n   *    onAfterMenuShow: Fired after the menu is shown.  You can customize the menu or dismiss it by returning false.\n   *        Event args:\n   *            cell:         Cell or column index\n   *            row:          Row index\n   *            grid:         Reference to the grid.\n   *\n   *    onBeforeMenuShow: Fired before the menu is shown.  You can customize the menu or dismiss it by returning false.\n   *        Event args:\n   *            cell:         Cell or column index\n   *            row:          Row index\n   *            grid:         Reference to the grid.\n   *\n   *    onBeforeMenuClose: Fired when the menu is closing.\n   *        Event args:\n   *            cell:         Cell or column index\n   *            row:          Row index\n   *            grid:         Reference to the grid.\n   *            menu:         Menu DOM element\n   *\n   *    onCommand: Fired on menu option clicked from the Command items list\n   *        Event args:\n   *            cell:         Cell or column index\n   *            row:          Row index\n   *            grid:         Reference to the grid.\n   *            command:      Menu command identified.\n   *            item:         Menu item selected\n   *            column:    Cell Column definition\n   *            dataContext:  Cell Data Context (data object)\n   *\n   *    onOptionSelected: Fired on menu option clicked from the Option items list\n   *        Event args:\n   *            cell:         Cell or column index\n   *            row:          Row index\n   *            grid:         Reference to the grid.\n   *            option:       Menu option selected.\n   *            item:         Menu item selected\n   *            column:    Cell Column definition\n   *            dataContext:  Cell Data Context (data object)\n   *\n   *\n   * @param options {Object} Cell Menu Options\n   * @class Slick.Plugins.CellMenu\n   * @constructor\n   */\nexport function CellMenu(optionProperties) {\n    let _cellMenuProperties;\n    let _currentCell = -1;\n    let _currentRow = -1;\n    let _grid;\n    let _gridOptions;\n    let _gridUid = \"\";\n  let _handler = new EventHandler();\n    let _self = this;\n    let _commandTitleElm;\n    let _optionTitleElm;\n    let _menuElm;\n  let _bindingEventService = new BindingEventService();\n\n    let _defaults = {\n      autoAdjustDrop: true,     // dropup/dropdown\n      autoAlignSide: true,      // left/right\n      autoAdjustDropOffset: 0,\n      autoAlignSideOffset: 0,\n      hideMenuOnScroll: true,\n      maxHeight: \"none\",\n      width: \"auto\",\n    };\n\n    function init(grid) {\n      _grid = grid;\n      _gridOptions = grid.getOptions();\n      _cellMenuProperties = Utils.extend({}, _defaults, optionProperties);\n      _gridUid = (grid && grid.getUID) ? grid.getUID() : \"\";\n      _handler.subscribe(_grid.onClick, handleCellClick);\n      if (_cellMenuProperties.hideMenuOnScroll) {\n        _handler.subscribe(_grid.onScroll, destroyMenu);\n      }\n    }\n\n    function setOptions(newOptions) {\n      _cellMenuProperties = Utils.extend({}, _cellMenuProperties, newOptions);\n    }\n\n    function destroy() {\n      _self.onAfterMenuShow.unsubscribe();\n      _self.onBeforeMenuShow.unsubscribe();\n      _self.onBeforeMenuClose.unsubscribe();\n      _self.onCommand.unsubscribe();\n      _self.onOptionSelected.unsubscribe();\n      _handler.unsubscribeAll();\n      _bindingEventService.unbindAll();\n\n      if (_menuElm && _menuElm.remove) {\n        _menuElm.remove();\n      }\n      _commandTitleElm = null;\n      _optionTitleElm = null;\n      _menuElm = null;\n    }\n\n    function createMenu(e) {\n      let cell = _grid.getCellFromEvent(e);\n      _currentCell = cell && cell.cell;\n      _currentRow = cell && cell.row;\n      let columnDef = _grid.getColumns()[_currentCell];\n      let dataContext = _grid.getDataItem(_currentRow);\n\n      let commandItems = _cellMenuProperties.commandItems || [];\n      let optionItems = _cellMenuProperties.optionItems || [];\n\n      // make sure there's at least something to show before creating the Cell Menu\n      if (!columnDef || !columnDef.cellMenu || (!commandItems.length && !optionItems.length)) {\n        return;\n      }\n\n      // delete any prior Cell Menu\n      destroyMenu();\n\n      // Let the user modify the menu or cancel altogether,\n      // or provide alternative menu implementation.\n      if (_self.onBeforeMenuShow.notify({\n        \"cell\": _currentCell,\n        \"row\": _currentRow,\n        \"grid\": _grid\n      }, e, _self).getReturnValue() == false) {\n        return;\n      }\n\n      // create a new cell menu\n      let maxHeight = isNaN(_cellMenuProperties.maxHeight) ? _cellMenuProperties.maxHeight : _cellMenuProperties.maxHeight + \"px\";\n      let width = isNaN(_cellMenuProperties.width) ? _cellMenuProperties.width : _cellMenuProperties.width + \"px\";\n\n      _menuElm = document.createElement('div');\n      _menuElm.className = `slick-cell-menu ${_gridUid}`;\n      _menuElm.role = 'menu';\n      _menuElm.style.width = width;\n      _menuElm.style.maxHeight = maxHeight;\n      _menuElm.style.top = `${e.pageY + 5}px`;\n      _menuElm.style.left = `${e.pageX}px`;\n      _menuElm.style.display = 'none';\n\n      const closeButtonElm = document.createElement('button');\n      closeButtonElm.type = 'button';\n      closeButtonElm.className = 'close';\n      closeButtonElm.dataset.dismiss = 'slick-cell-menu';\n      closeButtonElm.ariaLabel = 'Close';\n\n      const spanCloseElm = document.createElement('span');\n      spanCloseElm.className = 'close';\n      spanCloseElm.ariaHidden = 'true';\n      spanCloseElm.innerHTML = '&times;';\n      closeButtonElm.appendChild(spanCloseElm);\n\n      // -- Option List section\n      if (!_cellMenuProperties.hideOptionSection && optionItems.length > 0) {\n        const optionMenuElm = document.createElement('div');\n        optionMenuElm.className = 'slick-cell-menu-option-list';\n        optionMenuElm.role = 'menu';\n\n        if (!_cellMenuProperties.hideCloseButton) {\n          _bindingEventService.bind(closeButtonElm, 'click', handleCloseButtonClicked);\n          _menuElm.appendChild(closeButtonElm);\n        }\n        _menuElm.appendChild(optionMenuElm)\n\n        populateOptionItems(\n          _cellMenuProperties,\n          optionMenuElm,\n          optionItems,\n          { cell: _currentCell, row: _currentRow, column: columnDef, dataContext: dataContext, grid: _grid }\n        );\n      }\n\n      // -- Command List section\n      if (!_cellMenuProperties.hideCommandSection && commandItems.length > 0) {\n        const commandMenuElm = document.createElement('div');\n        commandMenuElm.className = 'slick-cell-menu-command-list';\n        commandMenuElm.role = 'menu';\n\n        if (!_cellMenuProperties.hideCloseButton && (optionItems.length === 0 || _cellMenuProperties.hideOptionSection)) {\n          _bindingEventService.bind(closeButtonElm, 'click', handleCloseButtonClicked);\n          _menuElm.appendChild(closeButtonElm);\n        }\n\n        _menuElm.appendChild(commandMenuElm);\n        populateCommandItems(\n          _cellMenuProperties,\n          commandMenuElm,\n          commandItems,\n          { cell: _currentCell, row: _currentRow, column: columnDef, dataContext: dataContext, grid: _grid }\n        );\n      }\n\n      _menuElm.style.display = 'block';\n      document.body.appendChild(_menuElm);\n\n      if (_self.onAfterMenuShow.notify({\n        \"cell\": _currentCell,\n        \"row\": _currentRow,\n        \"grid\": _grid\n      }, e, _self).getReturnValue() == false) {\n        return;\n      }\n\n      return _menuElm;\n    }\n\n    function handleCloseButtonClicked(e) {\n      if (!e.defaultPrevented) {\n        destroyMenu(e);\n      }\n    }\n\n    function destroyMenu(e, args) {\n      _menuElm = _menuElm || document.querySelector(\".slick-cell-menu.\" + _gridUid);\n\n      if (_menuElm && _menuElm.remove) {\n        if (_self.onBeforeMenuClose.notify({\n          \"cell\": args && args.cell,\n          \"row\": args && args.row,\n          \"grid\": _grid,\n          \"menu\": _menuElm\n        }, e, _self).getReturnValue() == false) {\n          return;\n        }\n        _menuElm.remove();\n        _menuElm = null;\n      }\n    }\n\n    /**\n     * Reposition the menu drop (up/down) and the side (left/right)\n     * @param {*} event\n     */\n    function repositionMenu(e) {\n      const parentElm = e.target.closest('.slick-cell');\n      const parentOffset = parentElm && Utils.offset(parentElm);\n      let menuOffsetLeft = parentElm ? parentOffset.left : e.pageX;\n      let menuOffsetTop = parentElm ? parentOffset.top : e.pageY;\n      const parentCellWidth = parentElm.offsetWidth || 0;\n      const menuHeight = _menuElm && _menuElm.offsetHeight || 0;\n      const menuWidth = _menuElm && _menuElm.offsetWidth || _cellMenuProperties.width || 0;\n      const rowHeight = _gridOptions.rowHeight;\n      const dropOffset = _cellMenuProperties.autoAdjustDropOffset;\n      const sideOffset = _cellMenuProperties.autoAlignSideOffset;\n\n      // if autoAdjustDrop is enable, we first need to see what position the drop will be located (defaults to bottom)\n      // without necessary toggling it's position just yet, we just want to know the future position for calculation\n      if (_cellMenuProperties.autoAdjustDrop) {\n        // since we reposition menu below slick cell, we need to take it in consideration and do our calculation from that element\n        const spaceBottom = Utils.calculateAvailableSpace(parentElm).bottom;\n        const spaceTop = Utils.calculateAvailableSpace(parentElm).top;\n        const spaceBottomRemaining = spaceBottom + dropOffset - rowHeight;\n        const spaceTopRemaining = spaceTop - dropOffset + rowHeight;\n        const dropPosition = (spaceBottomRemaining < menuHeight && spaceTopRemaining > spaceBottomRemaining) ? 'top' : 'bottom';\n        if (dropPosition === 'top') {\n          _menuElm.classList.remove('dropdown');\n          _menuElm.classList.add('dropup');\n          menuOffsetTop = menuOffsetTop - menuHeight - dropOffset;\n        } else {\n          _menuElm.classList.remove('dropup');\n          _menuElm.classList.add('dropdown');\n          menuOffsetTop = menuOffsetTop + rowHeight + dropOffset;\n        }\n      }\n\n      // when auto-align is set, it will calculate whether it has enough space in the viewport to show the drop menu on the right (default)\n      // if there isn't enough space on the right, it will automatically align the drop menu to the left (defaults to the right)\n      // to simulate an align left, we actually need to know the width of the drop menu\n      if (_cellMenuProperties.autoAlignSide) {\n        let gridPos = _grid.getGridPosition();\n        let dropSide = ((menuOffsetLeft + menuWidth) >= gridPos.width) ? 'left' : 'right';\n        if (dropSide === 'left') {\n          _menuElm.classList.remove('dropright');\n          _menuElm.classList.add('dropleft');\n          menuOffsetLeft = (menuOffsetLeft - (menuWidth - parentCellWidth) - sideOffset);\n        } else {\n          _menuElm.classList.remove('dropleft');\n          _menuElm.classList.add('dropright');\n          menuOffsetLeft = menuOffsetLeft + sideOffset;\n        }\n      }\n\n      // ready to reposition the menu\n      _menuElm.style.top = `${menuOffsetTop}px`;\n      _menuElm.style.left = `${menuOffsetLeft}px`;\n    }\n\n    function handleCellClick(e, args) {\n      if (e instanceof EventData)\n        e = e.getNativeEvent();\n\n      let cell = _grid.getCellFromEvent(e);\n      let dataContext = _grid.getDataItem(cell.row);\n      let columnDef = _grid.getColumns()[cell.cell];\n\n      // prevent event from bubbling but only on column that has a cell menu defined\n      if (columnDef && columnDef.cellMenu) {\n        e.preventDefault();\n      }\n\n      // merge the cellMenu of the column definition with the default properties\n      _cellMenuProperties = Utils.extend({}, _cellMenuProperties, columnDef.cellMenu);\n\n      // run the override function (when defined), if the result is false it won't go further\n      if (!args) {\n        args = {};\n      }\n      args.columnDef = columnDef;\n      args.dataContext = dataContext;\n      args.grid = _grid;\n      if (!runOverrideFunctionWhenExists(_cellMenuProperties.menuUsabilityOverride, args)) {\n        return;\n      }\n\n      // create the DOM element\n      _menuElm = createMenu(e, args);\n\n      // reposition the menu to where the user clicked\n      if (_menuElm) {\n        repositionMenu(e);\n        _menuElm.setAttribute('aria-expanded', 'true');\n        _menuElm.style.display = 'block';\n      }\n\n      // Hide the menu on outside click.\n      _bindingEventService.bind(document.body, 'mousedown', handleBodyMouseDown.bind(this));\n    }\n\n    function handleBodyMouseDown(e) {\n      if (_menuElm != e.target && !(_menuElm && _menuElm.contains(e.target))) {\n        if (!e.defaultPrevented) {\n          closeMenu(e, { cell: _currentCell, row: _currentRow });\n        }\n      }\n    }\n\n    function closeMenu(e, args) {\n      if (_menuElm) {\n        if (_self.onBeforeMenuClose.notify({\n          \"cell\": args && args.cell,\n          \"row\": args && args.row,\n          \"grid\": _grid,\n          \"menu\": _menuElm\n        }, e, _self).getReturnValue() == false) {\n          return;\n        }\n        if (_menuElm && _menuElm.remove) {\n          _menuElm.remove();\n          _menuElm = null;\n        }\n      }\n    }\n\n    /** Construct the Option Items section. */\n    function populateOptionItems(cellMenu, optionMenuElm, optionItems, args) {\n      if (!args || !optionItems || !cellMenu) {\n        return;\n      }\n\n      // user could pass a title on top of the Options section\n      if (cellMenu && cellMenu.optionTitle) {\n        _optionTitleElm = document.createElement('div');\n        _optionTitleElm.className = 'title';\n        _optionTitleElm.textContent = cellMenu.optionTitle;\n        optionMenuElm.appendChild(_optionTitleElm);\n      }\n\n      for (let i = 0, ln = optionItems.length; i < ln; i++) {\n        let addClickListener = true;\n        let item = optionItems[i];\n\n        // run each override functions to know if the item is visible and usable\n        let isItemVisible = runOverrideFunctionWhenExists(item.itemVisibilityOverride, args);\n        let isItemUsable = runOverrideFunctionWhenExists(item.itemUsabilityOverride, args);\n\n        // if the result is not visible then there's no need to go further\n        if (!isItemVisible) {\n          continue;\n        }\n\n        // when the override is defined, we need to use its result to update the disabled property\n        // so that \"handleMenuItemOptionClick\" has the correct flag and won't trigger an option clicked event\n        if (Object.prototype.hasOwnProperty.call(item, \"itemUsabilityOverride\")) {\n          item.disabled = isItemUsable ? false : true;\n        }\n\n        const liElm = document.createElement('div');\n        liElm.className = 'slick-cell-menu-item';\n        liElm.role = 'menuitem';\n\n        if (item.divider || item === \"divider\") {\n          liElm.classList.add(\"slick-cell-menu-item-divider\");\n          addClickListener = false;\n        }\n\n        // if the item is disabled then add the disabled css class\n        if (item.disabled || !isItemUsable) {\n          liElm.classList.add(\"slick-cell-menu-item-disabled\");\n        }\n\n        // if the item is hidden then add the hidden css class\n        if (item.hidden) {\n          liElm.classList.add(\"slick-cell-menu-item-hidden\");\n        }\n\n        if (item.cssClass) {\n          liElm.classList.add(...item.cssClass.split(' '));\n        }\n\n        if (item.tooltip) {\n          liElm.title = item.tooltip;\n        }\n\n        const iconElm = document.createElement('div');\n        iconElm.className = 'slick-cell-menu-icon';\n\n        liElm.appendChild(iconElm);\n\n        if (item.iconCssClass) {\n          iconElm.classList.add(...item.iconCssClass.split(' '));\n        }\n\n        if (item.iconImage) {\n          iconElm.style.backgroundImage = \"url(\" + item.iconImage + \")\";\n        }\n\n        const textElm = document.createElement('span');\n        textElm.className = 'slick-cell-menu-content';\n        textElm.textContent = item.title;\n\n        liElm.appendChild(textElm);\n\n        if (item.textCssClass) {\n          textElm.classList.add(...item.textCssClass.split(' '));\n        }\n\n        optionMenuElm.appendChild(liElm);\n\n        if (addClickListener) {\n          _bindingEventService.bind(liElm, 'click', handleMenuItemOptionClick.bind(this, item));\n        }\n      }\n    }\n\n    /** Construct the Command Items section. */\n    function populateCommandItems(cellMenu, commandMenuElm, commandItems, args) {\n      if (!args || !commandItems || !cellMenu) {\n        return;\n      }\n\n      // user could pass a title on top of the Commands section\n      if (cellMenu && cellMenu.commandTitle) {\n        _commandTitleElm = document.createElement('div');\n        _commandTitleElm.className = 'title';\n        _commandTitleElm.textContent = cellMenu.commandTitle;\n        commandMenuElm.appendChild(_commandTitleElm);\n      }\n\n      for (let i = 0, ln = commandItems.length; i < ln; i++) {\n        let addClickListener = true;\n        let item = commandItems[i];\n\n        // run each override functions to know if the item is visible and usable\n        let isItemVisible = runOverrideFunctionWhenExists(item.itemVisibilityOverride, args);\n        let isItemUsable = runOverrideFunctionWhenExists(item.itemUsabilityOverride, args);\n\n        // if the result is not visible then there's no need to go further\n        if (!isItemVisible) {\n          continue;\n        }\n\n        // when the override is defined, we need to use its result to update the disabled property\n        // so that \"handleMenuItemCommandClick\" has the correct flag and won't trigger a command clicked event\n        if (Object.prototype.hasOwnProperty.call(item, \"itemUsabilityOverride\")) {\n          item.disabled = isItemUsable ? false : true;\n        }\n\n        const liElm = document.createElement('div');\n        liElm.className = 'slick-cell-menu-item';\n        liElm.role = 'menuitem';\n\n        if (item.divider || item === \"divider\") {\n          liElm.classList.add(\"slick-cell-menu-item-divider\");\n          addClickListener = false;\n        }\n\n        // if the item is disabled then add the disabled css class\n        if (item.disabled || !isItemUsable) {\n          liElm.classList.add(\"slick-cell-menu-item-disabled\");\n        }\n\n        // if the item is hidden then add the hidden css class\n        if (item.hidden) {\n          liElm.classList.add(\"slick-cell-menu-item-hidden\");\n        }\n\n        if (item.cssClass) {\n          liElm.classList.add(...item.cssClass.split(' '));\n        }\n\n        if (item.tooltip) {\n          liElm.title = item.tooltip;\n        }\n\n        const iconElm = document.createElement('div');\n        iconElm.className = 'slick-cell-menu-icon';\n\n        liElm.appendChild(iconElm);\n\n        if (item.iconCssClass) {\n          iconElm.classList.add(...item.iconCssClass.split(' '));\n        }\n\n        if (item.iconImage) {\n          iconElm.style.backgroundImage = \"url(\" + item.iconImage + \")\";\n        }\n\n        const textElm = document.createElement('span');\n        textElm.className = 'slick-cell-menu-content';\n        textElm.textContent = item.title;\n\n        liElm.appendChild(textElm);\n\n        if (item.textCssClass) {\n          textElm.classList.add(...item.textCssClass.split(' '));\n        }\n\n        commandMenuElm.appendChild(liElm);\n\n        if (addClickListener) {\n          _bindingEventService.bind(liElm, 'click', handleMenuItemCommandClick.bind(this, item));\n        }\n      }\n    }\n\n    function handleMenuItemCommandClick(item, e) {\n      if (!item || item.disabled || item.divider || item === \"divider\") {\n        return;\n      }\n\n      const command = item.command || '';\n      const row = _currentRow;\n      const cell = _currentCell;\n      let columnDef = _grid.getColumns()[cell];\n      let dataContext = _grid.getDataItem(row);\n\n      if (command !== null && command !== \"\") {\n        // user could execute a callback through 2 ways\n        // via the onCommand event and/or an action callback\n        let callbackArgs = {\n          \"cell\": cell,\n          \"row\": row,\n          \"grid\": _grid,\n          \"command\": command,\n          \"item\": item,\n          \"column\": columnDef,\n          \"dataContext\": dataContext\n        };\n        _self.onCommand.notify(callbackArgs, e, _self);\n\n        // execute action callback when defined\n        if (typeof item.action === \"function\") {\n          item.action.call(this, e, callbackArgs);\n        }\n\n        if (!e.defaultPrevented) {\n          closeMenu(e, { cell: cell, row: row });\n        }\n      }\n    }\n\n    function handleMenuItemOptionClick(item, e) {\n      if (!item || item.disabled || item.divider || item === \"divider\") {\n        return;\n      }\n      if (!_grid.getEditorLock().commitCurrentEdit()) {\n        return;\n      }\n\n      const option = item.option !== undefined ? item.option : '';\n      const row = _currentRow;\n      const cell = _currentCell;\n      const columnDef = _grid.getColumns()[cell];\n      const dataContext = _grid.getDataItem(row);\n\n      if (option !== undefined) {\n        // user could execute a callback through 2 ways\n        // via the onOptionSelected event and/or an action callback\n        const callbackArgs = {\n          \"cell\": cell,\n          \"row\": row,\n          \"grid\": _grid,\n          \"option\": option,\n          \"item\": item,\n          \"column\": columnDef,\n          \"dataContext\": dataContext\n        };\n        _self.onOptionSelected.notify(callbackArgs, e, _self);\n\n        // execute action callback when defined\n        if (typeof item.action === \"function\") {\n          item.action.call(this, e, callbackArgs);\n        }\n\n        if (!e.defaultPrevented) {\n          closeMenu(e, { cell: cell, row: row });\n        }\n      }\n    }\n\n    /**\n     * Method that user can pass to override the default behavior.\n     * In order word, user can choose or an item is (usable/visible/enable) by providing his own logic.\n     * @param overrideFn: override function callback\n     * @param args: multiple arguments provided to the override (cell, row, columnDef, dataContext, grid)\n     */\n    function runOverrideFunctionWhenExists(overrideFn, args) {\n      if (typeof overrideFn === 'function') {\n        return overrideFn.call(this, args);\n      }\n      return true;\n    }\n\n  Utils.extend(this, {\n      \"init\": init,\n      \"closeMenu\": destroyMenu,\n      \"destroy\": destroy,\n      \"pluginName\": \"CellMenu\",\n      \"setOptions\": setOptions,\n\n    \"onAfterMenuShow\": new SlickEvent(),\n    \"onBeforeMenuShow\": new SlickEvent(),\n    \"onBeforeMenuClose\": new SlickEvent(),\n    \"onCommand\": new SlickEvent(),\n    \"onOptionSelected\": new SlickEvent()\n    });\n  }\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(true, window, {\n    Slick: {\n      Plugins: {\n        CellMenu\n      }\n    }\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
