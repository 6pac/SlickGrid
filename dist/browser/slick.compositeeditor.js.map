{
  "version": 3,
  "sources": ["../../src/slick.compositeeditor.ts"],
  "sourcesContent": ["import type { Column, CompositeEditorOption, Editor, EditorArguments, HtmlElementPosition } from './models/index';\nimport { Utils as Utils_ } from './slick.core';\n\n// for (iife) load Slick methods from global Slick object, or use imports for (esm)\nconst Utils = IIFE_ONLY ? Slick.Utils : Utils_;\n\n/**\n * A composite SlickGrid editor factory.\n * Generates an editor that is composed of multiple editors for given columns.\n * Individual editors are provided given containers instead of the original cell.\n * Validation will be performed on all editors individually and the results will be aggregated into one\n * validation result.\n *\n *\n * The returned editor will have its prototype set to CompositeEditor, so you can use the \"instanceof\" check.\n *\n * NOTE:  This doesn't work for detached editors since they will be created and positioned relative to the\n *        active cell and not the provided container.\n *\n * @namespace Slick\n * @class CompositeEditor\n * @constructor\n * @param columns {Array} Column definitions from which editors will be pulled.\n * @param containers {Array} Container HTMLElements in which editors will be placed.\n * @param options {Object} Options hash:\n *  validationFailedMsg     -   A generic failed validation message set on the aggregated validation resuls.\n *  validationMsgPrefix     -   Add an optional prefix to each validation message (only the ones shown in the modal form, not the ones in the \"errors\")\n *  modalType               -   Defaults to \"edit\", modal type can 1 of these 3: (create, edit, mass, mass-selection)\n *  hide                    -   A function to be called when the grid asks the editor to hide itself.\n *  show                    -   A function to be called when the grid asks the editor to show itself.\n *  position                -   A function to be called when the grid asks the editor to reposition itself.\n *  destroy                 -   A function to be called when the editor is destroyed.\n */\nexport function SlickCompositeEditor(columns: Column[], containers: Array<HTMLDivElement>, options: CompositeEditorOption) {\n  const defaultOptions = {\n    modalType: 'edit', // available type (create, edit, mass)\n    validationFailedMsg: 'Some of the fields have failed validation',\n    validationMsgPrefix: null,\n    show: null,\n    hide: null,\n    position: null,\n    destroy: null,\n    formValues: {},\n    editors: {}\n  };\n\n  const noop = function () { };\n\n  let firstInvalidEditor: Editor | null = null;\n\n  options = Slick.Utils.extend({}, defaultOptions, options);\n\n  function getContainerBox(i: number) {\n    const c = containers[i];\n    const offset = Slick.Utils.offset(c);\n    const w = Slick.Utils.width(c);\n    const h = Slick.Utils.height(c);\n\n    return {\n      top: (offset?.top ?? 0),\n      left: (offset?.left ?? 0),\n      bottom: (offset?.top ?? 0) + (h || 0),\n      right: (offset?.left ?? 0) + (w || 0),\n      width: w,\n      height: h,\n      visible: true\n    };\n  }\n\n  function editor(args: any[]) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const context: any = this;\n    let editors: Array<Editor & { args: EditorArguments }> = [];\n\n    function init() {\n      let newArgs: any = {};\n      let idx = 0;\n      while (idx < columns.length) {\n        if (columns[idx].editor) {\n          const column = columns[idx];\n          newArgs = Slick.Utils.extend(false, {}, args);\n          newArgs.container = containers[idx];\n          newArgs.column = column;\n          newArgs.position = getContainerBox(idx);\n          newArgs.commitChanges = noop;\n          newArgs.cancelChanges = noop;\n          newArgs.compositeEditorOptions = options;\n          newArgs.formValues = {};\n\n          const currentEditor = new (column.editor as any)(newArgs) as Editor & { args: EditorArguments };\n          options.editors[column.id] = currentEditor; // add every Editor instance refs\n          editors.push(currentEditor);\n        }\n        idx++;\n      }\n\n      // focus on first input\n      setTimeout(function () {\n        if (Array.isArray(editors) && editors.length > 0 && typeof editors[0].focus === 'function') {\n          editors[0].focus();\n        }\n      }, 0);\n    }\n\n    context.destroy = () => {\n      let idx = 0;\n      while (idx < editors.length) {\n        editors[idx].destroy();\n        idx++;\n      }\n\n      options.destroy?.();\n      editors = [];\n    };\n\n\n    context.focus = () => {\n      // if validation has failed, set the focus to the first invalid editor\n      (firstInvalidEditor || editors[0]).focus();\n    };\n\n    context.isValueChanged = () => {\n      let idx = 0;\n      while (idx < editors.length) {\n        if (editors[idx].isValueChanged()) {\n          return true;\n        }\n        idx++;\n      }\n      return false;\n    };\n\n    context.serializeValue = () => {\n      const serializedValue: any[] = [];\n      let idx = 0;\n      while (idx < editors.length) {\n        serializedValue[idx] = editors[idx].serializeValue();\n        idx++;\n      }\n      return serializedValue;\n    };\n\n    context.applyValue = (item: any, state: any) => {\n      let idx = 0;\n      while (idx < editors.length) {\n        editors[idx].applyValue(item, state[idx]);\n        idx++;\n      }\n    };\n\n    context.loadValue = (item: any) => {\n      let idx = 0;\n\n      while (idx < editors.length) {\n        editors[idx].loadValue(item);\n        idx++;\n      }\n    };\n\n    context.validate = (target: HTMLElement | null) => {\n      let validationResults;\n      const errors: any[] = [];\n      let targetElm = target ? target : null;\n\n      firstInvalidEditor = null;\n\n      let idx = 0;\n      while (idx < editors.length) {\n        const columnDef = editors[idx].args?.column ?? {};\n        if (columnDef) {\n          let validationElm = document.querySelector(`.item-details-validation.editor-${columnDef.id}`);\n          let labelElm = document.querySelector(`.item-details-label.editor-${columnDef.id}`);\n          let editorElm = document.querySelector(`[data-editorid=${columnDef.id}]`);\n          const validationMsgPrefix = options?.validationMsgPrefix || '';\n\n          if (!targetElm || Slick.Utils.contains(editorElm as HTMLElement, targetElm)) {\n            validationResults = editors[idx].validate();\n\n            if (!validationResults.valid) {\n              firstInvalidEditor = editors[idx];\n              errors.push({\n                index: idx,\n                editor: editors[idx],\n                container: containers[idx],\n                msg: validationResults.msg\n              });\n\n              if (validationElm) {\n                validationElm.textContent = validationMsgPrefix + validationResults.msg;\n                labelElm?.classList.add('invalid');\n                editorElm?.classList.add('invalid');\n              }\n            } else if (validationElm) {\n              validationElm.textContent = '';\n              editorElm?.classList.remove('invalid');\n              labelElm?.classList.remove('invalid');\n            }\n          }\n          validationElm = null;\n          labelElm = null;\n          editorElm = null;\n        }\n        idx++;\n      }\n      targetElm = null;\n\n      if (errors.length) {\n        return {\n          valid: false,\n          msg: options.validationFailedMsg,\n          errors\n        };\n      } else {\n        return {\n          valid: true,\n          msg: ''\n        };\n      }\n    };\n\n    context.hide = () => {\n      let idx = 0;\n      while (idx < editors.length) {\n        editors[idx]?.hide?.();\n        idx++;\n      }\n      options?.hide?.();\n    };\n\n    context.show = () => {\n      let idx = 0;\n      while (idx < editors.length) {\n        editors[idx]?.show?.();\n        idx++;\n      }\n      options?.show?.();\n    };\n\n    context.position = (box: HtmlElementPosition) => {\n      options?.position?.(box);\n    };\n\n    init();\n  }\n\n  // so we can do \"editor instanceof Slick.CompositeEditor\n  // @ts-ignore\n  editor.prototype = this;\n  return editor;\n}\n\n// extend Slick namespace on window object when building as iife\nif (IIFE_ONLY && window.Slick) {\n  Utils.extend(Slick, {\n    CompositeEditor: SlickCompositeEditor\n  });\n}\n"],
  "mappings": "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",
  "names": []
}
