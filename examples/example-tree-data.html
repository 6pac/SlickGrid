<!DOCTYPE HTML>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link rel="shortcut icon" type="image/ico" href="favicon.ico" />
  <title>SlickGrid example 5: Tree Data with Filters</title>
  <link rel="stylesheet" href="../slick.grid.css" type="text/css" />
  <link rel="stylesheet" href="../css/smoothness/jquery-ui.css" type="text/css" />
  <link rel="stylesheet" href="examples.css" type="text/css" />
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"
    crossorigin="anonymous">
  <style>
    .fa {
      font-size: 13px;
      font-weight: 500;
    }

    .fa-folder-o,
    .fa-folder-open-o {
      color: orange;
    }

    .fa-file-pdf-o {
      color: #f14668;
    }

    .fa-file-audio-o {
      color: #3298dc;
    }

    .fa-file-excel-o {
      color: #1E9F75;
    }

    .cell-title {
      font-weight: bold;
    }

    .cell-effort-driven {
      text-align: center;
    }

    .slick-group-toggle {
      height: 9px;
      width: 9px;
      display: inline-block;
    }

    .slick-group-toggle.expand {
      background: url(../images/expand.gif) no-repeat center center;
    }

    .slick-group-toggle.collapse {
      background: url(../images/collapse.gif) no-repeat center center;
    }

    .slick-headerrow-column {
      background: #eff2f3;
      text-overflow: clip;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }

    .slick-headerrow-column input {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
  </style>
</head>

<body>
  <table width="100%">
    <tr>
      <div>
        <span>
          <button onclick="clearFilters()">Clear Filters</button>
        </span>
        ColumnFilters: <span id="currentColumnFilters"></span>
      </div>
      <td valign="top" width="40%">
        <br />
        <div id="myGrid" style="width:600px;height:550px;"></div>
      </td>
      <td valign="top">
        <h2>Demonstrates:</h2>
        <ul>
          <li>Implementing a Tree Data View with Filtering and Sorting</li>
          <li>The data can have unlimited tree depth coming from parent/child ref (parentId)</li>
          <li>You can filter "File Size" with operator prefix, for example ">3" (greater than 3Mb)</li>
        </ul>

        <h2>View Source:</h2>
        <ul>
          <li><A href="https://github.com/6pac/SlickGrid/blob/master/examples/example-tree-data.html"
              target="_sourcewindow"> View the source for this example on Github</a></li>
        </ul>
      </td>
    </tr>
  </table>

  <script src="../lib/firebugx.js"></script>

  <script src="../lib/jquery-1.12.4.min.js"></script>
  <script src="../lib/jquery-ui.min.js"></script>
  <script src="../lib/jquery.event.drag-2.3.0.js"></script>

  <script src="../slick.core.js"></script>
  <script src="../slick.grid.js"></script>
  <script src="../slick.dataview.js"></script>

  <script>
    var columnFilters = {};
    var tmpPreFilteredData = [];
    var dataView;
    var grid;
    var data = [];
    var columns = [
      { id: 'file', name: 'Files', field: 'file', width: 200, formatter: treeFormatter, sortable: true, },
      { id: 'dateModified', name: 'Date Modified', field: 'dateModified', sortable: true, minWidth: 90, },
      { id: 'size', name: 'Size', field: 'size', sortable: true, minWidth: 90, formatter: function (row, cell, value) { return isNaN(value) ? '' : `${value} MB`; } },
    ];

    var gridOptions = {
      editable: true,
      enableAddRow: true,
      enableCellNavigation: true,
      asyncEditorLoading: false,
      showHeaderRow: true,
      explicitInitialization: true,
      headerRowHeight: 30,
    };

    // Executed right after a search input change/keyup event BUT before the myFilter since that requires the result of this call
    function filterMyFiles(inputArray, treeObj, columnFilters) {
      
      const filteredChildrenAndParents = [];
      function outerFilter(treeObj, masterTreeObj, arrayOfParentIds){
        for (let id in treeObj) {
          const a = inputArray[i];
          let matchFilter = true; // valid until it is proven to be invalid

          // loop through all column filters and execute filter condition(s)
          for (const key in columnFilters) {
            if (a.hasOwnProperty(key)) {
              // check case insensitive:
              const strContains = String(a[key]).toLowerCase().includes(columnFilters[key].toLowerCase());
              // RegEx explained: https://regex101.com/r/w74GSk/13:
              const re = /(?:(?:^|[-+<>=_*/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-<>=]?\d+)?\s*))+$/;
              // according to mozilla using Function("return something") is better then eval() - and doesn't use eval
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Never_use_eval!
              const comparison = re.test(columnFilters[key]) && Function('return ' + a[key] + columnFilters[key])();
              if (strContains || comparison) {
                // don't return true as need to check other keys in columnFilters
              } else {
                matchFilter = false;
                continue;
              }
            } else {
              matchFilter = false;
              continue;
            }
          }

          // build an array from the matched filters, anything valid from filter condition
          // will be pushed to the filteredChildrenAndParents array
          if (matchFilter) {
            const itemCopy = {...a};
            delete itemCopy.__children;
            filteredChildrenAndParents.push(itemCopy);
            let parentID = arrayOfParentIds.shift()
            let parent = masterTreeObj[parentID] || false;
            while (parent) {
              const parentCopy = {...parent};
              delete parentCopy.__children;
              filteredChildrenAndParents.push(parentCopy);
              parentID = arrayOfParentIds.shift()
              parent = parent.__children[parentID] || false;
            }
            const childrenObj = treeObj[a.id].__children;
            //function to add all children recursively
            //as this parent matched, show all children
            function innerAddAll(child){        
              for (let id in child) {
                const childCopy = {...child[id]};
                delete childCopy.__children;
                console.log('copy', childCopy);
                filteredChildrenAndParents.push(childCopy);
                innerAddAll(child[id].__children);
              }
            }
            innerAddAll(childrenObj);
          } else{ //didn't match but children might match
            //call recursively this function
            const childrenObj = treeObj[a.id].__children;
            const copyOfParentIds = [...arrayOfParentIds, a.id];
            outerFilter(childrenObj, masterTreeObj, copyOfParentIds);
          }
        }  
      }
      outerFilter(treeObj, {...treeObj}, []);
      console.log('myObj', treeObj);
      console.log('filtered', filteredChildrenAndParents);
      return filteredChildrenAndParents;
    }

    function myFilter(item, columnFilters) {
      if (item.parentId !== null) {
        let parent = dataView.getItemById(item.parentId);
        while (parent) {
          if (parent.__collapsed) {
            return false; // don't display any row that have their parent collapsed
          }
          parent = dataView.getItemById(parent.parentId);
        }
      }

      // filter out any row items that aren't part of our pre-processed "filterMyFiles()" result
      if (Array.isArray(tmpPreFilteredData)) {
        for (var columnId in columnFilters) {
          return tmpPreFilteredData.find(function (obj) { return obj.id == item.id });
          //return tmpPreFilteredData.includes(item.id); // return true when found, false otherwise
        }
      }

      // anything is considered valid
      return true;
    }

    function onSearchKeyupEvent(e) {
      var columnId = $(this).data("columnId");
      if (columnId != null) {
        var searchString = $.trim($(this).val());
        if (searchString === '') {
          delete columnFilters[columnId];
        } else {
          columnFilters[columnId] = searchString;
        }

        // display current columnFilters in the DOM
        document.querySelector('#currentColumnFilters').textContent = JSON.stringify(columnFilters);

        // step 1. filter the files 
        tmpPreFilteredData = filterMyFiles(data, treeData, columnFilters);

        // step 2. call the refresh so it does the final filtering of which rows should persist
        // calling dataview refresh is what triggers the myFilter()
        dataView.refresh();
      }
    }

    $(function () {
      // prepare the data "__treeLevel" is required for the treeFormatter to work correctly
      // very important, the data must be pre-sorted as to how it should be displayed in the UI
      data = [
        { id: 18, file: "alone.txt", dateModified: "2015-03-03", size: 90, __treeLevel: 0, parentId: null, },
        { id: 21, file: "Documents", parentId: null, __treeLevel: 0 },
        { id: 9, file: "misc", __treeLevel: 1, parentId: 21 },
        { id: 23,  file: "something2.txt", dateModified: "2015-02-26", size: 0.4, __treeLevel: 2,  parentId: 9 },
        { id: 10, file: "something.txt", dateModified: "2015-02-26", size: 0.4, __treeLevel: 2, parentId: 9, },
        { id: 4, file: "pdf", __treeLevel: 1, parentId: 21 },
        { id: 6, file: "internet-bill.pdf", dateModified: "2015-05-12", size: 1.4, __treeLevel: 2, parentId: 4, },
        { id: 5, file: "map.pdf", dateModified: "2015-05-21", size: 3.1, __treeLevel: 2, parentId: 4, },
        { id: 22, file: "map2.pdf", dateModified: "2015-05-21", size: 2.9, __treeLevel: 2, parentId: 4, },
        { id: 2, file: "txt", __treeLevel: 1, parentId: 21 },
        { id: 3, file: "todo.txt", dateModified: "2015-05-12", size: 0.7, __treeLevel: 2, parentId: 2, },
        { id: 7, file: "xls", __treeLevel: 1, parentId: 21 },
        { id: 8, file: "compilation.xls", dateModified: "2014-10-02", size: 2.3, __treeLevel: 2, parentId: 7, },
        { id: 11, file: "Music", __treeLevel: 0, parentId: null },
        { id: 12, file: "mp3", __treeLevel: 1, parentId: 11 },
        { id: 14, file: "pop", __treeLevel: 2, parentId: 12 },
        { id: 15, file: "theme.mp3", dateModified: "2015-03-01", size: 85, __treeLevel: 3, parentId: 14, },
        { id: 16, file: "rock", __treeLevel: 2, parentId: 12 },
        { id: 17, file: "soft.mp3", dateModified: "2015-05-13", size: 98, __treeLevel: 3, parentId: 16, }       
      ];

      treeData = {};
      for (let i = 0; i < data.length; i++) {
        treeData[data[i].id] = data[i];
        //new nested tree object creation if the data is sorted as it should appear as it says in the comments
        //then this will work if it is not sorted then children could come before parents and this would fail
        //it could be made to account for that too but if we don't need to there's no point:
        const j = data.length - 1 - i;
        //line above just reverses the loop direction using j instead of i
        if (data[j].parentId != null){
          //then it's not the level 0 folder
          if ( treeData.hasOwnProperty(data[j].id) ){
            //then its child already created its parent folder
            //so merge the current children and the parent itself:
            treeData[data[j].id] = {...data[j], ...treeData[data[j].id]};      
            //now we need to create this folder's parent and delete this key:
            const newChild = {[data[j].id]: treeData[data[j].id]};
            if ( !treeData.hasOwnProperty(data[j].parentId) ){
              //the parent wasn't yet created so do this:
              treeData[data[j].parentId] = {};
              treeData[data[j].parentId].__children = {};
            }
            const currChildren = treeData[data[j].parentId].__children;
            treeData[data[j].parentId].__children = {...currChildren, ...newChild};
            //now delete this key and its data (already contained in parent's children):
            delete treeData[data[j].id];
          } else{
            //then this is a file/folder with no children
            if ( !treeData.hasOwnProperty(data[j].parentId) ){
              //the parent wasn't yet created so do this          
              treeData[data[j].parentId] = {};
              //otherwise it is another file/folder sharing a parent (but with no children)
              //and this parent was already created
            } 
            const children = treeData[data[j].parentId].__children || {};
            const newChild = data[j];
            const newChildren = {...children, [data[j].id]: newChild};
            //console.log(i, 'newChildren', newChildren)
            treeData[data[j].parentId].__children = newChildren;
          }            
        } else { //is the level 0 file/folder:
          if ( !treeData.hasOwnProperty(data[j].id) ){
            //then it also doesn't have any children
            //so they didnt create its key
            //so let's make it:
            treeData[data[j].id] = {};
          }
          const children = treeData[data[j].id].__children || {};
          const newParent = data[j];          
          treeData[data[j].id] = {...newParent, __children: children};
        }    
      }
      console.log('tree', treeData);

      // initialize the model
      dataView = new Slick.Data.DataView();

      // initialize the grid
      grid = new Slick.Grid("#myGrid", dataView, columns, gridOptions);

      // add search input on top of each column
      grid.onHeaderRowCellRendered.subscribe(function (e, args) {
        $(args.node).empty();
        $("<input type='text'>")
          .data("columnId", args.column.id)
          .val(columnFilters[args.column.id])
          .appendTo(args.node);
      });

      // bind change/keyup events to search inputs and execute onSearchKeyupEvent() callback
      $(grid.getHeaderRow()).on("change keyup", ":input", onSearchKeyupEvent);

      // on a cell click event, we'll analyze if the cell is a parent, if it is then we'll toggle the collapse
      grid.onClick.subscribe(function (e, args) {
        if ($(e.target).hasClass("slick-group-toggle")) {
          var item = dataView.getItem(args.row);
          if (item) {
            item.__collapsed = !item.__collapsed;
            dataView.updateItem(item.id, item);
            grid.invalidate();
          }
          e.stopImmediatePropagation();
        }
      });

      // wire up model events to drive the grid
      dataView.onRowCountChanged.subscribe(function (e, args) {
        grid.updateRowCount();
        grid.render();
      });

      dataView.onRowsChanged.subscribe(function (e, args) {
        grid.invalidateRows(args.rows);
        grid.render();
      });

      // initialize grid & dataview
      grid.init();
      grid.autosizeColumns();
      dataView.beginUpdate();
      dataView.setItems(data);
      dataView.setFilterArgs(columnFilters);
      dataView.setFilter(myFilter);
      dataView.endUpdate();
    });

    function clearFilters() {
      $('.slick-headerrow-column').children().val('').keyup();
      for (var columnId in columnFilters) {
        columnFilters[columnId] = "";
      }
      dataView.refresh();
    }

    function treeFormatter(row, cell, value, columnDef, dataContext, grid) {
      const treeLevelPropName = '__treeLevel';
      if (value === null || value === undefined || dataContext === undefined) {
        return '';
      }
      const dataView = grid.getData();
      const data = dataView.getItems();
      const identifierPropName = dataView.getIdPropertyName() || 'id';
      const idx = dataView.getIdxById(dataContext[identifierPropName]);
      const prefix = getFileIcon(value);

      value = value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      const spacer = `<span style="display:inline-block; width:${(15 * dataContext[treeLevelPropName])}px;"></span>`;

      if (data[idx + 1] && data[idx + 1][treeLevelPropName] > data[idx][treeLevelPropName]) {
        const folderPrefix = `<i class="fa ${dataContext.__collapsed ? 'fa-folder-o' : 'fa-folder-open-o'}"></i>`;
        if (dataContext.__collapsed) {
          return `${spacer} <span class="slick-group-toggle collapsed" level="${dataContext[treeLevelPropName]}"></span>${folderPrefix} ${prefix}&nbsp;${value}`;
        } else {
          return `${spacer} <span class="slick-group-toggle expanded" level="${dataContext[treeLevelPropName]}"></span>${folderPrefix} ${prefix}&nbsp;${value}`;
        }
      } else {
        return `${spacer} <span class="slick-group-toggle" level="${dataContext[treeLevelPropName]}"></span>${prefix}&nbsp;${value}`;
      }
    }

    function getFileIcon(value) {
      let prefix = '';
      if (value.includes('.pdf')) {
        prefix = '<i class="fa fa-file-pdf-o"></i>';
      } else if (value.includes('.txt')) {
        prefix = '<i class="fa fa-file-o"></i>';
      } else if (value.includes('.xls')) {
        prefix = '<i class="fa fa-file-excel-o"></i>';
      } else if (value.includes('.mp3')) {
        prefix = '<i class="fa fa-file-audio-o"></i>';
      }
      return prefix;
    }
  </script>
</body>

</html>