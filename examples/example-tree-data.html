<!DOCTYPE HTML>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link rel="shortcut icon" type="image/ico" href="favicon.ico" />
  <title>SlickGrid example 5: Tree Data with Filters</title>
  <link rel="stylesheet" href="../slick.grid.css" type="text/css" />
  <link rel="stylesheet" href="../css/smoothness/jquery-ui.css" type="text/css" />
  <link rel="stylesheet" href="examples.css" type="text/css" />
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"
    crossorigin="anonymous">
  <style>
    .fa {
      font-size: 13px;
      font-weight: 500;
    }

    .fa-folder-o,
    .fa-folder-open-o {
      color: orange;
    }

    .fa-file-pdf-o {
      color: #f14668;
    }

    .fa-file-audio-o {
      color: #3298dc;
    }

    .fa-file-excel-o {
      color: #1E9F75;
    }

    .cell-title {
      font-weight: bold;
    }

    .cell-effort-driven {
      text-align: center;
    }

    .slick-group-toggle {
      height: 9px;
      width: 9px;
      display: inline-block;
    }

    .slick-group-toggle.expand {
      background: url(../images/expand.gif) no-repeat center center;
    }

    .slick-group-toggle.collapse {
      background: url(../images/collapse.gif) no-repeat center center;
    }

    .slick-headerrow-column {
      background: #eff2f3;
      text-overflow: clip;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }

    .slick-headerrow-column input {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
  </style>
</head>

<body>
  <table width="100%">
    <tr>
      <div>
        <span>
          <button onclick="clearFilters()">Clear Filters</button>
        </span>
        ColumnFilters: <span id="currentColumnFilters"></span>
      </div>
      <td valign="top" width="40%">
        <br />
        <div id="myGrid" style="width:600px;height:550px;"></div>
      </td>
      <td valign="top">
        <h2>Demonstrates:</h2>
        <ul>
          <li>Implementing a Tree Data View with Filtering and Sorting</li>
          <li>The data can have unlimited tree depth coming from parent/child ref (parentId)</li>
          <li>You can filter "File Size" with operator prefix, for example ">3" (greater than 3Mb)</li>
        </ul>

        <h2>View Source:</h2>
        <ul>
          <li><A href="https://github.com/6pac/SlickGrid/blob/master/examples/example-tree-data.html"
              target="_sourcewindow"> View the source for this example on Github</a></li>
        </ul>
      </td>
    </tr>
  </table>

  <script src="../lib/firebugx.js"></script>

  <script src="../lib/jquery-1.12.4.min.js"></script>
  <script src="../lib/jquery-ui.min.js"></script>
  <script src="../lib/jquery.event.drag-2.3.0.js"></script>

  <script src="../slick.core.js"></script>
  <script src="../slick.grid.js"></script>
  <script src="../slick.dataview.js"></script>
  <script src="../plugins/slick.treedata.js"></script>

  <script>
    var columnFilters = {};
    var tmpPreFilteredData = [];
    var dataView;
    var grid;
    var data = [];
    var myOptions = {
      parentPropName: 'parentId',
      childrenPropName: 'files',
      identifierPropName: 'id',
      treeLevelPropName: '__treeLevel',
      treeOutputType: {}, //Object of Objects rather than default array of objects
      aggregatorProps: ['size']
    };
    var treeData = {};
    var dataHierarchical = [];
    var columns = [
      { id: 'file', name: 'Files', field: 'file', width: 200, formatter: treeFormatter, sortable: true, },
      { id: 'dateModified', name: 'Date Modified', field: 'dateModified', sortable: true, minWidth: 90, },
      { id: 'size', name: 'Size', field: 'size', sortable: true, minWidth: 90, formatter: sizeFormatter },
    ];

    var gridOptions = {
      editable: true,
      enableAddRow: true,
      enableCellNavigation: true,
      asyncEditorLoading: false,
      showHeaderRow: true,
      explicitInitialization: true,
      headerRowHeight: 30,
      excludeChildrenWhenTreeDataFiltering: true
    };

    // Executed right after a search input change/keyup event BUT before the myFilter since that requires the result of this call
    function filterMyFiles(inputArray, treeObj, columnFilters, options) {
      //console.log(options);
      const childrenPropName = options && options.childrenPropName || 'children';
      const parentPropName = options && options.parentPropName || '__parentId';
      const identifierPropName = options && options.identifierPropName || 'id';
      const treeLevelPropName = options && options.treeLevelPropName || '__treeLevel';
      const hasChildrenFlagPropName = options && options.hasChildrenFlagPropName || '__hasChildren';

      const filteredChildrenAndParents = [];
      function outerFilter(treeObj, masterTreeObj, arrayOfParentIds, filterKeys) {
        const iterable = (treeObj instanceof Array) ?
          treeObj :
          Object.values(treeObj) || [];
        for (let id of iterable) {
          const a = id;
          let matchFilter = false; // invalid until it is proven to be valid

          //make a copy each time so each recursion sibling has a fresh array:
          const copyOfFilters = [...filterKeys]
          // loop through all column filters and execute filter condition(s):
          for (let i = 0; i < copyOfFilters.length; i++) {
            const key = copyOfFilters[i];
            if (a.hasOwnProperty(key) ||
              (gridOptions.excludeChildrenWhenTreeDataFiltering &&
                a.hasOwnProperty(`__agg__${key}`))) {

              const keyOrAggKey = a.hasOwnProperty(key) ? key : `__agg__${key}`;
              // check case insensitive:
              const strContains = String(a[keyOrAggKey]).toLowerCase().includes(columnFilters[key].toLowerCase());
              // RegEx explained: https://regex101.com/r/w74GSk/13:
              const re = /(?:(?:^|[-+<>=_*/])(?:\s*-?\d+(\.\d+)?(?:[eE][+-<>=]?\d+)?\s*))+$/;
              // according to mozilla using Function("return something") is better then eval() - and doesn't use eval
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Never_use_eval!
              const comparison = re.test(columnFilters[key]) && Function('return ' + a[keyOrAggKey] + columnFilters[key])();
              if (strContains || comparison) {
                // one filter matched remove this from the copyOfFilters
                matchFilter = true;
                copyOfFilters.splice(i, 1);
                i--; //the next filter has now moved one place back                       
              } else {
                continue;
              }
            } else {
              continue;
            }
          }

          // build an array from the matched filters, anything valid from filter condition
          // will be pushed to the filteredChildrenAndParents array
          if (matchFilter && copyOfFilters.length == 0) { //all filters matched
            const itemCopy = { ...a };
            delete itemCopy[childrenPropName];
            filteredChildrenAndParents.push(itemCopy);
            let parentID = arrayOfParentIds.shift()
            //now works with nested array of objects or object of objects:
            let parent = (masterTreeObj instanceof Array) ?
              masterTreeObj.find(val => val[identifierPropName] == parentID) || false :
              masterTreeObj[parentID] || false;
            while (parent) {
              const parentCopy = { ...parent };
              delete parentCopy[childrenPropName];
              filteredChildrenAndParents.push(parentCopy);
              parentID = arrayOfParentIds.shift()
              const parentsChildren = parent[childrenPropName];
              //now works with nested array of objects or object of objects:
              parent = (parentsChildren instanceof Array) ?
                parentsChildren.find(val => val[identifierPropName] == parentID) || false :
                parentsChildren[parentID] || false;
            }
            const childrenObj = a[childrenPropName];
            //function to add all children recursively
            //as this parent matched, show all children
            function innerAddAll(child) {
              //now works with nested array of objects or object of objects:
              const iterable = (child instanceof Array) ?
                child :
                Object.values(child) || [];
              for (let id of iterable) {
                const childCopy = { ...id };
                delete childCopy[childrenPropName];
                filteredChildrenAndParents.push(childCopy);
                id[childrenPropName] && innerAddAll(id[childrenPropName]);
              }
            }
            childrenObj && innerAddAll(childrenObj);
          } else {
            // either didn't match at all
            //or one or more filters matched but not all
            //but children might match
            //call recursively this function
            const childrenObj = a[childrenPropName] || false;
            const copyOfParentIds = [...arrayOfParentIds, a[identifierPropName]];
            if (gridOptions.excludeChildrenWhenTreeDataFiltering) {
              //call it with the full filterKeys - i.e. only ever match when one file/folder matches all filters
              childrenObj && outerFilter(childrenObj, masterTreeObj, copyOfParentIds, filterKeys);
            } else {
              //call it with the limited filters - i.e. if some already passed don't pass them down:
              childrenObj && outerFilter(childrenObj, masterTreeObj, copyOfParentIds, copyOfFilters);
            }
          }
        }
      }
      //now works with nested array of objects or object of objects:
      const treeCopy = (treeObj instanceof Array) ? [...treeObj] : { ...treeObj };
      const filterKeys = Object.keys(columnFilters);
      outerFilter(treeCopy, treeObj, [], filterKeys);
      //console.log('myObj', treeObj);
      //console.log('filtered', filteredChildrenAndParents);
      return filteredChildrenAndParents;
    }

    function myFilter(item, columnFilters) {
      if (item.parentId !== null) {
        let parent = dataView.getItemById(item.parentId);
        while (parent) {
          if (parent.__collapsed) {
            return false; // don't display any row that have their parent collapsed
          }
          parent = dataView.getItemById(parent.parentId);
        }
      }

      // filter out any row items that aren't part of our pre-processed "filterMyFiles()" result
      if (Array.isArray(tmpPreFilteredData)) {
        for (var columnId in columnFilters) {
          const filteredItem = tmpPreFilteredData.find(function (obj) { return obj.id == item.id });
          myOptions.aggregatorProps.forEach((aggKey) => {
            if (filteredItem && filteredItem.hasOwnProperty('__agg__' + aggKey)) {
              item['__agg__' + aggKey] = filteredItem['__agg__' + aggKey]; // copy the aggregator to the item
            }
          });
          return !!filteredItem; // should return boolean, not the actual item
          //return tmpPreFilteredData.includes(item.id); // return true when found, false otherwise
        }
      }

      // anything is considered valid
      return true;
    }

    function onSearchKeyupEvent(e) {
      var columnId = $(this).data("columnId");
      if (columnId != null) {
        var searchString = $.trim($(this).val());
        if (searchString === '') {
          delete columnFilters[columnId];
        } else {
          columnFilters[columnId] = searchString;
        }

        // display current columnFilters in the DOM
        document.querySelector('#currentColumnFilters').textContent = JSON.stringify(columnFilters);

        // step 1. filter the files 
        tmpPreFilteredData = filterMyFiles(data, dataHierarchical, columnFilters, myOptions);

        // step 2. call the refresh so it does the final filtering of which rows should persist
        // calling dataview refresh is what triggers the myFilter()
        dataView.refresh();
      }
    }

    $(function () {
      // prepare the data "__treeLevel" is required for the treeFormatter to work correctly
      // very important, the data must be pre-sorted as to how it should be displayed in the UI
      data = [
        { id: 18, file: "alone.txt", dateModified: "2015-03-03", size: 90, __treeLevel: 0, parentId: null, },
        { id: 21, file: "Documents", parentId: null, __treeLevel: 0 },
        { id: 9, file: "misc", __treeLevel: 1, parentId: 21 },
        { id: 23, file: "something2.txt", dateModified: "2015-02-26", size: 0.4, __treeLevel: 2, parentId: 9 },
        { id: 10, file: "something.txt", dateModified: "2015-02-26", size: 0.4, __treeLevel: 2, parentId: 9, },
        { id: 4, file: "pdf", __treeLevel: 1, parentId: 21 },
        { id: 6, file: "internet-bill.pdf", dateModified: "2015-05-12", size: 1.4, __treeLevel: 2, parentId: 4, },
        { id: 5, file: "map.pdf", dateModified: "2015-05-21", size: 3.1, __treeLevel: 2, parentId: 4, },
        { id: 22, file: "map2.pdf", dateModified: "2015-05-21", size: 2.9, __treeLevel: 2, parentId: 4, },
        { id: 2, file: "txt", __treeLevel: 1, parentId: 21 },
        { id: 3, file: "todo.txt", dateModified: "2015-05-12", size: 0.7, __treeLevel: 2, parentId: 2, },
        { id: 7, file: "xls", __treeLevel: 1, parentId: 21 },
        { id: 8, file: "compilation.xls", dateModified: "2014-10-02", size: 2.3, __treeLevel: 2, parentId: 7, },
        { id: 11, file: "Music", __treeLevel: 0, parentId: null },
        { id: 12, file: "mp3", __treeLevel: 1, parentId: 11 },
        { id: 14, file: "pop", __treeLevel: 2, parentId: 12 },
        { id: 15, file: "theme.mp3", dateModified: "2015-03-01", size: 85, __treeLevel: 3, parentId: 14, },
        { id: 16, file: "rock", __treeLevel: 2, parentId: 12 },
        { id: 17, file: "soft.mp3", dateModified: "2015-05-13", size: 98, __treeLevel: 3, parentId: 16, }
      ];

      // initialize the model
      dataView = new Slick.Data.DataView();

      // initialize the grid
      grid = new Slick.Grid("#myGrid", dataView, columns, gridOptions);

      // load tree data utilities
      treeDataUtilities = new Slick.Plugins.TreeData();

      //can use the util to convert the flat array of objects to an nested object of objects:
      treeData = treeDataUtilities.convertParentChildFlatArrayToHierarchicalView(data, myOptions)
      console.log('tree', treeData);

      //can use the util to convert the nested object of objects (back) to a flat array of objects:
      console.log('flat', treeDataUtilities.convertHierarchicalViewToFlatArray(treeData, myOptions))

      // add search input on top of each column
      grid.onHeaderRowCellRendered.subscribe(function (e, args) {
        $(args.node).empty();
        $("<input type='text'>")
          .data("columnId", args.column.id)
          .val(columnFilters[args.column.id])
          .appendTo(args.node);
      });

      // bind change/keyup events to search inputs and execute onSearchKeyupEvent() callback
      $(grid.getHeaderRow()).on("change keyup", ":input", onSearchKeyupEvent);

      // on a cell click event, we'll analyze if the cell is a parent, if it is then we'll toggle the collapse
      grid.onClick.subscribe(function (e, args) {
        if ($(e.target).hasClass("slick-group-toggle")) {
          var item = dataView.getItem(args.row);
          if (item) {
            item.__collapsed = !item.__collapsed;
            dataView.updateItem(item.id, item);
            grid.invalidate();
          }
          e.stopImmediatePropagation();
        }
      });

      // wire up model events to drive the grid
      dataView.onRowCountChanged.subscribe(function (e, args) {
        grid.updateRowCount();
        grid.render();
      });

      dataView.onRowsChanged.subscribe(function (e, args) {
        grid.invalidateRows(args.rows);
        grid.render();
      });

      // initialize grid & dataview
      grid.init();
      grid.autosizeColumns();
      dataView.beginUpdate();
      dataView.setItems(data);
      dataView.setFilterArgs(columnFilters);
      dataView.setFilter(myFilter);
      dataView.endUpdate();
      const myOptionsMod = { ...myOptions, treeOutputType: [] };
      dataHierarchical = treeDataUtilities.convertParentChildFlatArrayToHierarchicalView(data, myOptionsMod);
      console.log('array objects', dataHierarchical);
    });

    function clearFilters() {
      $('.slick-headerrow-column').children().val('').keyup();
      for (var columnId in columnFilters) {
        columnFilters[columnId] = "";
      }
      dataView.refresh();
    }

    function sizeFormatter(row, cell, value, columnDef, dataContext, grid) {
      let output = '';

      if (dataContext.__agg__size !== undefined) {
        return isNaN(dataContext.__agg__size) ? '' : `<b>${dataContext.__agg__size.toFixed(2)} MB</b>`;
      }
      return isNaN(value) ? '' : `${value} MB`;
    }

    function treeFormatter(row, cell, value, columnDef, dataContext, grid) {
      const treeLevelPropName = '__treeLevel';
      if (value === null || value === undefined || dataContext === undefined) {
        return '';
      }
      const dataView = grid.getData();
      const data = dataView.getItems();
      const identifierPropName = dataView.getIdPropertyName() || 'id';
      const idx = dataView.getIdxById(dataContext[identifierPropName]);
      const prefix = getFileIcon(value);

      value = value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      const spacer = `<span style="display:inline-block; width:${(15 * dataContext[treeLevelPropName])}px;"></span>`;

      if (data[idx + 1] && data[idx + 1][treeLevelPropName] > data[idx][treeLevelPropName]) {
        const folderPrefix = `<i class="fa ${dataContext.__collapsed ? 'fa-folder-o' : 'fa-folder-open-o'}"></i>`;
        if (dataContext.__collapsed) {
          return `${spacer} <span class="slick-group-toggle collapsed" level="${dataContext[treeLevelPropName]}"></span>${folderPrefix} ${prefix}&nbsp;${value}`;
        } else {
          return `${spacer} <span class="slick-group-toggle expanded" level="${dataContext[treeLevelPropName]}"></span>${folderPrefix} ${prefix}&nbsp;${value}`;
        }
      } else {
        return `${spacer} <span class="slick-group-toggle" level="${dataContext[treeLevelPropName]}"></span>${prefix}&nbsp;${value}`;
      }
    }

    function getFileIcon(value) {
      let prefix = '';
      if (value.includes('.pdf')) {
        prefix = '<i class="fa fa-file-pdf-o"></i>';
      } else if (value.includes('.txt')) {
        prefix = '<i class="fa fa-file-o"></i>';
      } else if (value.includes('.xls')) {
        prefix = '<i class="fa fa-file-excel-o"></i>';
      } else if (value.includes('.mp3')) {
        prefix = '<i class="fa fa-file-audio-o"></i>';
      }
      return prefix;
    }
  </script>
</body>

</html>